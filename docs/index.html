<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>FSD Weekly</title>

  
  <meta name="author" content="FSD Weekly">
  

  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="FSD Weekly"/>

  
  <meta property="og:image" content="/fsd/favicon.ico"/>
  

  <link href="/fsd/favicon.ico" rel="icon">
  <link rel="alternate" href="/fsd/atom.xml" title="FSD Weekly" type="application/atom+xml">
  <link rel="stylesheet" href="/fsd/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/fsd/">FSD Weekly</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/fsd/">主页</a></li>
      
        <li><a href="/fsd/archives">归档</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/fsd/2017/10/27/weekly-18/"><span>大前端周刊 第18期 （本期小编：包京京）</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/fsd/2017/10/27/weekly-18/" rel="bookmark">
        <time class="entry-date published" datetime="2017-10-27T02:24:12.000Z">
          2017-10-27
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="Show-me-the-code"><a href="#Show-me-the-code" class="headerlink" title="Show me the code"></a>Show me the code</h2><h3 id="用Javascript学习数据结构之栈-Stack"><a href="#用Javascript学习数据结构之栈-Stack" class="headerlink" title="用Javascript学习数据结构之栈(Stack)"></a>用Javascript学习数据结构之栈(Stack)</h3><p>栈(Stack)是一种遵循后进先出（LIFO）的有序集合，较新的元素会靠近顶部，较旧的元素会在栈的底部。<br>接下来我们正式开始实现栈（Stack）。首先，建立一个Stack类：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stack</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 类内部定义Stack的属性和方法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="属性："><a href="#属性：" class="headerlink" title="属性："></a>属性：</h4><ol>
<li>let items = []; //使用array来存储栈内的元素</li>
</ol>
<h4 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h4><ol>
<li>push(elements): 新增一个或者多个元素到栈的顶部</li>
<li>pop(): 移除栈顶部元素，同时返回被移除的元素</li>
<li>peek()或top(): 仅返回stack元素，不做任何修改</li>
<li>isEmpty(): 检查栈是否为空？若无任何元素则返回true，反之返回false</li>
<li>clear(): 清空栈内的所有元素</li>
<li>size(): 返回栈的元素个数</li>
</ol>
<h4 id="1-push-elements-和pop"><a href="#1-push-elements-和pop" class="headerlink" title="1.push(elements)和pop()"></a>1.push(elements)和pop()</h4><p>由于我们使用array当做stack的存储方式，所以我们可以使用array内建的push(element)和pop()方式来实现LIFO的特性，让元素的新增和删除只能发生在尾端。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stack</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> items = [];</div><div class="line">    <span class="keyword">this</span>.push = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</div><div class="line">        items.push(element);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.pop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> items.pop();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="2-peek-："><a href="#2-peek-：" class="headerlink" title="2.peek()："></a>2.peek()：</h4><p>若是我们想知道栈中的最后一个元素（最顶端的元素），我们可以实现peek()方法，返回顶部元素<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stack</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> items = [];</div><div class="line">    <span class="keyword">this</span>.peek = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> items[items.length - <span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="3-isEmpty-："><a href="#3-isEmpty-：" class="headerlink" title="3.isEmpty()："></a>3.isEmpty()：</h4><p>若我们想知道栈内是否还有元素，我们可以使用isEmpty()来判断<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stack</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> items = [];</div><div class="line">    <span class="keyword">this</span>.isEmpty = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> items.length === <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="4-clear-："><a href="#4-clear-：" class="headerlink" title="4.clear()："></a>4.clear()：</h4><p>若我们想清空栈的话，可以使用clear()方法，将所有元素删除<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stack</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> items = [];</div><div class="line">    <span class="keyword">this</span>.clear = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        items = [];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="5-size-："><a href="#5-size-：" class="headerlink" title="5.size()："></a>5.size()：</h4><p>通过size()方法我们可以取得栈的大小（共有几个元素）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stack</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> items = [];</div><div class="line">    <span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> items.length;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="完整代码："><a href="#完整代码：" class="headerlink" title="完整代码："></a>完整代码：</h4><p>把上面各种方法放到一起<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stack</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> items = [];</div><div class="line">    <span class="keyword">this</span>.push = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</div><div class="line">        items.push(element);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.pop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> items.pop();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.peek = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> items[items.length - <span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.isEmpty = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> items.length === <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.clear = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        items = [];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> items.length;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 加入打印方法</span></div><div class="line">    <span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(items.toString());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="插件推荐"><a href="#插件推荐" class="headerlink" title="插件推荐"></a>插件推荐</h2><ul>
<li><a href="http://phantomjs.org/" target="_blank" rel="external">PhantomJS</a><br>PhantomJS可以应用于下面这几个典型场景：无需浏览器的web测试，页面自动化操作，屏幕截图和网络监控等</li>
</ul>
<h2 id="文章推荐"><a href="#文章推荐" class="headerlink" title="文章推荐"></a>文章推荐</h2><ul>
<li><p><a href="http://www.jdon.com/idea/nodejs/event-loop.html" target="_blank" rel="external">Node.js的事件轮询Event Loop原理解释</a><br>Event Loop是理解Node实现事件驱动、异步高并发服务的关键。这篇文章中解释了下面几个容易被忽略的点： 1. Node.js的底层其实也是有一个线程池的，用来执行各种堵塞操作。2. 一个Event loop的三个基本组件：事件队列、读取事件的轮询线程、以及线程池。3. 各个事件的回调函数是如何激活并执行的。</p>
</li>
<li><p><a href="http://www.qdfuns.com/notes/16738/1b6ad6125747d28592a53a960b44c6f4.html" target="_blank" rel="external">jsonp原理详解</a><br>jsonp不是ajax的一个特例，哪怕jquery等巨头把jsonp封装进了ajax，也不能改变这一点！</p>
</li>
<li><p><a href="https://juejin.im/post/59bfe84351882531b730bac2" target="_blank" rel="external">this , apply , call , bind详解</a><br>几个ES5 的坑，this是其中经常搞晕的一个，上一篇通俗且易理解的文章</p>
</li>
<li><p><a href="http://taobaofed.org/blog/2017/08/31/nodejs-stream/" target="_blank" rel="external">深入理解 Node.js Stream 内部机制</a><br>知其然知其所以然，来了解一下nodejs stream内部机制。</p>
</li>
<li><p><a href="https://segmentfault.com/a/1190000011699304" target="_blank" rel="external">基于 Electron 开发客户端产品的体验</a><br>基于 Electron 开发的产品非常多，文章主要是针对于如何入门 Electron，可以说是作者开发的总结；非常适合计划使用 Electron的开发者阅读。</p>
</li>
<li><p><a href="https://juejin.im/post/59ec657ef265da431b6c5b03" target="_blank" rel="external">babel到底该如何配置？</a><br>大家都知道js作为宿主语言，很依赖执行的环境（浏览器、node等），不同环境对js语法的支持不尽相同，特别是ES6之后，ECMAScrip对版本的更新已经到了一年一次的节奏，虽然每年更新的幅度不大，但是每年的提案可不少。babel的出现就是为了解决这个问题，把那些使用新标准编写的代码转译为当前环境可运行的代码，简单点说就是把ES6代码转译（转码+编译）到ES5。</p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/27502596" target="_blank" rel="external">CSS 新的长度单位 fr 你知道么？</a><br>本文介绍了 CSS Grid 规范中引入的一个新的长度单位 fr，我们一起来看看到底是怎么回事吧！</p>
</li>
<li><p><a href="https://qiutc.me/post/resource-optimization-webpack.html" target="_blank" rel="external">使用 webpack 优化资源</a><br>本片文章中主要是基于 webpack 打包，以 React、vue 等生态开发的单页面应用来举例说明如何从 webpack 打包的层面去处理资源以及缓存，其中主要我们需要做的是对 webpack 进行配置的优化，同时涉及少量的业务代码的更改。</p>
</li>
<li><p><a href="http://www.ruanyifeng.com/blog/2012/06/sass.html" target="_blank" rel="external">SASS用法指南</a><br>今年TalkingData团队将 CSS 预处理器切换到了 SASS，代码层面只是简单直接的做了风格转换，还没有挖掘出 SASS 更深入的能力。本周推荐一篇 SASS “基础”内容，推荐大家阅读和实践，以提升大家在 CSS 方面的编程能力。</p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/29450092" target="_blank" rel="external">VirtualDOM与diff(Vue实现)</a><br>我们是不是可以把真实DOM树抽象成一棵以JavaScript对象构成的抽象树，在修改抽象树数据后将抽象树转化成真实DOM重绘到页面上呢？于是虚拟DOM出现了，它是真实DOM的一层抽象，用属性描述真实DOM的各个特性。当它发生变化的时候，就会去修改视图。</p>
</li>
<li><p><a href="http://wetest.qq.com/lab/view/316.html" target="_blank" rel="external">多“维”优化——前端高并发策略的更深层思考</a><br>一项指标的变好，总少不了相应优化策略的实施。优化并不是简单的一蹴而就，而是个不断迭代与推翻的过程。更深层的优化方案，往往是在某种思维策略之下，对问题场景和基本策略优缺的深刻理解后做出的当下最优的权衡结果——作者导读。</p>
</li>
<li><p><a href="https://juejin.im/entry/59bcce1b5188257e82676b53" target="_blank" rel="external">Egg 源码解析之 egg-cluster</a><br>Node.js 进程只能运行在一个 CPU 上，而 egg 采用多进程模型，使多核 CPU 的性能发挥到极致，最大程度地榨干服务器资源，进而解决了该问题。egg-cluster 是用于 egg 多进程管理的基础模块，负责底层的 IPC 通道的建立以及处理各进程的通信，本文解析了实现原理，值得一看。</p>
</li>
</ul>
<h2 id="招聘"><a href="#招聘" class="headerlink" title="招聘"></a>招聘</h2><p>TalkingData DTU 可视化团队招聘：</p>
<ul>
<li>资深前端工程师</li>
</ul>
<p>简历投递：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> email = <span class="string">'xiang.wang#tendcloud.com'</span>.replace(<span class="string">'#'</span>, <span class="string">'@'</span>);</div><div class="line"><span class="built_in">console</span>.log(email);</div></pre></td></tr></table></figure></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/fsd/2017/10/20/weekly-17/"><span>大前端周刊 第17期 （本期小编：耿少真）</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/fsd/2017/10/20/weekly-17/" rel="bookmark">
        <time class="entry-date published" datetime="2017-10-20T02:24:12.000Z">
          2017-10-20
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="Show-me-the-code"><a href="#Show-me-the-code" class="headerlink" title="Show me the code"></a>Show me the code</h2><h3 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h3><p>柯里化就是函数和参数值结合产生一个新的函数，如下代码，假设有一个curry的函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> a + b;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> add1 = add.curry(<span class="number">1</span>);</div><div class="line"><span class="built_in">console</span>.log(add1(<span class="number">5</span>)); <span class="comment">// 6</span></div><div class="line"><span class="built_in">console</span>.log(add1(<span class="number">2</span>)); <span class="comment">// 3</span></div></pre></td></tr></table></figure>
<p>怎么实现这样一个curry的函数？它的重点是要返回一个函数，这个函数有一些闭包的变量记录了创建时的默认参数，然后执行这个返回函数的时候，把新传进来的参数和默认参数拼一下变成完整参数列表去调原本的函数，所以有了以下代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Function</span>.prototype.curry = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> defaultArgs = <span class="built_in">arguments</span>;</div><div class="line">    <span class="keyword">let</span> that = <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> that.apply(<span class="keyword">this</span>, defaultArgs.concat(<span class="built_in">arguments</span>));    </div><div class="line">        &#125;</div><div class="line">    &#125;;</div></pre></td></tr></table></figure></p>
<p>但是由于参数不是一个数组，没有concat函数，所以需要把伪数组转成一个伪数组，可以用Array.prototype.slice：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Function</span>.prototype.curry = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> slice = <span class="built_in">Array</span>.prototype.slice;</div><div class="line">    <span class="keyword">let</span> defaultArgs = slice.call(<span class="built_in">arguments</span>);</div><div class="line">    <span class="keyword">let</span> that = <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">         <span class="keyword">return</span> that.apply(<span class="keyword">this</span>, defaultArgs.concat(slice.call(<span class="built_in">arguments</span>)));    </div><div class="line">        &#125;</div><div class="line">    &#125;;</div></pre></td></tr></table></figure>
<h3 id="复杂选择器的查DOM"><a href="#复杂选择器的查DOM" class="headerlink" title="复杂选择器的查DOM"></a>复杂选择器的查DOM</h3><p>如实现一个document.querySelector：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.querySelector(<span class="string">".mls-info &gt; div .copyright-content"</span>)</div></pre></td></tr></table></figure>
<p>首先把复杂选择器做一个解析，序列为以下格式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//把selector解析为</span></div><div class="line"><span class="keyword">var</span> selectors = [</div><div class="line">&#123;<span class="attr">relation</span>: <span class="string">"descendant"</span>,  <span class="attr">matchType</span>: <span class="string">"class"</span>, <span class="attr">value</span>: <span class="string">"copyright-content"</span>&#125;,</div><div class="line">&#123;<span class="attr">relation</span>: <span class="string">"child"</span>,       <span class="attr">matchType</span>: <span class="string">"tag"</span>,   <span class="attr">value</span>: <span class="string">"div"</span>&#125;,</div><div class="line">&#123;<span class="attr">relation</span>: <span class="string">"subSelector"</span>, <span class="attr">matchType</span>: <span class="string">"class"</span>, <span class="attr">value</span>: <span class="string">"mls-info"</span>&#125;];</div></pre></td></tr></table></figure></p>
<p>从右往左，第一个selector是.copyright-content，它是一个类选择器，所以它的matchType是class，它和第二个选择器是祖先和子孙关系，因此它的relation是descendant；同理第二个选择器的matchType是tag，而relation是child，表示是第三个选择器的直接子结点；第三个选择器也是class，但是它没有下一个选择器了，relation用subSelector表示。</p>
<p>matchType的作用就在于用来比较当前选择器是否match，如下代码所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">match</span>(<span class="params">node, selector</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(node === <span class="built_in">document</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    <span class="keyword">switch</span>(selector.matchType)&#123;</div><div class="line">        <span class="comment">//如果是类选择器</span></div><div class="line">        <span class="keyword">case</span> <span class="string">"class"</span>:</div><div class="line">            <span class="keyword">return</span> node.className.trim().split(<span class="regexp">/ +/</span>).indexOf(selector.value) &gt;= <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="comment">//如果是标签选择器</span></div><div class="line">        <span class="keyword">case</span> <span class="string">"tag"</span>:</div><div class="line">            <span class="keyword">return</span> node.tagName.toLowerCase() === selector.value. toLowerCase();</div><div class="line"></div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">throw</span> <span class="string">"unknown selector match type"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据不同的matchType做不同的匹配。</p>
<p>在匹配的时候，从右往左，依次比较每个选择器是否match. 在比较下一个选择器的时候，需要找到相应的DOM结点，如果当前选择器是下一个选择器的子孙时，则需要比较当前选择器所有的祖先结点，一直往上直到document；而如果是直接子元素的关系，则比较它的父结点即可。所以需要有一个找到下一个目标结点的函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">nextTarget</span>(<span class="params">node, selector</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(!node || node === <span class="built_in">document</span>) <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">    <span class="keyword">switch</span>(selector.relation)&#123;</div><div class="line">        <span class="keyword">case</span> <span class="string">"descendant"</span>:</div><div class="line">            <span class="keyword">return</span> &#123;<span class="attr">node</span>: node.parentNode, <span class="attr">hasNext</span>: <span class="literal">true</span>&#125;;</div><div class="line">        <span class="keyword">case</span> <span class="string">"child"</span>:</div><div class="line">            <span class="keyword">return</span> &#123;<span class="attr">node</span>: node.parentNode, <span class="attr">hasNext</span>: <span class="literal">false</span>&#125;;</div><div class="line">        <span class="keyword">case</span> <span class="string">"sibling"</span>:</div><div class="line">            <span class="keyword">return</span> &#123;<span class="attr">node</span>: node.previousSibling, <span class="attr">hasNext</span>: <span class="literal">true</span>&#125;;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">throw</span> <span class="string">"unknown selector relation type"</span>;</div><div class="line">          <span class="comment">//hasNext表示当前选择器relation是否允许继续找下一个节点</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>有了nextTarge和match这两个函数就可以开始遍历DOM，如下代码所示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">querySelector</span>(<span class="params">node, selectors</span>)</span>&#123;</div><div class="line">    <span class="keyword">while</span>(node)&#123; <span class="comment">// 遍历节点</span></div><div class="line">        <span class="keyword">var</span> currentNode = node;</div><div class="line">        <span class="keyword">if</span>(!match(node, selectors[<span class="number">0</span>]))&#123;</div><div class="line">            node = nextElement(currentNode);</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">var</span> next = <span class="literal">null</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; selectors.length;i++)&#123;</div><div class="line">            <span class="keyword">var</span> matchIt = <span class="literal">false</span>;</div><div class="line">            <span class="keyword">do</span> &#123;</div><div class="line">                next = nextTarget(node, selectors[i]);</div><div class="line">                node = next.node;</div><div class="line">                <span class="keyword">if</span>(!node)&#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(match(node, selectors[i+<span class="number">1</span>]))&#123;</div><div class="line">                    matchIt = <span class="literal">true</span>;  <span class="comment">// 有一个符合就继续</span></div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">while</span> (next.hasNext);</div><div class="line">            <span class="keyword">if</span>(!matchIt) <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(matchIt &amp;&amp; i === selectors.length - <span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">return</span> currentNode; <span class="comment">// 全部匹配完</span></div><div class="line">        &#125;</div><div class="line">        node = nextElement(currentNode);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最外层的while循环和简单选择器一样，都是要遍历所有DOM结点。对于每个结点，先判断第一个选择器是否match，如果不match的话，则继续下一个结点，如果不是标签选择器，对于绝大多数结点将会在这里判断不通过。如果第一个选择器match了，则根据第一个选择器的relation，找到下一个target，判断下一个targe是否match下一个selector，只要有一个target匹配上了，则退出里层的while循环，继续下一个选择器，如果所有的selector都能匹配上说明匹配成功。如果有一个selecotr的所有target都没有match，则说明匹配失败，退出selector的for循环，直接从头开始对下一个DOM结点进行匹配。</p>
<h2 id="插件推荐"><a href="#插件推荐" class="headerlink" title="插件推荐"></a>插件推荐</h2><ul>
<li><a href="https://dwqs.github.io/vue-area-linkage/" target="_blank" rel="external">vue-area-linkage</a></li>
</ul>
<p>Vue Area Linkage: 中国行政区联动选择器，省、市、区、街道联动选择</p>
<h2 id="文章推荐"><a href="#文章推荐" class="headerlink" title="文章推荐"></a>文章推荐</h2><ul>
<li><p><a href="http://www.cnblogs.com/penghuwan/p/7356210.html" target="_blank" rel="external">换种方式解读this</a><br>文中用一种全新的形式解读this的几种绑定形式，不论是新入门还是大牛都可以看看这种新的解读形式。</p>
</li>
<li><p><a href="http://web.jobbole.com/92760/" target="_blank" rel="external">谈谈 PostCSS</a><br>现在的前端，javascript的发展有目共睹，框架林立。同时，html也是齐头并进，推出了HTML5标准，并且得到了普及。这样的发展却唯独少了一个角色？</p>
</li>
<li><p><a href="http://geek.csdn.net/news/detail/240600" target="_blank" rel="external">前端：常见的6种HTML5错误用法</a><br>人们在标签使用中最常见到的错误之一就是随意将HTML5的<section>等价于<div>——具体地说，就是直接用作替代品(用于样式)。</div></section></p>
</li>
<li><p><a href="https://segmentfault.com/a/1190000011612365" target="_blank" rel="external">vuejs 路由基础入门实战操作详细指南</a><br>Vue.js + vue-router 创建单页应用，是非常简单的。使用 Vue.js ，我们已经可以通过组合组件来组成应用程序，当你要把 vue-router 添加进来，我们需要做的是，将组件(components)映射到路由(routes)，然后告诉 vue-router 在哪里渲染它们。</p>
</li>
<li><p><a href="https://segmentfault.com/a/1190000011623637#articleHeader17" target="_blank" rel="external">JavaScript专题之解读 v8 排序源码</a><br>文章对于插入排序与快速排序原理、实现讲解非常详细，并且在 V8排序的源码进行了实例分析。</p>
</li>
<li><p><a href="https://juejin.im/post/59c7b25a5188257a125d7a98" target="_blank" rel="external">从Vue.js源码看异步更新DOM策略及nextTick</a><br>文章以实际问题为引，从源码入手，吸收别人的思路，一步步得到解决问题方案。首先，我觉得作者这种解决问题的方式以及刨根问底的精神首先值得我们学习；其次，文章总结的很到位，配合代码示例，让人清晰理解nextTick的实现。</p>
</li>
<li><p><a href="https://www.sitepen.com/blog/2017/10/02/a-guide-to-faster-web-app-io-and-data-operations-with-streams/" target="_blank" rel="external">更快速的Web应用程序I / O和流数据操作</a><br>使用流更改您读取，写入和处理数据的方式。根据您的用例，代码复杂度可能会增加。然而，流可以实现数据的高效处理，从而导致更好的存储器性能。</p>
</li>
<li><p><a href="https://qianduan.group/posts/59e8be1b0119753d067b40cc" target="_blank" rel="external">使用Nuxt.js改善现有项目</a><br><code>SPA</code> 应用有其天生的问题：搜索引擎爬虫抓不到，无法满足 <code>SEO</code> 的需求。这可以可以通过 <code>SSR</code> 解决，<code>Nuxt.js</code> 是由一对法国的兄弟基于 vue 2.0 提供的 ssr 能力开发的框架，基于恰到好处的约定与配置，可以显著的降低开发者创建服务端渲染 web app 的门槛。</p>
</li>
<li><p><a href="http://www.jianshu.com/p/ab2741f78858" target="_blank" rel="external">浅析nodejs的http模块</a><br>HTTP模块是Node内置的核心模块之一，node入门的课程都会讲，通过createServer就可以得到一个server对象，关于它内部实现的理解，可以帮助你提高技能。本文讲解了HTTP模块的大致流程，对一些关键点进行了充分的分析。</p>
</li>
<li><p><a href="https://juejin.im/post/59a8f15ef265da246c4a3822" target="_blank" rel="external">数据模拟神器 easy-mock</a><br>如何提高前端开发效率？当前端UI及逻辑都写完而后端接口还没有完成，怎样不打断开发进程？  因此一款简单、高效、可视化并能快速生成模拟数据 的在线mock服务诞生。</p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/26216336" target="_blank" rel="external">如何使用koa2+es6/7打造高质量Restful API</a><br>如今nodejs变得越来越火热，采用nodejs实现前后端分离架构已被多数大公司所采用。在过去，使用nodejs大家首先想到的是express.js，而发展到如今，更轻量，性能更好的koa已然成为主流不仅性能优异，它还支持async/await, 堪称回调地狱的终结者。</p>
</li>
</ul>
<h2 id="招聘"><a href="#招聘" class="headerlink" title="招聘"></a>招聘</h2><p>TalkingData DTU 可视化团队招聘：</p>
<ul>
<li>资深前端工程师</li>
</ul>
<p>简历投递：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> email = <span class="string">'xiang.wang#tendcloud.com'</span>.replace(<span class="string">'#'</span>, <span class="string">'@'</span>);</div><div class="line"><span class="built_in">console</span>.log(email);</div></pre></td></tr></table></figure></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/fsd/2017/10/13/weekly-16/"><span>大前端周刊 第16期 （本期小编：张成斌）</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/fsd/2017/10/13/weekly-16/" rel="bookmark">
        <time class="entry-date published" datetime="2017-10-13T02:24:12.000Z">
          2017-10-13
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="Show-me-the-code"><a href="#Show-me-the-code" class="headerlink" title="Show me the code"></a>Show me the code</h2><h3 id="ES6中的class语法"><a href="#ES6中的class语法" class="headerlink" title="ES6中的class语法"></a>ES6中的<code>class</code>语法</h3><p>JavaScript 语言中，生成实例对象的传统方法是通过构造函数。这种写法跟传统的面向对象语言（比如 C++ 和 Java）差异很大。ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。基本上，ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</p>
<h4 id="Class-Definition"><a href="#Class-Definition" class="headerlink" title="Class Definition"></a>Class Definition</h4><p>ES6语法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span> (id, x, y) &#123;</div><div class="line">        <span class="keyword">this</span>.id = id;</div><div class="line">        <span class="keyword">this</span>.move(x, y);</div><div class="line">    &#125;</div><div class="line">    move (x, y) &#123;</div><div class="line">        <span class="keyword">this</span>.x = x;</div><div class="line">        <span class="keyword">this</span>.y = y;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ES5语法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Shape = <span class="function"><span class="keyword">function</span> (<span class="params">id, x, y</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.id = id;</div><div class="line">    <span class="keyword">this</span>.move(x, y);</div><div class="line">&#125;;</div><div class="line">Shape.prototype.move = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.x = x;</div><div class="line">    <span class="keyword">this</span>.y = y;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>上面ES6代码定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。也就是说，ES5 的构造函数Shape，对应 ES6 的Shape类的构造方法。Shape类除了构造方法，还定义了一个move方法。注意，定义“类”的方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。</p>
<h4 id="Class-Inheritance"><a href="#Class-Inheritance" class="headerlink" title="Class Inheritance"></a>Class Inheritance</h4><p>ES6语法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span> (id, x, y) &#123;</div><div class="line">        <span class="keyword">this</span>.id = id;</div><div class="line">        <span class="keyword">this</span>.move(x, y);</div><div class="line">    &#125;</div><div class="line">    move (x, y) &#123;</div><div class="line">        <span class="keyword">this</span>.x = x;</div><div class="line">        <span class="keyword">this</span>.y = y;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span> (id, x, y, width, height) &#123;</div><div class="line">        <span class="keyword">super</span>(id, x, y);</div><div class="line">        <span class="keyword">this</span>.width  = width;</div><div class="line">        <span class="keyword">this</span>.height = height;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span> (id, x, y, radius) &#123;</div><div class="line">        <span class="keyword">super</span>(id, x, y);</div><div class="line">        <span class="keyword">this</span>.radius = radius;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ES5语法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Shape = <span class="function"><span class="keyword">function</span> (<span class="params">id, x, y</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.id = id;</div><div class="line">    <span class="keyword">this</span>.move(x, y);</div><div class="line">&#125;;</div><div class="line">Shape.prototype.move = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.x = x;</div><div class="line">    <span class="keyword">this</span>.y = y;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> Rectangle = <span class="function"><span class="keyword">function</span> (<span class="params">id, x, y, width, height</span>) </span>&#123;</div><div class="line">    Shape.call(<span class="keyword">this</span>, id, x, y);</div><div class="line">    <span class="keyword">this</span>.width  = width;</div><div class="line">    <span class="keyword">this</span>.height = height;</div><div class="line">&#125;;</div><div class="line">Rectangle.prototype = <span class="built_in">Object</span>.create(Shape.prototype);</div><div class="line">Rectangle.prototype.constructor = Rectangle;</div><div class="line"><span class="keyword">var</span> Circle = <span class="function"><span class="keyword">function</span> (<span class="params">id, x, y, radius</span>) </span>&#123;</div><div class="line">    Shape.call(<span class="keyword">this</span>, id, x, y);</div><div class="line">    <span class="keyword">this</span>.radius = radius;</div><div class="line">&#125;;</div><div class="line">Circle.prototype = <span class="built_in">Object</span>.create(Shape.prototype);</div><div class="line">Circle.prototype.constructor = Circle;</div></pre></td></tr></table></figure></p>
<p>上面的ES6代码定义了一个Rectangle类和一个Circle类，它们通过extends关键字，继承了Shape类的所有属性和方法。子类里都出现了super关键字，它在这里表示父类的构造函数，用来新建父类的this对象。子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。对照ES5语法我们可以发现使用class语法更简洁明了。</p>
<h2 id="插件推荐"><a href="#插件推荐" class="headerlink" title="插件推荐"></a>插件推荐</h2><ul>
<li><a href="https://www.whatruns.com/" target="_blank" rel="external">whatruns</a></li>
</ul>
<p>这个chrome插件可以查看网站，包括但不限于web框架、web服务器、js框架、js图表插件、字体、CDN。可以很方便的查看你感兴趣的网站所使用的技术。直接在chrome扩展商店里面搜whatruns就能安装。</p>
<h2 id="文章推荐"><a href="#文章推荐" class="headerlink" title="文章推荐"></a>文章推荐</h2><ul>
<li><p><a href="https://zhuanlan.zhihu.com/p/27288444" target="_blank" rel="external">美团外卖前端可视化界面组装平台</a><br>前端如何才能提高生产效率，普遍的共识是要做到组件化开发，很多团队已经这样做了。虽然很多的产品已经实现了组件化开发，但不同产品间依然存在很多重复的劳动，比如登录框、导航等等。这里推荐一篇美团外卖在效率方面尝试的一个解决方案。</p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzA4NjE3MDg4OQ==&amp;mid=2650965216&amp;idx=1&amp;sn=758f45497eb1755c84de7c4afbd494eb&amp;chksm=843ae886b34d6190e9c720c495952b8c7e045e6af40b35c5192d1f0450856f4d44c2536a970d&amp;mpshare=1&amp;scene=1&amp;srcid=1001pdkcvIK6jOSK62fc15aq#" target="_blank" rel="external">如何处理 JavaScript 内存泄露</a><br>讨论开发者容易忽视的重要主题 ：内存管理。文章也提供一些关于如何处理JavaScript内存泄露的技巧。在SessionStack，我们需要确保不会造成内存泄露或者不会增加我们集成的Web应用的内存消耗。</p>
</li>
<li><p><a href="https://juejin.im/entry/59deb55951882578c2084a63" target="_blank" rel="external">反击爬虫，前端工程师的脑洞可以有多大？</a><br>关于反击爬虫，本文给了很多前端反爬虫例子；<br>真的感叹为了反爬虫，前段工程师真的费尽心思，脑洞大开！</p>
</li>
<li><p><a href="http://web.jobbole.com/92605/" target="_blank" rel="external">Promise 异步流程控制</a><br>网页中预加载20张图片资源，分步加载，一次加载10张，两次完成，怎么控制图片请求的并发，怎样感知当前异步请求是否已完成？</p>
</li>
<li><p><a href="http://www.cnblogs.com/TomXu/archive/2012/03/02/2355128.html" target="_blank" rel="external">设计模式之观察者模式</a><br>观察者模式是一种常用的设置模式。文中提供了多种实现观察者模式的方式，并带有调用方式。可作为实现观察者模式的源码和研究观察者模式使用。</p>
</li>
<li><p><a href="http://www.alloyteam.com/2017/09/13139/" target="_blank" rel="external">用 threejs 制作一款简单的赛车游戏</a><br>通过学习本教程，可以熟悉 <code>webgl</code> 和 <code>threejs</code> 相关的知识。</p>
</li>
<li><p><a href="https://imququ.com/post/enhance-security-for-ls-code.html" target="_blank" rel="external">使用 SRI 增强 localStorage 代码安全</a><br>大部分 Web 应用从 localStorage 中获取缓存代码后，没有任何检测机制，直接执行。而 localStorage 是跨页面的，同域下任何页面有 XSS 漏洞，就可以被攻击者用来往 localStorage 写入恶意代码，可以使用 SRI 增强 localStorage 代码安全。</p>
</li>
<li><p><a href="http://mp.weixin.qq.com/s/a7UtcAUnifrNCzegfDYaig" target="_blank" rel="external">浏览器缓存机制小结</a><br>本文总结了浏览器缓存的基本机制，将各种情况分为：强缓存和协商缓存两种方式。对三组核心的HTTP请求以及响应头参数：cache-control和expire， last-modified和if-modified-since，etag和if-none-matched，做了清晰的解释，很好理解它们之间的区别、优先级等关系。</p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/29750583" target="_blank" rel="external">HTTP 缓存机制一二三</a><br>作为前端，常与请求打交道，HTTP缓存应该作为基本知识储备。文章介绍了强缓存和协商缓存，响应头各个字段的含义简单了解下，具体业务需要后端配合设置。</p>
</li>
<li><p><a href="https://yq.aliyun.com/articles/8539?spm=5176.100240.searchblog.8.u2w8qY" target="_blank" rel="external">如何优雅的在 koa 中处理错误</a><br>软件开发时，有 80% 的代码在处理各种错误。 ——某著名开发者 想让自己的代码健壮，错误处理是必不可少的。这篇文章将主要介绍 koa 框架中错误处理的实现（其实主要是 co 的实现），使用 koa 框架开发 web 应用时进行错误处理的一些方法。</p>
</li>
</ul>
<h2 id="招聘"><a href="#招聘" class="headerlink" title="招聘"></a>招聘</h2><p>TalkingData DTU 可视化团队招聘：</p>
<ul>
<li>资深前端工程师</li>
</ul>
<p>简历投递：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> email = <span class="string">'xiang.wang#tendcloud.com'</span>.replace(<span class="string">'#'</span>, <span class="string">'@'</span>);</div><div class="line"><span class="built_in">console</span>.log(email);</div></pre></td></tr></table></figure></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/fsd/2017/09/29/weekly-15/"><span>大前端周刊 第15期 （本期小编：郭俊兵）</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/fsd/2017/09/29/weekly-15/" rel="bookmark">
        <time class="entry-date published" datetime="2017-09-29T08:23:27.000Z">
          2017-09-29
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="Show-me-the-code"><a href="#Show-me-the-code" class="headerlink" title="Show me the code"></a>Show me the code</h2><ul>
<li>对象数组排序</li>
</ul>
<p>概念：javascript实现多维数组、对象数组排序，其实用的就是原生的sort()方法，用于对数组的元素进行排序。</p>
<p>语法：arr.sort(by(‘xx’))</p>
<ul>
<li><p>参数介绍：</p>
<ul>
<li>function, key<br>使用回调函数，处理需要排序的对象key。</li>
</ul>
</li>
<li><p>返回值<br>排序以后的数组。</p>
<p>针对于偶尔需要前端排序的情况，可以使用该方式。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// 回调函数</div><div class="line">function by(name) &#123;</div><div class="line">  return function(o, p) &#123;</div><div class="line">    let a;</div><div class="line">    let b;</div><div class="line">    if (typeof o === &apos;object&apos; &amp;&amp; typeof p === &apos;object&apos; &amp;&amp; o &amp;&amp; p) &#123;</div><div class="line">      a = o[name];</div><div class="line">      b = p[name];</div><div class="line">      if (a === b) &#123;</div><div class="line">        return 0;</div><div class="line">      &#125;</div><div class="line">      if (typeof a === typeof b) &#123;</div><div class="line">        return a &lt; b ? -1 : 1;</div><div class="line">      &#125;</div><div class="line">      return typeof a &lt; typeof b ? -1 : 1;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  需要排序的 Array：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">const employees = [&#123;</div><div class="line">  name: &apos;George&apos;,</div><div class="line">  age: 32,</div><div class="line">  retiredate: &apos;March 12, 2014&apos;</div><div class="line">&#125;, &#123;</div><div class="line">  name: &apos;Edward&apos;,</div><div class="line">  age: 17,</div><div class="line">  retiredate: &apos;June 2, 2023&apos;</div><div class="line">&#125;, &#123;</div><div class="line">  name: &apos;Christine&apos;,</div><div class="line">  age: 58,</div><div class="line">  retiredate: &apos;December 20, 2036&apos;</div><div class="line">&#125;, &#123;</div><div class="line">  name: &apos;Sarah&apos;,</div><div class="line">  age: 62,</div><div class="line">  retiredate: &apos;April 30, 2020&apos;</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<p>  通过 age 排序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">employees.sort(by(&apos;age&apos;));</div></pre></td></tr></table></figure></p>
<p>  结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[&#123;&quot;name&quot;:&quot;Edward&quot;,&quot;age&quot;:17,&quot;retiredate&quot;:&quot;June 2, 2023&quot;&#125;,</div><div class="line">&#123;&quot;name&quot;:&quot;George&quot;,&quot;age&quot;:32,&quot;retiredate&quot;:&quot;March 12, 2014&quot;&#125;,</div><div class="line">&#123;&quot;name&quot;:&quot;Christine&quot;,&quot;age&quot;:58,&quot;retiredate&quot;:&quot;December 20, 2036&quot;&#125;,</div><div class="line">&#123;&quot;name&quot;:&quot;Sarah&quot;,&quot;age&quot;:62,&quot;retiredate&quot;:&quot;April 30, 2020&quot;&#125;]</div></pre></td></tr></table></figure></p>
<p>  到这里，对象数组排序就算基本实现了。那如何实现多个键值排序呢？意思就是先是对age排序，如果age相同，再比较name。<br>    这时，我们可以进一步修改by函数，让其可以接受第二个参数，当主要的键值产生一个匹配的时候，另一个compare方法将被调用以决出高下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">// by函数接受一个成员名字符串和一个可选的次要比较函数做为参数</div><div class="line">// 并返回一个可以用来包含该成员的对象数组进行排序的比较函数</div><div class="line">// 当o[age]和 p[age] 相等时， 次要比较函数被用来决出高下</div><div class="line">function by(name, minor) &#123;</div><div class="line">  return function(o, p) &#123;</div><div class="line">    let a;</div><div class="line">    let b;</div><div class="line">    if (o &amp;&amp; p &amp;&amp; typeof o === &apos;object&apos; &amp;&amp; typeof p === &apos;object&apos;) &#123;</div><div class="line">      a = o[name];</div><div class="line">      b = p[name];</div><div class="line">      if (a === b) &#123;</div><div class="line">        return typeof minor === &apos;function&apos; ? minor(o, p) : 0;</div><div class="line">      &#125;</div><div class="line">      if (typeof a === typeof b) &#123;</div><div class="line">        return a &lt; b ? -1 : 1;</div><div class="line">      &#125;</div><div class="line">      return typeof a &lt; typeof b ? -1 : 1;</div><div class="line">    &#125; else &#123;</div><div class="line">      thro(&quot;error&quot;);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>  待排序数组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">const employees = [&#123;</div><div class="line">  name: &apos;George&apos;,</div><div class="line">  age: 32,</div><div class="line">  retiredate: &apos;March 12, 2014&apos;</div><div class="line">&#125;, &#123;</div><div class="line">  name: &apos;Edward&apos;,</div><div class="line">  age: 17,</div><div class="line">  retiredate: &apos;June 2, 2023&apos;</div><div class="line">&#125;, &#123;</div><div class="line">  name: &apos;Christine&apos;,</div><div class="line">  age: 32,</div><div class="line">  retiredate: &apos;December 20, 2036&apos;</div><div class="line">&#125;, &#123;</div><div class="line">  name: &apos;Sarah&apos;,</div><div class="line">  age: 62,</div><div class="line">  retiredate: &apos;April 30, 2020&apos;</div><div class="line">&#125;];</div><div class="line">// 排序操作</div><div class="line">employees.sort(by(&apos;age&apos;, by(&apos;name&apos;)))</div></pre></td></tr></table></figure></p>
<p>  结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[&#123;&quot;name&quot;:&quot;Edward&quot;,&quot;age&quot;:17,&quot;retiredate&quot;:&quot;June 2, 2023&quot;&#125;,</div><div class="line">&#123;&quot;name&quot;:&quot;George&quot;,&quot;age&quot;:32,&quot;retiredate&quot;:&quot;March 12, 2014&quot;&#125;,</div><div class="line">&#123;&quot;name&quot;:&quot;Sarah&quot;,&quot;age&quot;:32,&quot;retiredate&quot;:&quot;April 30, 2020&quot;&#125;,</div><div class="line">&#123;&quot;name&quot;:&quot;Christine&quot;,&quot;age&quot;:58,&quot;retiredate&quot;:&quot;December 20, 2036&quot;&#125;]</div></pre></td></tr></table></figure></p>
<h2 id="插件推荐"><a href="#插件推荐" class="headerlink" title="插件推荐"></a>插件推荐</h2><ul>
<li><p><a href="https://github.com/josdejong/jsoneditor/" target="_blank" rel="external">jsoneditor JOSN格式编辑器</a></p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install jsoneditor</div></pre></td></tr></table></figure>
<h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">import JSONEditor from &apos;jsoneditor/dist/jsoneditor&apos;;</div><div class="line">const container = document.getElementById(&apos;jsonEdit&apos;);</div><div class="line">container.innerHTML = &apos;&apos;;</div><div class="line">const options = &#123;</div><div class="line">  mode: &apos;code&apos;,</div><div class="line">&#125;;</div><div class="line">const editor = new JSONEditor(container, options);</div><div class="line">// 添加数据</div><div class="line">editor.set(JSON);</div><div class="line">// 获取数据</div><div class="line">editor.get();</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="文章推荐"><a href="#文章推荐" class="headerlink" title="文章推荐"></a>文章推荐</h2><ul>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzAwNTAzMjcxNg==&amp;mid=2651425040&amp;idx=1&amp;sn=523695a371f87ce6f4f1c003ef937f0b&amp;chksm=80dff773b7a87e65fa93ce9f059d3b1f6af1c2115c3bf5356357f25fab730cab4f8ae67cb70d&amp;mpshare=1&amp;scene=1&amp;srcid=0929ZyVAlRQeJ9EX6qEuuq5C#rd" target="_blank" rel="external">实现达到 60FPS 的高性能交互动画</a><br>  对于页面优化而言，开发者往往会花大量精力在优化首屏加载，为了几毫秒锱铢必较，但忽略了页面交互动画所带来的性能问题。本文从浏览器渲染原理的角度，给出了实现60FPS交互动画的方法。</p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/27069865" target="_blank" rel="external">Node.js cluster 踩坑小结</a><br>  推荐大家深入阅读这篇来自饿了么 Node 大神黄鼎恒的文章，内容深入介绍了进程与 process 对象、子进程 和 IPC ，负载实现等知识点和踩过的坑。</p>
</li>
<li><p><a href="https://juejin.im/post/59b9ffa8f265da06710d8e89" target="_blank" rel="external">你真的会用 Babel 吗</a><br>  对于 babel 的使用，大部分同学一直停留在与 webpack 结合使用，以及在浏览器开发环境下。导致很多 babel 的包，都不清楚他们是干嘛的。本篇文章可以当个入门来读</p>
</li>
<li><p><a href="http://www.zcfy.cc/article/diving-deep-into-javascript-array-8211-evolution-038-performance-void-canvas-4202.html?t=new" target="_blank" rel="external">JavaScript 数组的演进及其性能</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Typed_arrays" target="_blank" rel="external">MDN JavaScript typed arrays</a><br>  文章通过数组与类型化数组（Typed Arrays）进行对比，从创建，插入，读取等方面进行性能比较；从而直观的介绍类型化数组的，并没有深入Typed Arrays。</p>
</li>
<li><p><a href="http://web.jobbole.com/86941/" target="_blank" rel="external">RAIL 性能模型</a><br>  资源加载之后的性能，因为大多数用户关注的不是应用如何加载而是具体的使用。所以要快速响应用户，尤其是无线端，我们有必要了解浏览器渲染性能。</p>
</li>
<li><p><a href="https://segmentfault.com/a/1190000011354975" target="_blank" rel="external">CSS 黑魔法小技巧，让你少写不必要的JS，代码更优雅</a><br>  <a href="https://github.com/jawil/blog/issues/24" target="_blank" rel="external">这些JavaScript编程黑科技，装逼指南，高逼格代码，让你惊叹不已</a><br>  很有意思的两篇代码小技巧，几行代码实现让人惊诧的功能、效果。思路清奇，仔细阅读代码相信会沉淀不少有用的东西。</p>
</li>
<li><p><a href="http://web.jobbole.com/92207/" target="_blank" rel="external">javascript 函数中的 this 的四种绑定形式</a><br>   javascript中的this和函数息息相关，谈到this很多让人晕晕乎乎的抽象概念就跑出来了，这里只说最核心的一点——函数中的this总指向调用它的对象</p>
</li>
<li><p><a href="https://fed.renren.com/2017/09/23/http2/" target="_blank" rel="external">怎样把网站升级到http/2</a><br>  为何升级http/2理由<a href="https://fed.renren.com/2017/09/03/upgrade-to-https/" target="_blank" rel="external">在这里</a>，本文是实践部分。http/2给前端优化带来了<a href="https://imququ.com/post/http2-new-opportunities-and-challenges.html" target="_blank" rel="external">新的机遇与挑战</a>，有兴趣的小伙伴可以了解下。</p>
</li>
<li><p><a href="https://segmentfault.com/a/1190000007484357" target="_blank" rel="external">JavaScript 开发者所需要知道的 V8（一）：V8 In NodeJS</a><br>  V8做为Javascript引擎，使用范围已经越来越广泛。文中简单介绍了V8引擎在NodeJS的中运用。</p>
</li>
</ul>
<h2 id="招聘"><a href="#招聘" class="headerlink" title="招聘"></a>招聘</h2><p>TalkingData DTU 可视化团队招聘：</p>
<ul>
<li>资深前端工程师</li>
<li>前端实习生</li>
</ul>
<p>简历投递：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> email = <span class="string">'xiang.wang#tendcloud.com'</span>.replace(<span class="string">'#'</span>, <span class="string">'@'</span>);</div><div class="line"><span class="built_in">console</span>.log(email);</div></pre></td></tr></table></figure></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/fsd/tags/Node/">Node</a><a href="/fsd/tags/动画/">动画</a><a href="/fsd/tags/Babels/">Babels</a><a href="/fsd/tags/渲染性能/">渲染性能</a><a href="/fsd/tags/this关键字/">this关键字</a><a href="/fsd/tags/http-2升级/">http/2升级</a><a href="/fsd/tags/CSS黑魔法/">CSS黑魔法</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/fsd/2017/09/22/weekly-14/"><span>大前端周刊 第14期 （本期小编：陶明）</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/fsd/2017/09/22/weekly-14/" rel="bookmark">
        <time class="entry-date published" datetime="2017-09-22T07:56:42.000Z">
          2017-09-22
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="Show-me-the-code"><a href="#Show-me-the-code" class="headerlink" title="Show me the code"></a>Show me the code</h2><ul>
<li>Set</li>
</ul>
<p>语法：new Set([iterable])</p>
<ul>
<li><p>参数介绍：</p>
<ul>
<li>iterable<br>如果传递一个可迭代对象，它的所有元素将被添加到新的 Set中。如果不指定此参数或其值为null，则新的 Set为空。</li>
</ul>
</li>
<li><p>返回值<br>一个新的Set对象。</p>
<p>简单说一下为什么要用 Set，因为 Set中的值具有唯一性（划重点！！！）。<br>唯一性！<br>所以，我就用它来去重。<br>嗯，对。<br>只用来数组去重！！！</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">const arr = [1, 2, 3, 4, 5, 5, 4, 3, 2, 0];</div><div class="line">const ArraySet = new Set(arr);</div><div class="line"></div><div class="line">Array.from(ArraySet); // [1, 2, 3, 4, 5, 0]</div><div class="line">[...ArraySet]; // [1, 2, 3, 4, 5, 0]</div><div class="line"></div><div class="line">const emoji = [&apos;↖&apos;, &apos;💎&apos;, &apos;↗&apos;, &apos;♠&apos;, &apos;↖&apos;, &apos;😏&apos;, &apos;💎&apos;, &apos;😍&apos;, &apos;😏&apos;,];</div><div class="line">const emojiSet = new Set(arr);</div><div class="line"></div><div class="line">Array.from(emojiSet) // [&quot;↖&quot;, &quot;💎&quot;, &quot;↗&quot;, &quot;♠&quot;, &quot;😏&quot;, &quot;😍&quot;]</div><div class="line">[...emojiSet] // [&quot;↖&quot;, &quot;💎&quot;, &quot;↗&quot;, &quot;♠&quot;, &quot;😏&quot;, &quot;😍&quot;]</div></pre></td></tr></table></figure>
<p>  只能 Array？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">const text = &apos;prototype&apos;;</div><div class="line">new Set(text); // Set &#123;&quot;p&quot;, &quot;r&quot;, &quot;o&quot;, &quot;t&quot;, &quot;y&quot;, &quot;e&quot;&#125; 我是 String Set的</div></pre></td></tr></table></figure></p>
<p>  上面说到它的返回值是一个对象<br>  So, 它有自己属性及方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const arr = [1, 2, 3, 4, 5, 5, 4, 3, 2, 0];</div><div class="line">const mySet = new Set(arr);</div><div class="line"></div><div class="line">mySet.size; // 6 剩 6 个了</div><div class="line">mySet.length; // undefined</div></pre></td></tr></table></figure></p>
<p>  都叫 ‘size’了，当然是它的个数啊,<br>  没 length（手动痴呆脸）我就试试看而已…<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">const arr = [1, 2, 3, 4, 5, 5, 4, 3, 2, 0];</div><div class="line">const mySet = new Set(arr);</div><div class="line"></div><div class="line">/* 我要加个 10 */</div><div class="line">mySet.add(10) // [1, 2, 3, 4, 5, 0, 10] 加上了！</div><div class="line"></div><div class="line">/* 我要加个 1 */</div><div class="line">mySet.add(1) // [1, 2, 3, 4, 5, 0] 233 加不上！说了 Set有唯一性了！</div><div class="line"></div><div class="line">/* 我不要 0 了 */</div><div class="line">mySet.clear(0) // undefined !!!</div><div class="line">mySet.clear() // undefined !!!</div></pre></td></tr></table></figure></p>
<p>  刷出来算我输…<br>  Set.prototype.clear()，没参数，调用就清空啦.</p>
<p>  当然是可以删除了，开了一个好冷的笑话（故作镇定接着写…）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">const arr = [1, 2, 3, 4, 5, 5, 4, 3, 2, 0];</div><div class="line">const mySet = new Set(arr);</div><div class="line"></div><div class="line">/* 我不要 0 了  */</div><div class="line">mySet.delete(0) // [1, 2, 3, 4, 5] 删掉了！</div><div class="line"></div><div class="line">/* 有 1 吗？ */</div><div class="line">mySet.has(1); // true 有的！</div><div class="line"></div><div class="line">/* 有 2 吗？ */</div><div class="line">mySet.has(2); // true 有的！</div><div class="line"></div><div class="line">/* 有 0 吗？ */</div><div class="line">mySet.has(0); // false 没有！刚才删了！</div></pre></td></tr></table></figure></p>
<p>  其实还有几个方法，<br>  这里只是简单的说一下这个 Set 而已<br>  你以为我结束了？<br>  我再说最后一个！<br>  嗯！<br>  最后一个！<br>  我保证！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/* 用 forEach 能干点什么？ */</div><div class="line">mySet.forEach(function(value) &#123;</div><div class="line">  // use value do something ...</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>  OK，能力有限…</p>
<h2 id="插件推荐"><a href="#插件推荐" class="headerlink" title="插件推荐"></a>插件推荐</h2><ul>
<li><p><a href="https://github.com/lucefer/vue-bubble" target="_blank" rel="external">消息气泡拖拽插件, 基于vue实现的仿QQ消息气泡拖拽插件</a></p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install vue-bubble</div></pre></td></tr></table></figure>
<h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">const vueBubble from &apos;vue-bubble&apos;</div><div class="line">Vue.use(vueBubble)</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="文章推荐"><a href="#文章推荐" class="headerlink" title="文章推荐"></a>文章推荐</h2><ul>
<li><p><a href="https://segmentfault.com/a/1190000011229300" target="_blank" rel="external">JavaScript 工作原理：内存管理与常见内存泄露分析</a><br>本系列文章皆着眼于深度解析 JavaScript 内部运行原理，而本文则重点讨论编程语言中常见的内存管理问题；并且还提出了对于处理常见的内存泄露的建议。</p>
</li>
<li><p><a href="https://antv.alipay.com/vis/doc/chart/details/scatter-plot.html" target="_blank" rel="external">可视化基础之散点图介绍</a><br>这篇文章介绍了散点图的科学意义，推荐大家阅读学习。可视化是前端发展的一个大方向，可视化工程师除了技术实现之外，还应该学习各种图表所能表达的科学含义。感谢蚂蚁金服体验技术部同学们，整理了一整套科学规范的可视化图表“字典”，让大家详细了解每种图表背后的含义。扩展阅读：<a href="https://antv.alipay.com/vis/doc/chart/classify/compare.html" target="_blank" rel="external">可视化基础</a></p>
</li>
<li><p><a href="https://juejin.im/post/5965943ff265da6c30653879" target="_blank" rel="external">JS正则表达式完整教程</a><br>非常详细的介绍了JS中和正则相关的知识，文章很长，适合慢慢研读</p>
</li>
<li><p><a href="https://juejin.im/post/59bb37fa6fb9a00a554f89d2" target="_blank" rel="external">webpack：从入门到真实项目配置</a><br>文章主要介绍webpack配置，由简入繁、逐步优化，从简单的打包为一个bundle到分离代码、抽离共同代码、按需加载代码、自动刷新，每一步都非常详细，适合初学者快速入门。</p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/26364493" target="_blank" rel="external">AR.js 初探</a><br>AR技术（增强现实技术Augmented Reality，简称 AR），AR技术在Native中已经兴起了，并且市场上有许多成功的APP，但是对于JavaScript怎么来玩转AR呢？下面我来简单的给大家演示两个不同版本，不同场景的AR小例子。</p>
</li>
<li><p><a href="https://github.com/zuopf769/notebook/blob/master/fe/BFC%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/README.md" target="_blank" rel="external">史上最全面、最透彻的BFC原理剖析</a><br>介绍FC的概念是什么； BFC的约束规则；咋样才能触发生成新的BFC；BFC在布局中的应用：防止margin重叠(塌陷,以最大的为准)； 清除内部浮动；自适应两（多）栏布局。 </p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/29137921" target="_blank" rel="external">JS遇上IOT</a><br>IOT是 Internet of Things 的缩写，字面翻译是“物体组成的因特网”，准确的翻译应该为“物联网”。凡是可以用 JavaScript 来写的应用，最终都会用 JavaScript ——Atwood 定律。逃不出这个定律，JavaScript 也能用于物联网开发了。本文介绍了使用 JavaScript 在 ruff 开发平台上的小实例，有树莓派的小伙伴可以尝试把玩一下。</p>
</li>
<li><p><a href="https://segmentfault.com/a/1190000010921801" target="_blank" rel="external">上手 Webpack ? 这篇就够了！</a><br>文章系统的概述了 Webpack 从安装到配置以及插件等等；讲述的还是比较全面。对于使用 Webpack 来说，完全可以说是够用。</p>
</li>
<li><p><a href="http://www.cnblogs.com/giggle/p/7538533.html" target="_blank" rel="external">实现一个简单的虚拟DOM</a><br>现在的流行框架，无论React还是Vue，都采用虚拟DOM。文中介绍了虚拟DOM的实现原理，能帮助更好理解双向绑定实现。</p>
</li>
</ul>
<h2 id="招聘"><a href="#招聘" class="headerlink" title="招聘"></a>招聘</h2><p>TalkingData DTU 可视化团队招聘：</p>
<ul>
<li>资深前端工程师</li>
<li>前端实习生</li>
</ul>
<p>简历投递：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> email = <span class="string">'xiang.wang#tendcloud.com'</span>.replace(<span class="string">'#'</span>, <span class="string">'@'</span>);</div><div class="line"><span class="built_in">console</span>.log(email);</div></pre></td></tr></table></figure></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/fsd/tags/Webpack/">Webpack</a><a href="/fsd/tags/内存管理/">内存管理</a><a href="/fsd/tags/散点图/">散点图</a><a href="/fsd/tags/正则/">正则</a><a href="/fsd/tags/AR/">AR</a><a href="/fsd/tags/IOT/">IOT</a><a href="/fsd/tags/虚拟DOM/">虚拟DOM</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/fsd/2017/09/15/weekly-13/"><span>大前端周刊 第13期 （本期小编：李丽娇）</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/fsd/2017/09/15/weekly-13/" rel="bookmark">
        <time class="entry-date published" datetime="2017-09-15T06:55:47.000Z">
          2017-09-15
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="Show-me-the-code"><a href="#Show-me-the-code" class="headerlink" title="Show me the code"></a>Show me the code</h2><ul>
<li>剩余参数</li>
</ul>
<p>概念：剩余参数（rest parameter）语法允许我们将一个不定数量的参数表示为一个数组。<br>使用场景：在不确定参数个数的函数中，设置部分行参。<br>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function(a, b, ...restArgs) &#123;</div><div class="line">  // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function multiply(multiplier, ...theArgs) &#123;</div><div class="line">  return theArgs.map(function (element) &#123;</div><div class="line">    return multiplier * element;</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var arr = multiply(2, 1, 2, 3); </div><div class="line">console.log(arr);  // [2, 4, 6]</div></pre></td></tr></table></figure></p>
<p>说明：<br>剩余参数和 arguments 对象的区别：</p>
<ol>
<li>剩余参数只包含那些没有对应形参的实参，而 arguments 对象包含了传给函数的所有实参。</li>
<li>arguments 对象不是一个真实的数组,而剩余参数是真实的 Array实例，也就是说你能够在它上面直接使用所有的数组方法，比如 sort，map，forEach，pop。</li>
<li>arguments 对象对象还有一些附加的属性 (比如callee属性)。</li>
</ol>
<ul>
<li>逗号操作符</li>
</ul>
<p>概念：逗号操作符  对它的每个操作数求值（从左到右），并返回最后一个操作数的值。<br>语法：expr1, expr2, expr3…<br>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function a(num) &#123;</div><div class="line">  console.log(num);</div><div class="line">&#125;</div><div class="line"></div><div class="line">function b(num) &#123;</div><div class="line">  console.log(num * 2);</div><div class="line">&#125;</div><div class="line"></div><div class="line">a(1), b(1); // 1  2</div><div class="line">b(1), a(1); // 2  1</div></pre></td></tr></table></figure></p>
<p>小结：<br>逗号表达式最常用的地方是是用一句代码定义多个变量的场景。在许多大厂的源码中也被用在如上示例的函数调用。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ul>
<li>Trackingjs</li>
</ul>
<p>js实现人脸识别，看这里：<a href="https://trackingjs.com/" target="_blank" rel="external">https://trackingjs.com</a>，文章推荐板块中有成功的实践案例。</p>
<ul>
<li>图片渐进式加载</li>
</ul>
<p>需求：在网速不好的情况下，网站上的某张图片用上向下一点点加载，用户体现不友好。希望先显示整张图片然后渐渐变清晰。<br>方案：使用渐进式加载的图片，详情见文章：<a href="http://www.zhangxinxu.com/wordpress/2013/01/progressive-jpeg-image-and-so-on/" target="_blank" rel="external">渐进式jpeg(progressive jpeg)图片</a>。</p>
<ul>
<li>Flex布局</li>
</ul>
<p>自从有了flex布局，处女座的设计师再也不用担心内容没有中间对其或上下对齐了。图文详解flex语法，戳下文：<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="external">Flex 布局教程－语法篇</a></p>
<h2 id="工具和模块"><a href="#工具和模块" class="headerlink" title="工具和模块"></a>工具和模块</h2><p>作为前端童鞋，平时开发免不了和接口打交道，拿到接口后需要测试一下接口返回是否正常，这时最后有一款支持各种请求方式的模拟Http请求工具。现在来介绍一些一款解决这个问题的工具－Postman，Postman支持各种请求方式，支持添加各个请求头参数。对写接口或用接口的同学来说都是利器。</p>
<ol>
<li><p>官网：<a href="https://www.getpostman.com/" target="_blank" rel="external">https://www.getpostman.com/</a></p>
</li>
<li><p>推荐文章：<a href="http://blog.csdn.net/flowerspring/article/details/52774399" target="_blank" rel="external">Postman用法简介</a></p>
</li>
</ol>
<h2 id="文章推荐"><a href="#文章推荐" class="headerlink" title="文章推荐"></a>文章推荐</h2><ul>
<li><p><a href="https://www.smashingmagazine.com/2017/09/guide-virtual-reality-web-developers/?utm_source=frontendfocus&amp;utm_medium=email" target="_blank" rel="external">面向 Web 开发者的 VR 指南</a><br>近日来，越来越多的浏览器添加了对于 VR 特性的支持，本文即是盘点下目前浏览器中 VR 技术发展的现状，并且对可用的 WebVR 相关 API 进行简要介绍。</p>
</li>
<li><p><a href="https://segmentfault.com/a/1190000011153487" target="_blank" rel="external">深入浅出基于“依赖收集”的响应式原理</a><br>文章很透彻的解析了对于使用Object.defineProperty()实现的响应式原理；从一个简单的实例逐步分析响应式原理的具体思路。讲解响应式原理的文章很多，这篇还是很形象的。</p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/28653993" target="_blank" rel="external">30 行 JavaScript 代码搭建神经网络</a><br>数据科学部的同学推荐的一篇神经网络入门实践文章，这篇文章图文并茂的介绍了神经网络的基础知识：神经元、神经网络等。深入阅读：<a href="http://www.ruanyifeng.com/blog/2017/07/neural-network.html" target="_blank" rel="external">神经网络入门</a></p>
</li>
<li><p><a href="https://github.com/jawil/blog/issues/9" target="_blank" rel="external">深入浅出DOM基础——《DOM探索之基础详解篇》学习笔记</a><br>文章稍长，本文只论述DOM基础概念，不涉及DOM的一些事件原理机制，页面元素的操作和常用API的讲解以及兼容性事项，所以概念性东西比较多，稍微有点抽象。</p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/26063036" target="_blank" rel="external">编写可维护代码之“中间件模式”</a><br>中间件可以介入请求和相应的处理,是一个轻量级的模块,每个中间负责完成某个特定的功能。</p>
</li>
<li><p><a href="http://mp.weixin.qq.com/s?__biz=MzIyMjYyMzg3MA==&amp;mid=2247484289&amp;idx=1&amp;sn=9e7f6c0c5e6707c8b3d0a73b36bc00c1&amp;chksm=e82be290df5c6b86e2be66f2eea6ee88be1449c3b40d8ebf40932798f95e651fbaf49ca698d0&amp;mpshare=1&amp;scene=1&amp;srcid=0727KaC7tg9V5Sa1mhiVeInx#rd" target="_blank" rel="external">当我们学习 Node.js 时，我们在学习什么？</a><br>大家都说学 Node.js 学 Node.js，到底是学它的什么呢？是学 JavaScript 这门语言，还是学 Node.js 的 API？还是学 Node.js 各种三方库？</p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/29165800" target="_blank" rel="external">石墨表格之 Web Worker 应用实战</a><br>JavaScript 执行是单线程的，如运行 CPU 密集型任务会阻塞线程，此时浏览器会被卡住。解决该问题的办法之一就是引入Web Worker。Web Worker 为前端带来了后台计算的能力，可以实现主 UI 线程与复杂计运算线程的分离，从而极大减轻了因计算量大而造成 UI 阻塞而出现的界面渲染卡、掉帧的情况，从而更大程度地的提高我们的页面性能。</p>
</li>
<li><p><a href="https://juejin.im/post/59ade28051882538fd72fa2c" target="_blank" rel="external">那些你不能错过的 GitHub 插件和工具</a><br>既然 GitHub 这么重要，又被我们使用得这么频繁，那关于 GitHub 的一些优秀浏览器插件或者其他工具，我们就一定不可错过啦。本文就来整理一些，都是我平常使用最得心应手的东西，全都倾力推荐出来，绝对干货！</p>
</li>
<li><p><a href="http://refined-x.com/2017/09/06/%E7%BA%AF%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB-%E6%8F%90%E5%8F%96-%E5%90%88%E6%88%90/" target="_blank" rel="external">纯前端实现人脸识别-提取-合成</a><br>前段时间火遍朋友圈的军装照竟然是用纯前段实现的！<br>实现原理已在文中揭秘，速度get起来～</p>
</li>
<li><p><a href="http://www.w3cplus.com/css/css-polyfluidsizing-using-calc-vw-breakpoints-and-linear-equations.html" target="_blank" rel="external">实现精准的流体排版原理</a><br>文章介绍了如何实现精准的流式排版。其中原理非常的简单，通过CSS的Viewport单位和calc()配合一些数学公式，较为精准的实现随着视窗改变，能较为精准的改变font-size的大小，甚至只要是带有长度单位的属性都可以通过这样方式，达到精准的值。</p>
</li>
</ul>
<h2 id="招聘"><a href="#招聘" class="headerlink" title="招聘"></a>招聘</h2><p>TalkingData DTU 可视化团队招聘：</p>
<ul>
<li>资深前端工程师</li>
<li>前端实习生</li>
</ul>
<p>简历投递：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> email = <span class="string">'xiang.wang#tendcloud.com'</span>.replace(<span class="string">'#'</span>, <span class="string">'@'</span>);</div><div class="line"><span class="built_in">console</span>.log(email);</div></pre></td></tr></table></figure></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/fsd/tags/weekly/">weekly</a><a href="/fsd/tags/Trackingjs/">Trackingjs</a><a href="/fsd/tags/flex/">flex</a><a href="/fsd/tags/postman/">postman</a><a href="/fsd/tags/神经网络/">神经网络</a><a href="/fsd/tags/DOM/">DOM</a><a href="/fsd/tags/Nodejs/">Nodejs</a><a href="/fsd/tags/Web-Worker/">Web Worker</a><a href="/fsd/tags/GitHub插件/">GitHub插件</a><a href="/fsd/tags/人脸识别/">人脸识别</a><a href="/fsd/tags/流体排版/">流体排版</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/fsd/2017/09/08/weekly-12/"><span>大前端周刊 第12期 （本期小编：李志伟）</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/fsd/2017/09/08/weekly-12/" rel="bookmark">
        <time class="entry-date published" datetime="2017-09-08T06:55:47.000Z">
          2017-09-08
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="Show-me-the-code"><a href="#Show-me-the-code" class="headerlink" title="Show me the code"></a>Show me the code</h2><ul>
<li>回调地狱</li>
</ul>
<p>需求：异步读取多个文件，等到所有文件读取完毕执行特定操作。<br>简单实现：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line">fs.readFile(<span class="string">'./config/test.txt'</span>), (err, data) =&gt; &#123;</div><div class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err</div><div class="line">    fs.readFile(<span class="string">'./config/test1.txt'</span>), (err, data1) =&gt; &#123;</div><div class="line">      <span class="keyword">if</span> (err) <span class="keyword">throw</span> err</div><div class="line">      fs.readFile(<span class="string">'./config/test2.txt'</span>), (err, data2) =&gt; &#123;</div><div class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err</div><div class="line">        fs.readFile(<span class="string">'./config/test3.txt'</span>), (err, data3) =&gt; &#123;</div><div class="line">          <span class="keyword">if</span> (err) <span class="keyword">throw</span> err</div><div class="line">          <span class="built_in">console</span>.log(<span class="string">'success'</span>);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncReadFile</span> (<span class="params">filePath, options</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">    fs.readFile(filePath, options, (err, data) =&gt; &#123;</div><div class="line">      <span class="keyword">if</span> (err) reject(err);</div><div class="line">      resolve(data);</div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">asyncReadFile(<span class="string">'./config/test.txt'</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> asyncReadFile(<span class="string">'./config/test1.txt'</span>);</div><div class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> asyncReadFile(<span class="string">'./config/test2.txt'</span>);</div><div class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> asyncReadFile(<span class="string">'./config/test3.txt'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>小结：Promise 是一种对异步操作的封装，在异步操作执行成功或者失败时执行指定方法。将横向的异步调用转换为纵向，因此更符合人类的思维方式。</p>
<ul>
<li>async和await</li>
</ul>
<p>小小面试题：每隔一秒输出一个数字，顺序是：0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5</p>
<p>简单实现：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 你首先想到的可能是这样</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;  <span class="comment">// j = i</span></div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>, j);</div><div class="line">    &#125;, <span class="number">1000</span>);</div><div class="line">  &#125;)(i);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>, i);</div><div class="line"></div><div class="line"><span class="comment">// 利用es7的async和await 你还可以这样</span></div><div class="line"><span class="keyword">const</span> sleep = <span class="function">(<span class="params">timeountMS</span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</div><div class="line">  setTimeout(resolve, timeountMS);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">(<span class="keyword">async</span> () =&gt; &#123;  <span class="comment">// 声明即执行的 async 函数表达式</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">    <span class="keyword">await</span> sleep(<span class="number">1000</span>);</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>, i);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">await</span> sleep(<span class="number">1000</span>);</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>, i);</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p>
<h2 id="工具和模块"><a href="#工具和模块" class="headerlink" title="工具和模块"></a>工具和模块</h2><p>推荐简单易用的git客户端管理工具——Source Tree，支持创建、克隆、提交、push、pull 和合并等操作，其最大优点是拥有可视化界面，大大简化了开发者与代码库之间的Git操作方式，这对于那些不熟悉Git命令的开发者来说非常实用。</p>
<ol>
<li><p>官网：<a href="https://www.sourcetreeapp.com/" target="_blank" rel="external">https://www.sourcetreeapp.com/</a></p>
</li>
<li><p>git学习教程：<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000</a></p>
</li>
</ol>
<h2 id="文章推荐"><a href="#文章推荐" class="headerlink" title="文章推荐"></a>文章推荐</h2><ul>
<li><p><a href="https://mp.weixin.qq.com/s/mblUhRMgyWUBhtIOaN6bGg" target="_blank" rel="external">从攻击看防御-前端视野下的web安全思考</a><br>文章基于笔者对自身业务的web安全梳理，引起对web安全的一定思考。因其岗位视野以web前端为主，在对web安全的思考上，难免会有一定的局限性，故题目加上了“前端视野下”这样的修饰词。</p>
</li>
<li><p><a href="http://www.cnblogs.com/coco1s/p/5499469.html" target="_blank" rel="external">高性能滚动 scroll 及页面渲染优化</a><br>本文算是对上一期关于函数节流与防抖的实际场景中的实践，阅读本文以助于更好好的理解函数节流与防抖，并且本文也提供了一些其他的优化思路。</p>
</li>
<li><p><a href="http://cnodejs.org/topic/57b062ed144011da12ff4183" target="_blank" rel="external">基于koajs的前后端分离实践</a><br>要实现前后端分离框架，无非要满足这样几点：<br>更便捷地创建路由、更高效地代理数据请求、更灵活地环境部署</p>
</li>
<li><p><a href="https://segmentfault.com/a/1190000011019534" target="_blank" rel="external">深入理解CSS时序函数</a><br>本文非常详细的介绍制作动画时所使用的时序函数，对于动画的实现有详细的demo和说明。总之对于CSS动画来说，还是要看大家怎么玩这些属性了。</p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651225513&amp;idx=1&amp;sn=d247881a71f06e75478611e40b3d4e01&amp;chksm=bd49a42d8a3e2d3bc783fc1b75672b3e2069b48c1add29f64dd626b0b8d4c5c6c1bdb09e2565&amp;mpshare=1&amp;scene=1&amp;srcid=09081NPEMSgj7Z8J7G4807ps#rd" target="_blank" rel="external">Webpack 的静态资源持久缓存</a><br>代码每次更新-&gt;服务器重新部署-&gt;客户端重新下载资源，显然低效。所以这就是浏览器会缓存静态资源的原因，但存在缺陷：文件不修改文件名，浏览器会认为没有更新，就会使用缓存中的版本。文章介绍webpack如何配置以开启静态资源的持久缓存，内置详细代码示例，易懂易用。</p>
</li>
<li><p><a href="https://juejin.im/post/59ac1c4ef265da248e75892b" target="_blank" rel="external">js 深拷贝 vs 浅拷贝</a><br>主要讲一下 js 的基本数据类型以及一些堆和栈的知识和什么是深拷贝、什么是浅拷贝、深拷贝与浅拷贝的区别，以及怎么进行深拷贝和怎么进行浅拷贝。</p>
</li>
<li><p><a href="http://www.jianshu.com/p/80e25cb1d81a" target="_blank" rel="external">关于HTTP协议</a><br>http协议作为连接浏览器和服务器之间的协议，有着重要的作用，为前端开发必了解内容之一。<br>下文介绍了http的概要，偏理论，可作为了解。</p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/29010060" target="_blank" rel="external">前端校招面试该考察什么？</a><br>文章总结了腾讯的校招流程和校招（实习生）对候选人技能的侧重方面。除了招聘，文章还对前端工程师的技术栈做了非常全面的总结。</p>
</li>
</ul>
<h2 id="招聘"><a href="#招聘" class="headerlink" title="招聘"></a>招聘</h2><p>TalkingData DTU 可视化团队招聘：</p>
<ul>
<li>资深前端工程师</li>
<li>前端实习生</li>
</ul>
<p>简历投递：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> email = <span class="string">'xiang.wang#tendcloud.com'</span>.replace(<span class="string">'#'</span>, <span class="string">'@'</span>);</div><div class="line"><span class="built_in">console</span>.log(email);</div></pre></td></tr></table></figure></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/fsd/tags/weekly/">weekly</a><a href="/fsd/tags/ES6/">ES6</a><a href="/fsd/tags/webpack/">webpack</a><a href="/fsd/tags/koa/">koa</a><a href="/fsd/tags/web安全/">web安全</a><a href="/fsd/tags/http/">http</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/fsd/2017/09/01/weekly-11/"><span>大前端周刊 第11期 （本期小编：胡国伟）</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/fsd/2017/09/01/weekly-11/" rel="bookmark">
        <time class="entry-date published" datetime="2017-09-01T09:00:00.000Z">
          2017-09-01
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="Show-me-the-code"><a href="#Show-me-the-code" class="headerlink" title="Show me the code"></a>Show me the code</h2><h4 id="截流-throttle"><a href="#截流-throttle" class="headerlink" title="截流(throttle)"></a>截流(throttle)</h4><p>概念理解：固定函数执行的速率。<br>使用场景：DOM 事件绑定，短时间内触发多次绑定事件造成性能问题，如 <code>onresize</code>,<code>onscroll</code>等，使用节流函数可确保在指定时间内只触发一次。<br>简单实现：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> throttle = <span class="function">(<span class="params">func, wait</span>) =&gt;</span> &#123;</div><div class="line">	<span class="keyword">let</span> context, args;</div><div class="line">	<span class="keyword">let</span> previous = <span class="number">0</span>;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">		<span class="keyword">let</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line">		context = <span class="keyword">this</span>;</div><div class="line">		args = <span class="built_in">arguments</span>;</div><div class="line">		<span class="keyword">if</span> (now - previous &gt; wait) &#123;</div><div class="line">			func.apply(context, args);</div><div class="line">			previous = now;</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h4 id="防抖-debounce"><a href="#防抖-debounce" class="headerlink" title="防抖(debounce)"></a>防抖(debounce)</h4><p>概念理解：强制一个函数在某个连续时间段内只执行一次，哪怕它本来会被调用多次。<br>使用场景：</p>
<ol>
<li>表单远程搜索，键盘多次输入取最后一次输入值作为查询关键词。</li>
<li>下拉菜单的延时消失。</li>
</ol>
<p>简单实现：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> debounce = <span class="function">(<span class="params">func, wait</span>) =&gt;</span> &#123;</div><div class="line">	<span class="keyword">let</span> timeout;</div><div class="line">  	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    	<span class="keyword">let</span> context = <span class="keyword">this</span>;</div><div class="line">    	<span class="keyword">let</span> args = <span class="built_in">arguments</span>;</div><div class="line">    	clearTimeout(timeout);</div><div class="line">    	timeout = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      		func.apply(context, args)</div><div class="line">    	&#125;, wait);</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="工具和模块"><a href="#工具和模块" class="headerlink" title="工具和模块"></a>工具和模块</h2><p>推荐功能强大的<code>HTTP</code>抓包调试工具：Fiddler。假如有这样一个场景，线上突然出现bug，而你正在休假、手头又没有源码，但又急需你参与问题排查，怎么办？Fiddler 便是你的救🔥利器。</p>
<ol>
<li>官网：<a href="http://www.telerik.com/fiddler" target="_blank" rel="external">http://www.telerik.com/fiddler</a></li>
<li>插件（官方&amp;第三方）：<a href="http://www.telerik.com/fiddler/add-ons" target="_blank" rel="external">http://www.telerik.com/fiddler/add-ons</a></li>
<li>快速上手：<a href="https://www.qcloud.com/community/article/115124?fromSource=gwzcw.93596.93596.93596" target="_blank" rel="external">十分钟学会 Fiddler</a></li>
<li>视频教程：<a href="http://www.imooc.com/learn/37" target="_blank" rel="external">http://www.imooc.com/learn/37</a></li>
<li>系列文章<ul>
<li><a href="http://blog.csdn.net/ohmygirl/article/details/17846199" target="_blank" rel="external">【HTTP】Fiddler（一） - Fiddler简介</a></li>
<li><a href="http://blog.csdn.net/ohmygirl/article/details/17849983" target="_blank" rel="external">【HTTP】Fiddler（二） - 使用Fiddler做抓包分析</a></li>
<li><a href="http://blog.csdn.net/ohmygirl/article/details/17855031" target="_blank" rel="external">【HTTP】Fiddler（三）- Fiddler命令行和HTTP断点调试</a></li>
</ul>
</li>
</ol>
<h2 id="文章推荐"><a href="#文章推荐" class="headerlink" title="文章推荐"></a>文章推荐</h2><ul>
<li><p><a href="http://www.ruanyifeng.com/blog/2015/06/istanbul.html" target="_blank" rel="external">代码覆盖率工具 Istanbul 入门教程</a><br>使用 Mocha 进行单元测试时，还需要了解测试的覆盖程度，这个指标就叫做”代码覆盖率”（code coverage）。这篇文章非常全面地介绍了Istanbul，让你轻松上手。深入了解：<a href="https://github.com/istanbuljs/nyc" target="_blank" rel="external">nyc</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzIyMjYyMzg3MA==&amp;mid=2247484408&amp;idx=2&amp;sn=456405dd36fd679dea1470b131924980&amp;chksm=e82be2e9df5c6bff70912d297d535bfb747e2598a129641ea3409cedd88f2eac22e2d77dc98b&amp;mpshare=1&amp;scene=1&amp;srcid=0901XT4SSeVjxiKd3Pj6IOvv&amp;pass_ticket=%2BCgbmXT%2FgYy2AZSB%2B2tlPOm2ZM34W2NpPc%2F1G3ifFff91PXQRXcYFvt%2BSdaP7QjU#rd" target="_blank" rel="external">深入浅出浏览器渲染原理</a><br>对于 HTTP 协议和浏览器渲染原理都是理解容易但不好讲明白，那么为什么不采用 Node.js 来阐述呢？以实践的方式、最简单的方式来向你展示不好讲的东西，对于 Node.js 开发者和大前端开发来说都是非常实用的。</p>
</li>
<li><p><a href="https://github.com/DMQ/mvvm" target="_blank" rel="external">剖析Vue实现原理 - 如何实现双向绑定mvvm</a></p>
<ol>
<li>了解vue的双向数据绑定原理以及核心代码模块</li>
<li>了解如何实现双向绑定</li>
</ol>
</li>
<li><p><a href="https://github.com/jawil/blog/issues/16" target="_blank" rel="external">不用call和apply方法模拟实现ES5的bind方法</a><br>这个问题是对JavaScript基本功很好的一个检测，看JavaScript掌握的怎么样以及平时有没有去深入研究一些方法的实现，简而言之，就是有没有折腾精神。</p>
</li>
<li><p><a href="https://github.com/Jocs/jocs.github.io/issues/11" target="_blank" rel="external">通过ES6 Generator函数实现异步操作</a><br>文章对 Generator函数实现异步进行了深入的讲解，最后使用 promise和 generator这样的模式实现异步操作，对于实现的过程进行深入细致的分析。</p>
</li>
<li><p><a href="http://mp.weixin.qq.com/s?__biz=MzI2MTY0NTEyMA==&amp;mid=2247483871&amp;idx=1&amp;sn=f717d3c787626d997c410117a1cd7fb9&amp;chksm=ea5677f0dd21fee6c7853b60b7e32d744af1abb183903ce8523954e093263a8c375895f0f193&amp;mpshare=1&amp;scene=1&amp;srcid=06289q8vqWAQUGuqdrMsqEzq#" target="_blank" rel="external">你了解CSS设计模式吗？</a><br>简单来了解下CSS设计模式：</p>
<ol>
<li>BEM全称（block、element、modifier）是Yandex 团队提出的CSS Class命名法</li>
<li>OOCSS全称（Object Oriented CSS）由Nicole Sullivan提出的css理论</li>
<li>SMACSS是Jonathan Snook的一个CSS框架</li>
<li>Atomic Design，原子设计</li>
</ol>
</li>
</ul>
<ul>
<li><a href="http://fed.renren.com/2017/07/02/algorithm/" target="_blank" rel="external">我接触过的前端数据结构与算法</a><br>  作者总结了前端常常碰到的算法，主要涉及递归、节流、数组去重、栈和堆、图像处理等。代码示例较为清晰，对于初学者还是很有帮助的，比较赞同作者的观点：算法的目的是用最小的时间和最小的空间解决问题。但是有时候不用太拘泥于一定要最优的答案，能够合适地解决问题就是好方法，而且对于不同的应用场景可能要采取不同的策略。</li>
</ul>
<ul>
<li><a href="http://web.jobbole.com/88463/" target="_blank" rel="external">JavaScript 中 4 种常见的内存泄露陷阱</a><br>虽然Javascript有内存自动回收机制，但这并不以为着js开发使完全不用关心内存管理。文中详细介绍了什么是内存泄漏和js中容易引起内存泄漏的点，并提供了使用Chrome分析内存的方法。</li>
</ul>
<h2 id="招聘"><a href="#招聘" class="headerlink" title="招聘"></a>招聘</h2><p>TalkingData DTU 可视化团队招聘：</p>
<ul>
<li>资深前端工程师</li>
<li>前端实习生</li>
</ul>
<p>简历投递：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> email = <span class="string">'xiang.wang#tendcloud.com'</span>.replace(<span class="string">'#'</span>, <span class="string">'@'</span>);</div><div class="line"><span class="built_in">console</span>.log(email);</div></pre></td></tr></table></figure></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/fsd/tags/weekly/">weekly</a><a href="/fsd/tags/开发工具/">开发工具</a><a href="/fsd/tags/测试工具/">测试工具</a><a href="/fsd/tags/Vue/">Vue</a><a href="/fsd/tags/ES6/">ES6</a><a href="/fsd/tags/设计模式/">设计模式</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/fsd/2017/08/25/weekly-10/"><span>大前端周刊 第10期 （本期小编：王祥）</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/fsd/2017/08/25/weekly-10/" rel="bookmark">
        <time class="entry-date published" datetime="2017-08-25T02:30:30.000Z">
          2017-08-25
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="Show-me-the-code"><a href="#Show-me-the-code" class="headerlink" title="Show me the code"></a>Show me the code</h2><p>ES 6 中引入了很多让代码看起来更简洁的新特性，比如展开运算符 (spread operator)。下面的三段代码，展示了 ES6 更简洁的对象拷贝、数组复制和可变参数的写法。</p>
<ul>
<li>对象拷贝</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// very bad</span></div><div class="line"><span class="keyword">const</span> original = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</div><div class="line"><span class="keyword">const</span> copy = <span class="built_in">Object</span>.assign(original, &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;); <span class="comment">// this mutates `original` ಠ_ಠ</span></div><div class="line"><span class="keyword">delete</span> copy.a; <span class="comment">// so does this</span></div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> original = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</div><div class="line"><span class="keyword">const</span> copy = <span class="built_in">Object</span>.assign(&#123;&#125;, original, &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;); <span class="comment">// copy =&gt; &#123; a: 1, b: 2, c: 3 &#125;</span></div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> original = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</div><div class="line"><span class="keyword">const</span> copy = &#123; ...original, <span class="attr">c</span>: <span class="number">3</span> &#125;; <span class="comment">// copy =&gt; &#123; a: 1, b: 2, c: 3 &#125;</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> &#123; a, ...noA &#125; = copy; <span class="comment">// noA =&gt; &#123; b: 2, c: 3 &#125;</span></div></pre></td></tr></table></figure>
<ul>
<li>数组复制 (copy arrays)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> len = items.length;</div><div class="line"><span class="keyword">const</span> itemsCopy = [];</div><div class="line"><span class="keyword">let</span> i;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i += <span class="number">1</span>) &#123;</div><div class="line">  itemsCopy[i] = items[i];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> itemsCopy = [...items];</div></pre></td></tr></table></figure>
<ul>
<li>可变函数 (variadic function)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">const</span> x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</div><div class="line"><span class="built_in">console</span>.log.apply(<span class="built_in">console</span>, x);</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">const</span> x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</div><div class="line"><span class="built_in">console</span>.log(...x);</div><div class="line"></div><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">new</span> (<span class="built_in">Function</span>.prototype.bind.apply(<span class="built_in">Date</span>, [<span class="literal">null</span>, <span class="number">2016</span>, <span class="number">8</span>, <span class="number">5</span>]));</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(...[<span class="number">2016</span>, <span class="number">8</span>, <span class="number">5</span>]);</div></pre></td></tr></table></figure>
<h2 id="工具和模块"><a href="#工具和模块" class="headerlink" title="工具和模块"></a>工具和模块</h2><p>推荐一个 Markdown 生成 Word 文档工具 pandoc。</p>
<ol>
<li><p>使用 pandoc 将 Markdown 文件转换为 Word 文档。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pandoc -f markdown -t docx front-end-engineering-practice.md -o mydoc.docx</div></pre></td></tr></table></figure>
</li>
<li><p>安装 pandoc ( Mac )</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ brew install pandoc</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="文章推荐"><a href="#文章推荐" class="headerlink" title="文章推荐"></a>文章推荐</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/26709518" target="_blank" rel="external">10 个基于 JavaScript 的机器学习实例</a></li>
</ul>
<p>虽然，大多数 JavaScript 机器学习库都是“新轮子”，有的甚至还在研发中，但并不会影响你的使用。在这篇文章中，我们将与你分享这些库，以及一些很酷的 AI Web 应用程序实例，帮助你开启机器学习之旅。</p>
<ul>
<li><a href="https://github.com/jawil/blog/issues/14" target="_blank" rel="external">通俗大白话来理解TCP协议的三次握手和四次分手</a></li>
</ul>
<p>前端工程师也需要了解HTTP方面的一些知识，本篇文章用通俗易懂的方式讲解了平时经常听到的三次握手和四次分手究竟是什么。</p>
<ul>
<li><a href="http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html" target="_blank" rel="external">测试框架 Mocha 实例教程</a></li>
</ul>
<p>Mocha 是目前最流行的测试框架之一，支持浏览器端和 Node 端的单元测试。这篇文章非常全面地介绍如何使用Mocha，让你轻松上手。</p>
<ul>
<li><a href="https://www.kancloud.cn/kancloud/midway/48192" target="_blank" rel="external">前后端分离的思考与实践</a></li>
</ul>
<p>本文是阿里某前端团队，在探索一套基于NodeJS的前后端分离方案的过程中，对于前后端分离的一些认识以及思考。</p>
<ul>
<li>Mac <a href="http://blog.devtang.com/2015/11/14/charles-introduction/" target="_blank" rel="external">Charles 从入门到精通</a><br>PC <a href="http://blog.csdn.net/qq_21445563/article/details/51017605" target="_blank" rel="external">Fiddler 抓包工具总结</a></li>
</ul>
<p>在PC Web端开发的时候，我们能很方便的从浏览器开发者工具里进行网络接口调试。<br>在移动端开发是面对这样的需求，我们可以通过抓包工具来解决这个问题。<br>在Mac系统常用的抓包工具是Charles，Windows系统中常用的抓包工具是Fiddler。<br>下面的文章分别对Charles和Fiddler进行介绍，并图文显示了使用方法。</p>
<ul>
<li><a href="https://github.com/zce/weapp-demo/tree/tutorial" target="_blank" rel="external">微信小程序开发教程</a></li>
</ul>
<p>由易到难介绍小程序开发的流程，讲解比较层次化，比较细致，可以让人很快进行上手开发</p>
<ul>
<li><a href="https://github.com/Jocs/jocs.github.io/issues/1" target="_blank" rel="external">JavaScript Error 指南</a></li>
</ul>
<p>深度的剖析了错误信息和追溯栈，从错误捕获、剖析追溯栈、不同浏览器对于追溯栈格式上的差异等等，讲解相当详细也很透彻。</p>
<ul>
<li><a href="http://ifanqi.me/2017/07/25/you-can-understand-closure/" target="_blank" rel="external">浏览器是怎么看闭包的</a></li>
</ul>
<p>关于闭包的解释有很多，很多只是从“行”上去解读，理解 JavaScript 闭包绕不开一个问题：闭包是如何实现变量保留在内存中呢？这涉及到浏览器对内存的分配与回收，本文从这个点展开图文详实的解读。拓展阅读：<a href="http://ifanqi.me/2017/07/28/js-variable-memory/" target="_blank" rel="external">可视化分析js的内存分配与回收</a>。</p>
<ul>
<li><a href="https://github.com/xieranmaya/blog/issues/3" target="_blank" rel="external">剖析Promise内部结构</a></li>
</ul>
<p>一步一步实现一个完整的、能通过所有Test case的Promise类。文章由构造简单的promise对象开始，逐步完善逻辑。抛出问题，介绍思路，给出代码示例，比较清晰合理。自己实现已有的轮子，对于编码能力提升还是很有帮助的。</p>
<h2 id="招聘"><a href="#招聘" class="headerlink" title="招聘"></a>招聘</h2><p>TalkingData DTU 可视化团队招聘：</p>
<ul>
<li>资深前端工程师</li>
<li>前端实习生</li>
</ul>
<p>简历投递：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> email = <span class="string">'xiang.wang#tendcloud.com'</span>.replace(<span class="string">'#'</span>, <span class="string">'@'</span>);</div><div class="line"><span class="built_in">console</span>.log(email);</div></pre></td></tr></table></figure></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/fsd/tags/weekly/">weekly</a><a href="/fsd/tags/工程化实践/">工程化实践</a><a href="/fsd/tags/Vuex/">Vuex</a><a href="/fsd/tags/Webpack/">Webpack</a><a href="/fsd/tags/PWA/">PWA</a><a href="/fsd/tags/持续部署/">持续部署</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/fsd/2017/08/18/weekly-9/"><span>大前端周刊 第9期 （本期小编：包京京）</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/fsd/2017/08/18/weekly-9/" rel="bookmark">
        <time class="entry-date published" datetime="2017-08-18T06:57:34.000Z">
          2017-08-18
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul>
<li><p><a href="http://blog.benoitvallon.com/data-structures-in-javascript/data-structures-in-javascript/" target="_blank" rel="external">javascript数据结构</a><br><strong>用javascript创建并分析各种常见数据结构</strong></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651226809&amp;idx=1&amp;sn=514ca88902bc91840f363348d6c86c39&amp;chksm=bd495b3d8a3ed22bcf78801f96ae5c8d9555792d599004a7dc47a5a528185b9734f78af565fb&amp;mpshare=1&amp;scene=1&amp;srcid=08182YSPaUr4JxGj4iID40gs&amp;pass_ticket=0Et24OmYtRSLgA6Geno1MGBk5RujsQrVbaq%2FwZJ%2BzwtD%2F%2FbnV8lCXfDaw3Z5FpPr#rd" target="_blank" rel="external">理解Service Worker</a><br><strong>PWA是最近前端最火热的一个概念之一，Service Worker是支持PWA的核心技术之一</strong></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651226816&amp;idx=1&amp;sn=5c2de943a3ff61de10466bfe21f973c2&amp;chksm=bd495b448a3ed2529d674d66eab367d3b2c9c1516f70206ea36aaa5439703288168a6305d48f&amp;mpshare=1&amp;scene=1&amp;srcid=0818znt16EAbHf0IGrXO1guY&amp;pass_ticket=0Et24OmYtRSLgA6Geno1MGBk5RujsQrVbaq%2FwZJ%2BzwtD%2F%2FbnV8lCXfDaw3Z5FpPr#rd" target="_blank" rel="external">常见排序算法之JavaScript实现</a><br><strong>排序算法是基础算法。本文用javascript和算法可视化工具将各种排序算法实现了一遍</strong></p>
</li>
</ul>
<h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><ul>
<li><p><a href="https://zhuanlan.zhihu.com/p/27853228" target="_blank" rel="external">饿了么的 PWA 升级实践</a><br><small><em>推荐人: 胡国伟</em></small><br>饿了吗本次分享了基于 vue.js 的升级实践，踩坑跳坑的过程非常精彩。阅读完本文之余也可了解下Lavas：百度推出的基于 Vue 的 PWA 解决方案，其号称帮助开发者快速搭建 PWA 应用，解决接入 PWA 的各种问题。</p>
</li>
<li><p><a href="https://tech.meituan.com/vuex-code-analysis.html" target="_blank" rel="external">Vuex框架原理与源码分析</a><br><small><em>推荐人：李志伟</em></small><br>文章首先抛出5个核心问题，然后介绍各模块核心流程，结合图解、代码示例更利于理解。理清store构造方法你也就大致明白Vuex的实现了。</p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&amp;mid=2651552440&amp;idx=1&amp;sn=01bdb132ed0383a47993d711120b4283&amp;chksm=8025ad79b752246fef6761482dbace0d9899ac00982a238063749400e4b0aed38140005ac869&amp;mpshare=1&amp;scene=1&amp;srcid=0809B7Mm0d6x7DCLtBzpQKer#" target="_blank" rel="external">每个JavaScript开发者都该懂的Unicode</a><br><small><em>推荐人：郭俊兵</em></small><br>如果你觉得理解Unicode很难，那么是时候来面对它了！其实它没你想的那么难。让我们进入抽象概念、字符、星光平面(辅助平面)和代理对的世界。</p>
</li>
<li><p><a href="http://code.oneapm.com/javascript/2015/07/07/webpack_performance_1/" target="_blank" rel="external">Webpack 性能优化 （一）</a><br><small><em>推荐人：陶明</em></small><br>文章通过项目打包场景，介绍了 resolve.alias 即利用别名做重定向的方法，在此基础上，配合module.noParse 忽略对某些模块的解析可以进一步加快速度。</p>
</li>
<li><p><a href="http://web.jobbole.com/85503/" target="_blank" rel="external">分享一篇介绍JS调试技巧的文章</a><br><small><em>推荐人：李丽娇</em></small><br>据说程序员不是在改bug就是在写bug的路上，由此可见调试问题这个技能的重要性。文中介绍了多种JS的调试工具和方法，并配有GIF图演示。快GET起来吧！</p>
</li>
<li><p><a href="https://chenshenhai.github.io/koa2-note/" target="_blank" rel="external">Koa2进阶学习笔记</a><br><small><em>推荐人：耿少真</em></small><br>基于async/await实现中间体系的koa2框架将会是是node.js web开发方向大势所趋的普及框架。基于generator/yield的koa1将会逐渐被koa2替代，毕竟使用co.js来处理generator是一种过渡的方式，虽然有其特定的应用场景，但是用async/await会更加优雅地实现同步写法。</p>
</li>
<li><p><a href="http://annn.me/frontend-ci-cd/" target="_blank" rel="external">前端开发持续集成/持续部署(CI/CD)实例</a><br><small><em>推荐人：包京京</em></small><br>近几年，前端项目也引入了编译，构建，单元测试等现代软件工程化的标准环节。这样大提高了前端的开发效率和业务交付能力。在项目部署阶段，我们还需要引入 CI / CD 等现代化的软件开发实践，来减少风险，自动化重复操作，节省我们的时间。本文主要分享一下如何基于 gitlab 、 jenkins 让 CI/CD 跑起来。</p>
</li>
<li><p><a href="https://github.com/DDFE/DDFE-blog/issues/13" target="_blank" rel="external">滴滴 webapp 5.0 Vue 2.0 重构经验分享</a><br><small><em>推荐人：张成斌</em></small><br>滴滴的 webapp 是运行在微信、支付宝、手 Q 以及其它第三方渠道的打车软件。借着产品层面的功能和视觉升级，我们用 Vue 2.0 对它进行了一次技术重构；本文即是本次重构中的经验分享。</p>
</li>
<li><p><a href="http://wxnet.me/2017/08/18/front-end-engineering-practice/" target="_blank" rel="external">前端工程化实践</a><br><small><em>推荐人：王祥</em></small><br>第一篇原创文章，总结了TalkingData DTU可视化团队，在2017年上半年的实践和尝试。内容包括git工作流、代码规范和大前端的目标确定，总结过往，才能更好的迎接未来。</p>
</li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/fsd/tags/weekly/">weekly</a><a href="/fsd/tags/工程化实践/">工程化实践</a><a href="/fsd/tags/Vuex/">Vuex</a><a href="/fsd/tags/Webpack/">Webpack</a><a href="/fsd/tags/PWA/">PWA</a><a href="/fsd/tags/持续部署/">持续部署</a>
    </span>
    

    </div>

    
  </div>
</article>




<nav class="pagination">
  
  
  <a href="/fsd/page/2/" class="pagination-next">下一页</a>
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2017 FSD Weekly
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>