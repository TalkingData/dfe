{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/Hacker/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/images/icon-heart.svg","path":"images/icon-heart.svg","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/article.styl","path":"css/components/article.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/archive.styl","path":"css/components/archive.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/base/normalize.css","path":"css/base/normalize.css","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/categories.styl","path":"css/components/categories.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/icon.styl","path":"css/components/icon.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/footer.styl","path":"css/components/footer.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/header.styl","path":"css/components/header.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/layout.styl","path":"css/components/layout.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/responsive.styl","path":"css/components/responsive.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/pagination.styl","path":"css/components/pagination.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/syntax.styl","path":"css/components/syntax.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/tags.styl","path":"css/components/tags.styl","modified":1,"renderable":1}],"Cache":[{"_id":"themes/Hacker/.gitignore","hash":"803c06a7086b5817c03d2e8672da27bc56ba2bce","modified":1498192818000},{"_id":"themes/Hacker/README_zh-CN.md","hash":"d6c9200e96bb3633c3a84de169f91e6c34a5ea14","modified":1498192818000},{"_id":"themes/Hacker/LICENSE","hash":"3127907a7623734f830e8c69ccee03b693bf993e","modified":1498192818000},{"_id":"themes/Hacker/README.md","hash":"71077f7bdebc6e8d36f763e715ec2d55ddca4141","modified":1498192818000},{"_id":"themes/Hacker/_config.yml","hash":"5d8cc859c48024451a316c50ab16ba58702b062d","modified":1498192818000},{"_id":"source/_posts/5-protocols-for-event-driven-api-architectures.md","hash":"8fc472d56a43aaa7ee1f935501969b469e717c19","modified":1500607722000},{"_id":"source/_posts/weekly-1.md","hash":"95f5d7afb0a322d85ea9589b92e8495d4408fa5c","modified":1498208484000},{"_id":"source/_posts/weekly-2.md","hash":"40bd5d87fea2e892b52216d66d84efb47a0e9a3b","modified":1499140362000},{"_id":"source/_posts/weekly-4.md","hash":"14b049290b64270a054d2492d88bb9f82abca257","modified":1499875141000},{"_id":"source/_posts/weekly-3.md","hash":"78d8a48f1f24aa905127662fabf14e92a769cf28","modified":1499874885000},{"_id":"themes/Hacker/languages/default.yml","hash":"ef90548952b1f9cc88dbe9daad882786212aec38","modified":1498192818000},{"_id":"themes/Hacker/languages/zh-CN.yml","hash":"18638177b944e0deb4a8c26a1c4a980901151132","modified":1498192818000},{"_id":"themes/Hacker/layout/categories.ejs","hash":"bfad4e7eade650c535f0194974e2646619657b8b","modified":1498192818000},{"_id":"themes/Hacker/layout/archive.ejs","hash":"2238cbe29009aafb16969d2c70dceb3f71772123","modified":1498192818000},{"_id":"themes/Hacker/layout/index.ejs","hash":"1d2c487a95d25e763b5f7e004194eb6ee6b18135","modified":1498192818000},{"_id":"themes/Hacker/layout/layout.ejs","hash":"341e77b5f07457e4ccd69634f511da05a5d89f18","modified":1498192818000},{"_id":"themes/Hacker/layout/page.ejs","hash":"84e00bbcc643dff4bd02880b3bbea658f510835f","modified":1498192818000},{"_id":"themes/Hacker/layout/post.ejs","hash":"84e00bbcc643dff4bd02880b3bbea658f510835f","modified":1498192818000},{"_id":"themes/Hacker/layout/tags.ejs","hash":"ee89e6a9c14bdb5e5e8cf975a558c780fe8dabff","modified":1498192818000},{"_id":"themes/Hacker/layout/components/comment.ejs","hash":"34b72f9819b5298be101f5c568cc7f2a52ab0f7d","modified":1498192818000},{"_id":"themes/Hacker/layout/components/article.ejs","hash":"5a08e05eb271589a2ed69fdd08516fa8457af3ed","modified":1498192818000},{"_id":"themes/Hacker/layout/components/categories.ejs","hash":"3665bf5d1c7181db22dc1c48d62ebf42757d8c27","modified":1498192818000},{"_id":"themes/Hacker/layout/components/archive.ejs","hash":"1f79ebaf52b8229cf5c58bb8325cf0177859a05c","modified":1498192818000},{"_id":"themes/Hacker/layout/components/footer.ejs","hash":"538795f4af3a98e824aefc4b68a1bcd210c091e9","modified":1498192818000},{"_id":"themes/Hacker/layout/components/head.ejs","hash":"10475fdfc513c9380f18d034e15b3b051c8e9269","modified":1498192818000},{"_id":"themes/Hacker/layout/components/header.ejs","hash":"929a8eafa278d49c2f41d3581e2608eca80d7856","modified":1498192818000},{"_id":"themes/Hacker/layout/components/googleanalytics.ejs","hash":"fa11251ace0fc61cbcffb74f32fbf5bdbb201ff2","modified":1498192818000},{"_id":"themes/Hacker/layout/components/pagination.ejs","hash":"4ab5e3b0239e467923a0f91c771bcc9ee7889cfe","modified":1498192818000},{"_id":"themes/Hacker/source/css/style.styl","hash":"208e5f6d010e4e2c5590dae5e4fca8de592d3ef1","modified":1498192818000},{"_id":"themes/Hacker/source/images/icon-heart.svg","hash":"ec483e96c88eea013fd8ac71a34a875107397f43","modified":1498192818000},{"_id":"themes/Hacker/source/css/components/article.styl","hash":"e99f13c6744ddaa7f7bfcf0662e4dc6840fae8fa","modified":1498192818000},{"_id":"themes/Hacker/source/css/components/archive.styl","hash":"de701a1dee6e870140565044a08c2c45cfcd4bc3","modified":1498192818000},{"_id":"themes/Hacker/source/css/base/normalize.css","hash":"e58275a588bb631a37a2988145eea231ed23176b","modified":1498192818000},{"_id":"themes/Hacker/source/css/components/categories.styl","hash":"c67e20d60351295cb178b568af42d430f4bcc3e6","modified":1498192818000},{"_id":"themes/Hacker/source/css/components/icon.styl","hash":"8da3ff5b6cd1609fdfe0c564d47391367abc8808","modified":1498192818000},{"_id":"themes/Hacker/source/css/components/footer.styl","hash":"80ef890252d31d3bbfe71740fdcfc54ae14cad8e","modified":1498192818000},{"_id":"themes/Hacker/source/css/components/header.styl","hash":"fa5e6d715d288a327406df78225284c70530cb98","modified":1498192818000},{"_id":"themes/Hacker/source/css/components/layout.styl","hash":"73c1688b95b20cd67669bc5567420f5be8448c9f","modified":1498192818000},{"_id":"themes/Hacker/source/css/components/responsive.styl","hash":"053e7ec4c22845422440660b7e1d6b0dea5b4fbd","modified":1498192818000},{"_id":"themes/Hacker/source/css/components/pagination.styl","hash":"c20a9920bb444c22b20e588f97eba4e03f09a439","modified":1498192818000},{"_id":"themes/Hacker/source/css/components/syntax.styl","hash":"68b7deadab1ac13603eb5e812e1060db25227fd0","modified":1498192818000},{"_id":"themes/Hacker/source/css/components/tags.styl","hash":"684cf4eb4b8671476365e955dceebf096cc0e6ed","modified":1498192818000},{"_id":"public/atom.xml","hash":"1880d8e90ccbba9d9e1725861eff1f5a3b3ba491","modified":1500607754597},{"_id":"public/2017/07/12/weekly-4/index.html","hash":"0115ff4bddbef9f497bf16593aa150d5b130a557","modified":1500607754885},{"_id":"public/2017/07/07/weekly-3/index.html","hash":"c239e3df521a1a3638a4fa836cee6a867f9e1ccc","modified":1500607754891},{"_id":"public/2017/06/30/weekly-2/index.html","hash":"082a776021ca1a79e6fb18a98291fcae3374c002","modified":1500607754892},{"_id":"public/2017/06/23/weekly-1/index.html","hash":"161f8f5fa9c48d55848ca4f1e9a1479217bfd034","modified":1500607754892},{"_id":"public/archives/index.html","hash":"0c8be97d60eb0336f4f149420daaba5345eef48d","modified":1500607754892},{"_id":"public/archives/2017/index.html","hash":"970c63af8099c0657da54295d64e6d0e314225b4","modified":1500607754892},{"_id":"public/archives/2017/06/index.html","hash":"7785b5c9683a43e2a518a46334eb2b281754f4c9","modified":1500607754892},{"_id":"public/archives/2017/07/index.html","hash":"59987e354c27d69132a92de79736eba98a359cea","modified":1500607754892},{"_id":"public/tags/全栈/index.html","hash":"0feef4981a7047551224a9bc1a4d2f906eabfc00","modified":1500607754892},{"_id":"public/tags/Node/index.html","hash":"c9a9b992f9943d74820879a802e277aebb098545","modified":1500607754892},{"_id":"public/tags/weekly/index.html","hash":"f833019cfc1c2ab228ac38e3e1fd9160d6857a24","modified":1500607754892},{"_id":"public/tags/框架/index.html","hash":"61e814f30817a502dc48b20d2d608d3710858ffd","modified":1500607754892},{"_id":"public/tags/测试/index.html","hash":"1f37df8698cc8cb466d7abefcd1b3b30a31b3378","modified":1500607754892},{"_id":"public/tags/设计模式/index.html","hash":"0f9935bc07ba9ed37445ecf2ecb802c6921a1fbb","modified":1500607754892},{"_id":"public/tags/three-js/index.html","hash":"a39acb19f15177394a5eea3f9fa667eae3880340","modified":1500607754893},{"_id":"public/tags/es6/index.html","hash":"ffbbfb37d45e328bfb79c69cb7255ca94080ac11","modified":1500607754893},{"_id":"public/tags/vue/index.html","hash":"28973471229ccbfd3c465427c8b1f30a435371d1","modified":1500607754893},{"_id":"public/tags/算法/index.html","hash":"c676ed964a0e3ce27250f70659b01a37ddabcab0","modified":1500607754893},{"_id":"public/tags/工具/index.html","hash":"305f3d9b6be547a80defa499f61113b6f079ee7f","modified":1500607754893},{"_id":"public/tags/必备技能/index.html","hash":"684462f6beaaddd81b145b65e0444a34ebd80751","modified":1500607754893},{"_id":"public/index.html","hash":"8c5362fb8e422414592faacc041f3daa07e16a39","modified":1500607754893},{"_id":"public/tags/Event-Driven/index.html","hash":"2c212f22711765e465768438d2da5b2262947e65","modified":1500607754896},{"_id":"public/2017/07/21/5-protocols-for-event-driven-api-architectures/index.html","hash":"97af58b8b052f133cc5ae1371cc41306bd987f56","modified":1500607754896},{"_id":"public/images/icon-heart.svg","hash":"ec483e96c88eea013fd8ac71a34a875107397f43","modified":1500607754898},{"_id":"public/css/components/article.css","hash":"563b6fd19e1f5ba4787acd2ef2e1ee876e521cab","modified":1500607755314},{"_id":"public/css/components/archive.css","hash":"14902abf01556a3e23e03ac18c87fa7a5a39d89a","modified":1500607755315},{"_id":"public/css/base/normalize.css","hash":"e58275a588bb631a37a2988145eea231ed23176b","modified":1500607755315},{"_id":"public/css/components/categories.css","hash":"f181d27640f1408f032c5386836c4c2322724f8d","modified":1500607755315},{"_id":"public/css/components/footer.css","hash":"602def895fd52f288b6e93932284aa2e52b7fee0","modified":1500607755315},{"_id":"public/css/components/icon.css","hash":"cdaf1a152184ff7def760f14095e4a2fa16cd6bd","modified":1500607755315},{"_id":"public/css/components/header.css","hash":"51f8a4c736f3b180a7c4c8f804d8060031df6a34","modified":1500607755315},{"_id":"public/css/components/layout.css","hash":"b8625c7b90a973f2e37897f346e6f80b779fd9ca","modified":1500607755315},{"_id":"public/css/components/responsive.css","hash":"216eb94fc69007de995fc8d382670ba00a9574e8","modified":1500607755315},{"_id":"public/css/components/pagination.css","hash":"2f3f9bb1bc6513d08865e7a2fb2160cc47d4a229","modified":1500607755315},{"_id":"public/css/components/syntax.css","hash":"00970bfdb168aa13622c829920907ca3416829f8","modified":1500607755317},{"_id":"public/css/components/tags.css","hash":"1566e94c23ae19dbfc7d2cf433e68242ed657dea","modified":1500607755317},{"_id":"public/css/style.css","hash":"48373889a036d403ca34bc085cabeb302e2a08ee","modified":1500607755318}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"5 Protocols For Event-Driven API Architectures","date":"2017-07-21T04:00:00.000Z","_content":"\n原文：[5 Protocols For Event-Driven API Architectures](http://nordicapis.com/5-protocols-for-event-driven-api-architectures/)\n\nThe internet is a system of communication, and as such, the relationship between client and server, as well as server to server, is one of the most oft-discussed and hotly contested concepts. **event-driven architecture** is a methodology of defining these relationships, and creating systems within a specific set of relationships that allow for extensive functionality.\n\nIn this piece, we’re going to discuss 5 common event-driven methods — **WebSockets**, **WebHooks**, **REST Hooks**, **Pub-Sub**, and **Server Sent Events**. We’ll define what they fundamentally are and do, and how API providers go about using them. Additionally, we’ll provide some pros and cons on each to make choosing a solution for your platform easy and intuitive.\n\n## What is an Event-Driven Architecture?\n\nEvent-driven architectures establish an event that can be consumed and reacted to. But what is an event?\n\nAn event is essentially any significant **change** from one state to another, such as the change from having no messages in your inbox to have a new message in your inbox. This state can be reacted to **internally** (such as when the email program in question realizes a new message has been received), **externally** (when a user sees a notification for a new message), or used to **generate another event** (for instance, the message tally increases by one).\n\nEvent-driven architectures are appealing to API developers because they function very well in **asynchronous** environments. By crafting APIs that **trigger** certain functions on new event delivery, API systems don’t have to inherently wait for synchronous delivery or real time communication. This is hugely beneficial, as eliminating the need to constantly poll endpoints frees resources from otherwise wasteful purposes, reducing both general hardware requirements and call-specific overhead.\n\nFor this reason, event-driven architectures are very, very popular, and lead to improved power, bandwidth, and co-processing than other solutions and architectures such as polling and other poll-centric derivatives.\n\n## 5 Types of Event-Driven Protocols for APIs\n\n### 1: WebSockets\n\n**WebSockets** are an interesting event-driven solution, because, for most browsers, they’re actually baked into the application itself. Essentially, WebSocket is a protocol that provides full-duplex communication on a single TCP connection. It was standardized by the Internet Engineering Task Force as [RFC 6455](https://tools.ietf.org/html/rfc6455), and the WebSocket API in Web IDL was later standardized under the W3C banner.\n\nWhile the protocol itself is meant to be used between **web browsers** and **servers**, the protocol can be used in any case where there is a client-server relationship. The protocol itself is based upon TCP, with the additional HTTP interpretation statement that is considered an “Upgrade request” to allow for interoperability.\n\n#### Pros\nBecause WebSocket is expressly designed for browser operation, it boasts extremely **low overhead** for what it actually does. By establishing a **full-duplex** conversation using a standardized methodology, connection both to and from the two entities can take place simultaneously, resulting in lower overhead and better throughput.\n\nAdditionally, the fact that these communications take place over TCP 80/443 means that environments that traditionally block non-web based applications for security reasons can still handle this protocol, as firewalls allow communication to and from this port.\n\nPerhaps the strongest argument for the use of WebSockets are the fact that they are standardized and **natively supported** by all major browsers, ranging from Microsft Edge to Opera, from Firefox to Chrome. This means that any web application that ties into it will be interactable within the vast majority of both browser-based and browser-independent gateways and applications.\n\n#### Cons\nWebSockets have one distinct major failing — while it might have support for HTTP-like functionality, **it is not HTTP** whatsoever. This has implications, especially when considering optimizing in HTTP such as caching, proxying, etc., that haven’t quite become apparent.\n\nBecause WebSockets are relatively new, having been only officially standardized in 2011, the industry is still understanding what the side effects mean. Most applications that use WebSockets are designed specifically for everything that a WebSocket is — what has yet to be seen, however, is whether or not this solution is better in the long-run than any stateless solution currently available.\n\nThere is of course the fact that, as with other architectures on this list, WebSockets create an “always on” connection during the duration of data transfer. While this is fine for many uses such as media streaming and live stream calculations, it also essentially means that, for WebSockets, there is no scalability. Ports have hardcoded limitations and bandwidth, and thus in order to “scale”, you must add additional ports to match the maximum load. In stateless systems, this is less of an issue, as requests can wait and be made in such a way as to be independent on the state of the server itself.\n\n### 2: WebHooks\n**WebHooks** are a similar concept to the WebSocket. They primarily function using **custom callbacks**, or code that is passed as an argument to another chunk of code and executed at a specified point in time. Essentially, a WebHook is a glorified system of “if this, then do”, allowing for users independent of the event firing to craft a custom response to that event within their own system.\n\nThe term was coined by [Jeff Lindsay](https://twitter.com/progrium) in 2007, and quickly became popular amongst users who wished to create automated responses to exterior behaviors. A great example of this would be a developer pushing a new item to GitHub, which causes an event. A user has a system tied into the URI of a WebHook. When the push is published, the user’s system utilizes the URI of the WebHook to integrate the push into a larger build, thereby creating a compiled component.\n\n#### Pros\nWebHooks function a lot like WebSockets, but they’re different in some key areas. First and foremost, WebSockets are primarily designed for browser-based communications, and while they can be used regardless in any client-server communication, they do not behave well in a **server-to-server** setup.\n\nWebHooks, on the other hand, work very well in server-to-server systems due to how they operate. Because the system essentially functions as the aforementioned “if this then do”, servers can be configured to tie into pre-formed URIs at any time and execute a given function whenever that event is triggered.\n\nAdditionally, WebHooks have the unique benefit of being **based upon HTTP**, unlike WebSockets. This means that the system can be integrated without utilizing any new infrastructure, allowing speedy adoption and relatively simple setup.\n\n#### Cons\nThe problem with WebHooks is that a lot of their functionality can already be placed on the arguably more powerful REST architectural approach. While adopting event-driven architecture is often a requirement of the service being built, it’s a hard sell when it can be mirrored in REST while also giving the wealth of options that REST gives to the user.\n\nThese RESTful solutions such as [RestMS](http://www.restms.org/) are essentially simply message querying services, though, and do require additional infrastructure, which may or may not be doable considering the purpose of the application.\n\nAdditionally, WebHooks can be **resource intensive** to both the client and the server. If the client needs to notify many servers that an event has occurred, and a server needs to listen to a great deal of clients notifying of this change, you can very quickly run into a situation where your network grows uncontrollably. While HTTP does scale quite well, this is a definite negative to consider.\n\nHowever, there are also ways to build a [message queuing service](https://en.wikipedia.org/wiki/Message_queuing_service) on top of HTTP—some RESTful examples include [IronMQ](https://www.iron.io/platform/ironmq/) and RestMS.\n\n### 3: REST Hooks\nSpeaking of RESTful examples, **REST Hooks** is essentially “hooking” baked into REST itself. Defined as an initiative from [Zapier](http://resthooks.org/docs/), this is a subject [we’ve covered before](http://nordicapis.com/stop-polling-and-consider-using-rest-hooks/) — hooks are collated to a single target URL as a subscription, which pings the resource requester when a change is noted.\n\nThis approach is a response to the practice of **polling**, in which a client constantly checks for changes to a resource. Under the REST Hooks paradigm, the client instead waits for a change, and reacts to it. To put it simply, this is a WebHook in REST.\n\n#### Pros\nREST Hooks are obviously super powerful in the correct context — being able to passively receive a resource rather than dedicating processing power to constant polling frees up a lot of the client-side cost.\n\nPerhaps the strongest argument for REST Hooks though, is the fact that it’s **so easy** and **intuitive** to use. While WebHooks utilize HTTP and thus do not need new architecture to set up, they are also limited by the fact that they are built upon HTTP, and can thus be somewhat complex to set up properly and use effectively.\n\nREST Hooks, though, are **subscription based**, and as such, are simply usable by subscribing. This makes it a very easy to use solution while providing a lot of the usability and effectiveness of more complex systems.\n\n#### Cons\nOf course, every solution has its negatives, and REST Hooks are no different. It could be viewed that REST Hooks actually fly in the face of what REST is — [session free and stateless](http://nordicapis.com/defining-stateful-vs-stateless-web-services/). REST Hooks essentially create consistent polling, it’s just moved the polling from one side to another.\n\nThen, there’s the arguable problem that REST Hooks might be doing something that has already been solved. Some would argue that TCP already does most of what REST Hooks is trying to do, and simply layering more solutions on top of HTTP to get what TCP already does is a poor approach.\n\n### 4: Pub-Sub\n**Pub-Sub** is a slightly different approach. Referred to by its full name as **publish-subscribe**, the concept is where events are published to a class without knowledge of the client subscribing to the class. Basically, a user will join one or more classes, and then will receive event updates without regard or knowledge to the event publisher.\n\nThe main difference here is one of conscious choice of provider — in the other solutions noted herein, a user consciously communicates with a given server or provider and receives events as pre-determined. Under the Pub-Sub scheme, the user only specifies which class they wish to be part of and what events they are interested in receiving. From there, they receive these events when one is pushed out.\n\nA way this is often framed in internet discussions is in the frame of a **radio channel**. Record companies, or publishers, issue audio to the station, which then broadcasts this audio to listeners, or subscribers. Pub-sub is the middleman radio station here — listeners don’t know who gave the station the music, nor do the companies know who the listeners are. It is this segmentation that is baked into the pattern.\n\nWhen we talk about Pub-Sub, we need to keep in mind that we’re actually talking about two different things. Pub-Sub can mean the methodology and general concept in programming terms, but it can also mean specific provider solutions based upon that methodology. For instance, Google’s [Cloud Pub/Sub](https://cloud.google.com/pubsub/docs/overview) is an implementation of the general methodology within their cloud service, and allows for asynchronous many-to-many pub-sub relationships as stated above.\n\n#### Pros\nA huge benefit of Pub-Sub is the fact that it’s **loosely coupled**, and thus is extremely scalable and flexible. The only thing the event-provider is doing is generating the content — each other step is done through a separated middleman, and so the content is easily scaled and modulated to the architecture and design of the solution.\n\nAdditionally, Pub-Sub lends itself very well to **testing**. A subscriber is narrowly limited to a set of events that they have requested under a class, so if a failure occurs, this natural segmentation informs the provider as to where the fault is, and which class of users is experiencing the fault.\n\n#### Cons\nUnfortunately, decoupling is also a huge disadvantage for this pattern. By being a **middleman**, Pub-Sub cannot effectively notify the provider that a message has been sent, and the listener is separated from the event and thus may not know if a message wasn’t sent that should have been. Harkening back to the radio explanation, a listener will never know if a song was meant to play on a channel or if the channel is out of range, and once the record executives hand off the music, they’ve got no idea if the user received the songs without direct feedback from them.\n\nAdditionally, while the system is extensible and flexible, instability does occur with high traffic load as subclass after subclass might be constructed to handle further segmentation. This of course leads to the aforementioned instability in addition to increased complexity.\n\nYou must keep in mind that while the relationship between the publisher and subscriber in this model may be beneficial, it also comes with its own difficulties when these relationships need to be modulated. While you can certainly work around this, at this point, you’re fighting the very basis of the pattern, rather than any secondary natures — you’re trying to make dehydrated water, and fighting against the nature of a pattern suggests the pattern to be inherently poor.\n\n> Also read: [Building a Backend for Frontend (BFF) For Your Microservices](http://nordicapis.com/building-a-backend-for-frontend-shim-for-your-microservices/)\n\n### 5: Server Sent Events\n**Server Sent Events**, or SSE, is a communication protocol much like WebSockets, but with the implication of **unidirectional data**. In this architecture, the server is consistently sending updates to the client as an automatic process. This was standardized under HTML5 by the [W3C](https://www.w3.org/TR/2009/WD-eventsource-20091029/), and is thus compatible with any solution that is likewise compatible with HTML5.\n\n> Of note is that there is a competing standardization from the [Web Hypertext Application Technology Working Group](https://whatwg.org/) – this is a relic from movement away from “HTML5” and into what WHATWG is calling “HTML Living Standard”. The general working consensus is that, WHATWG’s standardization is prioritized in the rare cases of divergent standards. This could become more of an issue as time marches forward, given that WHATWG was created due to a perceived lack of interest from W3C towards evolving HTML, but for the time being, either standard is generally acceptable.\nWhile simple in theory, Server Sent Events are anything but simple when considering benefits and drawbacks.\n\n#### Pros\nSSE is **not bidirectional** in its communications — the server is issuing the events in a steady, predictable method. This is hugely beneficial to applications which do not need the two-way communications baked into WebSockets or other such solutions, as this means **lower bandwidth**, and an allowance for the connection to be temporary rather than always-on during the duration of data transfer. By its nature, the data is being transferred one way, and thus there is no need to wait for data to be returned.\n\nAdditionally, at least in theory, SSE is easier to set up in complex situations. You only have to worry about data traveling one direction via one system, thus reducing complexity dramatically. There is no need to define a message exchange protocol, no need to specify data duration or wait times, no need to support bilateral messaging — the single direction saves a lot of complexity.\n\n#### Cons\nThat simplicity could be where SSE fails for particular use cases. SSE is a very poor solution for situations that require **bidirectional communication**, and while this seems obvious, it would surprise many developers to see how many systems actually depend on bidirectional communication for simple functionality.\n\nWhile much of this can be fixed with workarounds, a developer’s goal in choosing an event-driven protocol should be to find one that works out of the box, not to find a solution that might work if configured properly and given secondary systems upon which to depend.\n\nThere is also the issue of **security** and authentication. While two-way systems can easily use authentication methodologies, SSE handles this using **header forwarding**. While headers can be manipulated and overridden in many languages and applications, the EventSource object in JavaScript does not natively support this, which would cause many adoptees some major headaches.\n\nFinally, there is a concern over loss of efficiency with **over transmitting** data. A two-direction system can determine when a client or server disconnects, but SSE can only determine that a client has disconnected after attempting a full data transmission and receiving a noted failure. Because of this, data can be lost rather quickly, and with many failed connections, this loss can mount dramatically over time.\n\n## Conclusion\nThere is no one event-driven solution that works in every use case. While many would argue that event-driven solutions should be REST based, which suggests REST Hooks as the answer, many others would argue that it is entirely situational, and that REST is not always the silver bullet it’s touted to be.\n\nIf you are building for scalability with low overhead in a browser environment, **WebSockets** are a great solution. Conversely, if you’d like those same benefits but are working in a non-browser system, then **WebHooks** should be your approach. **REST Hooks** are not only great for RESTful services, they’re also much easier to set up than either, and thus are great in low-time high-rush situations. **Pub-Sub** can be great if you need to enforce a division between client and server, and this can further be established and controlled in an even stronger way with **Server Sent**.\n\nSimply put, the best solution will be the one that fits your specific situation and build — any of these solutions, given the correct system, is a great solution. To that end, each solution has a very specific use case.\n\n## TLDR Comparison Table\n| PROTOCOL | RELATED TO | STANDARD BODY | NOTES |\n| ------ | ------ | ------ | ------ |\n| WebSockets | TCP, HTTP-like | IETF, W3C | Two-way communication over TCP<br>Designed for web browsers & web servers<br>Good for lower overhead scenarios<br>Supported in all major browsers |\n| Webhooks | URI, HTTP | - | User defined “HTTP callbacks”<br>Triggered by an event HTTP<br>Requests are made to Webhook URI<br>Enables real-time event triggering|\n| REST Hooks | HTTP | Zapier | Lightweight subscription layer<br>Manipulated by a REST API<br>Essentially a WebHook in REST |\n| Pub-Sub | - | - |Client subscribes to classes<br>Bidirectional<br>Middleman layer between client and server<br>Loose coupling|\n| Server Sent | HTTP, HTML5 , DOM | WHATWG, W3C |Server constantly sends updates to the client<br>Unidirectional push notifications as DOM events|\n","source":"_posts/5-protocols-for-event-driven-api-architectures.md","raw":"---\ntitle: 5 Protocols For Event-Driven API Architectures\ndate: 2017-07-21 12:00:00\ntags: [Event-Driven,全栈,Node]\n---\n\n原文：[5 Protocols For Event-Driven API Architectures](http://nordicapis.com/5-protocols-for-event-driven-api-architectures/)\n\nThe internet is a system of communication, and as such, the relationship between client and server, as well as server to server, is one of the most oft-discussed and hotly contested concepts. **event-driven architecture** is a methodology of defining these relationships, and creating systems within a specific set of relationships that allow for extensive functionality.\n\nIn this piece, we’re going to discuss 5 common event-driven methods — **WebSockets**, **WebHooks**, **REST Hooks**, **Pub-Sub**, and **Server Sent Events**. We’ll define what they fundamentally are and do, and how API providers go about using them. Additionally, we’ll provide some pros and cons on each to make choosing a solution for your platform easy and intuitive.\n\n## What is an Event-Driven Architecture?\n\nEvent-driven architectures establish an event that can be consumed and reacted to. But what is an event?\n\nAn event is essentially any significant **change** from one state to another, such as the change from having no messages in your inbox to have a new message in your inbox. This state can be reacted to **internally** (such as when the email program in question realizes a new message has been received), **externally** (when a user sees a notification for a new message), or used to **generate another event** (for instance, the message tally increases by one).\n\nEvent-driven architectures are appealing to API developers because they function very well in **asynchronous** environments. By crafting APIs that **trigger** certain functions on new event delivery, API systems don’t have to inherently wait for synchronous delivery or real time communication. This is hugely beneficial, as eliminating the need to constantly poll endpoints frees resources from otherwise wasteful purposes, reducing both general hardware requirements and call-specific overhead.\n\nFor this reason, event-driven architectures are very, very popular, and lead to improved power, bandwidth, and co-processing than other solutions and architectures such as polling and other poll-centric derivatives.\n\n## 5 Types of Event-Driven Protocols for APIs\n\n### 1: WebSockets\n\n**WebSockets** are an interesting event-driven solution, because, for most browsers, they’re actually baked into the application itself. Essentially, WebSocket is a protocol that provides full-duplex communication on a single TCP connection. It was standardized by the Internet Engineering Task Force as [RFC 6455](https://tools.ietf.org/html/rfc6455), and the WebSocket API in Web IDL was later standardized under the W3C banner.\n\nWhile the protocol itself is meant to be used between **web browsers** and **servers**, the protocol can be used in any case where there is a client-server relationship. The protocol itself is based upon TCP, with the additional HTTP interpretation statement that is considered an “Upgrade request” to allow for interoperability.\n\n#### Pros\nBecause WebSocket is expressly designed for browser operation, it boasts extremely **low overhead** for what it actually does. By establishing a **full-duplex** conversation using a standardized methodology, connection both to and from the two entities can take place simultaneously, resulting in lower overhead and better throughput.\n\nAdditionally, the fact that these communications take place over TCP 80/443 means that environments that traditionally block non-web based applications for security reasons can still handle this protocol, as firewalls allow communication to and from this port.\n\nPerhaps the strongest argument for the use of WebSockets are the fact that they are standardized and **natively supported** by all major browsers, ranging from Microsft Edge to Opera, from Firefox to Chrome. This means that any web application that ties into it will be interactable within the vast majority of both browser-based and browser-independent gateways and applications.\n\n#### Cons\nWebSockets have one distinct major failing — while it might have support for HTTP-like functionality, **it is not HTTP** whatsoever. This has implications, especially when considering optimizing in HTTP such as caching, proxying, etc., that haven’t quite become apparent.\n\nBecause WebSockets are relatively new, having been only officially standardized in 2011, the industry is still understanding what the side effects mean. Most applications that use WebSockets are designed specifically for everything that a WebSocket is — what has yet to be seen, however, is whether or not this solution is better in the long-run than any stateless solution currently available.\n\nThere is of course the fact that, as with other architectures on this list, WebSockets create an “always on” connection during the duration of data transfer. While this is fine for many uses such as media streaming and live stream calculations, it also essentially means that, for WebSockets, there is no scalability. Ports have hardcoded limitations and bandwidth, and thus in order to “scale”, you must add additional ports to match the maximum load. In stateless systems, this is less of an issue, as requests can wait and be made in such a way as to be independent on the state of the server itself.\n\n### 2: WebHooks\n**WebHooks** are a similar concept to the WebSocket. They primarily function using **custom callbacks**, or code that is passed as an argument to another chunk of code and executed at a specified point in time. Essentially, a WebHook is a glorified system of “if this, then do”, allowing for users independent of the event firing to craft a custom response to that event within their own system.\n\nThe term was coined by [Jeff Lindsay](https://twitter.com/progrium) in 2007, and quickly became popular amongst users who wished to create automated responses to exterior behaviors. A great example of this would be a developer pushing a new item to GitHub, which causes an event. A user has a system tied into the URI of a WebHook. When the push is published, the user’s system utilizes the URI of the WebHook to integrate the push into a larger build, thereby creating a compiled component.\n\n#### Pros\nWebHooks function a lot like WebSockets, but they’re different in some key areas. First and foremost, WebSockets are primarily designed for browser-based communications, and while they can be used regardless in any client-server communication, they do not behave well in a **server-to-server** setup.\n\nWebHooks, on the other hand, work very well in server-to-server systems due to how they operate. Because the system essentially functions as the aforementioned “if this then do”, servers can be configured to tie into pre-formed URIs at any time and execute a given function whenever that event is triggered.\n\nAdditionally, WebHooks have the unique benefit of being **based upon HTTP**, unlike WebSockets. This means that the system can be integrated without utilizing any new infrastructure, allowing speedy adoption and relatively simple setup.\n\n#### Cons\nThe problem with WebHooks is that a lot of their functionality can already be placed on the arguably more powerful REST architectural approach. While adopting event-driven architecture is often a requirement of the service being built, it’s a hard sell when it can be mirrored in REST while also giving the wealth of options that REST gives to the user.\n\nThese RESTful solutions such as [RestMS](http://www.restms.org/) are essentially simply message querying services, though, and do require additional infrastructure, which may or may not be doable considering the purpose of the application.\n\nAdditionally, WebHooks can be **resource intensive** to both the client and the server. If the client needs to notify many servers that an event has occurred, and a server needs to listen to a great deal of clients notifying of this change, you can very quickly run into a situation where your network grows uncontrollably. While HTTP does scale quite well, this is a definite negative to consider.\n\nHowever, there are also ways to build a [message queuing service](https://en.wikipedia.org/wiki/Message_queuing_service) on top of HTTP—some RESTful examples include [IronMQ](https://www.iron.io/platform/ironmq/) and RestMS.\n\n### 3: REST Hooks\nSpeaking of RESTful examples, **REST Hooks** is essentially “hooking” baked into REST itself. Defined as an initiative from [Zapier](http://resthooks.org/docs/), this is a subject [we’ve covered before](http://nordicapis.com/stop-polling-and-consider-using-rest-hooks/) — hooks are collated to a single target URL as a subscription, which pings the resource requester when a change is noted.\n\nThis approach is a response to the practice of **polling**, in which a client constantly checks for changes to a resource. Under the REST Hooks paradigm, the client instead waits for a change, and reacts to it. To put it simply, this is a WebHook in REST.\n\n#### Pros\nREST Hooks are obviously super powerful in the correct context — being able to passively receive a resource rather than dedicating processing power to constant polling frees up a lot of the client-side cost.\n\nPerhaps the strongest argument for REST Hooks though, is the fact that it’s **so easy** and **intuitive** to use. While WebHooks utilize HTTP and thus do not need new architecture to set up, they are also limited by the fact that they are built upon HTTP, and can thus be somewhat complex to set up properly and use effectively.\n\nREST Hooks, though, are **subscription based**, and as such, are simply usable by subscribing. This makes it a very easy to use solution while providing a lot of the usability and effectiveness of more complex systems.\n\n#### Cons\nOf course, every solution has its negatives, and REST Hooks are no different. It could be viewed that REST Hooks actually fly in the face of what REST is — [session free and stateless](http://nordicapis.com/defining-stateful-vs-stateless-web-services/). REST Hooks essentially create consistent polling, it’s just moved the polling from one side to another.\n\nThen, there’s the arguable problem that REST Hooks might be doing something that has already been solved. Some would argue that TCP already does most of what REST Hooks is trying to do, and simply layering more solutions on top of HTTP to get what TCP already does is a poor approach.\n\n### 4: Pub-Sub\n**Pub-Sub** is a slightly different approach. Referred to by its full name as **publish-subscribe**, the concept is where events are published to a class without knowledge of the client subscribing to the class. Basically, a user will join one or more classes, and then will receive event updates without regard or knowledge to the event publisher.\n\nThe main difference here is one of conscious choice of provider — in the other solutions noted herein, a user consciously communicates with a given server or provider and receives events as pre-determined. Under the Pub-Sub scheme, the user only specifies which class they wish to be part of and what events they are interested in receiving. From there, they receive these events when one is pushed out.\n\nA way this is often framed in internet discussions is in the frame of a **radio channel**. Record companies, or publishers, issue audio to the station, which then broadcasts this audio to listeners, or subscribers. Pub-sub is the middleman radio station here — listeners don’t know who gave the station the music, nor do the companies know who the listeners are. It is this segmentation that is baked into the pattern.\n\nWhen we talk about Pub-Sub, we need to keep in mind that we’re actually talking about two different things. Pub-Sub can mean the methodology and general concept in programming terms, but it can also mean specific provider solutions based upon that methodology. For instance, Google’s [Cloud Pub/Sub](https://cloud.google.com/pubsub/docs/overview) is an implementation of the general methodology within their cloud service, and allows for asynchronous many-to-many pub-sub relationships as stated above.\n\n#### Pros\nA huge benefit of Pub-Sub is the fact that it’s **loosely coupled**, and thus is extremely scalable and flexible. The only thing the event-provider is doing is generating the content — each other step is done through a separated middleman, and so the content is easily scaled and modulated to the architecture and design of the solution.\n\nAdditionally, Pub-Sub lends itself very well to **testing**. A subscriber is narrowly limited to a set of events that they have requested under a class, so if a failure occurs, this natural segmentation informs the provider as to where the fault is, and which class of users is experiencing the fault.\n\n#### Cons\nUnfortunately, decoupling is also a huge disadvantage for this pattern. By being a **middleman**, Pub-Sub cannot effectively notify the provider that a message has been sent, and the listener is separated from the event and thus may not know if a message wasn’t sent that should have been. Harkening back to the radio explanation, a listener will never know if a song was meant to play on a channel or if the channel is out of range, and once the record executives hand off the music, they’ve got no idea if the user received the songs without direct feedback from them.\n\nAdditionally, while the system is extensible and flexible, instability does occur with high traffic load as subclass after subclass might be constructed to handle further segmentation. This of course leads to the aforementioned instability in addition to increased complexity.\n\nYou must keep in mind that while the relationship between the publisher and subscriber in this model may be beneficial, it also comes with its own difficulties when these relationships need to be modulated. While you can certainly work around this, at this point, you’re fighting the very basis of the pattern, rather than any secondary natures — you’re trying to make dehydrated water, and fighting against the nature of a pattern suggests the pattern to be inherently poor.\n\n> Also read: [Building a Backend for Frontend (BFF) For Your Microservices](http://nordicapis.com/building-a-backend-for-frontend-shim-for-your-microservices/)\n\n### 5: Server Sent Events\n**Server Sent Events**, or SSE, is a communication protocol much like WebSockets, but with the implication of **unidirectional data**. In this architecture, the server is consistently sending updates to the client as an automatic process. This was standardized under HTML5 by the [W3C](https://www.w3.org/TR/2009/WD-eventsource-20091029/), and is thus compatible with any solution that is likewise compatible with HTML5.\n\n> Of note is that there is a competing standardization from the [Web Hypertext Application Technology Working Group](https://whatwg.org/) – this is a relic from movement away from “HTML5” and into what WHATWG is calling “HTML Living Standard”. The general working consensus is that, WHATWG’s standardization is prioritized in the rare cases of divergent standards. This could become more of an issue as time marches forward, given that WHATWG was created due to a perceived lack of interest from W3C towards evolving HTML, but for the time being, either standard is generally acceptable.\nWhile simple in theory, Server Sent Events are anything but simple when considering benefits and drawbacks.\n\n#### Pros\nSSE is **not bidirectional** in its communications — the server is issuing the events in a steady, predictable method. This is hugely beneficial to applications which do not need the two-way communications baked into WebSockets or other such solutions, as this means **lower bandwidth**, and an allowance for the connection to be temporary rather than always-on during the duration of data transfer. By its nature, the data is being transferred one way, and thus there is no need to wait for data to be returned.\n\nAdditionally, at least in theory, SSE is easier to set up in complex situations. You only have to worry about data traveling one direction via one system, thus reducing complexity dramatically. There is no need to define a message exchange protocol, no need to specify data duration or wait times, no need to support bilateral messaging — the single direction saves a lot of complexity.\n\n#### Cons\nThat simplicity could be where SSE fails for particular use cases. SSE is a very poor solution for situations that require **bidirectional communication**, and while this seems obvious, it would surprise many developers to see how many systems actually depend on bidirectional communication for simple functionality.\n\nWhile much of this can be fixed with workarounds, a developer’s goal in choosing an event-driven protocol should be to find one that works out of the box, not to find a solution that might work if configured properly and given secondary systems upon which to depend.\n\nThere is also the issue of **security** and authentication. While two-way systems can easily use authentication methodologies, SSE handles this using **header forwarding**. While headers can be manipulated and overridden in many languages and applications, the EventSource object in JavaScript does not natively support this, which would cause many adoptees some major headaches.\n\nFinally, there is a concern over loss of efficiency with **over transmitting** data. A two-direction system can determine when a client or server disconnects, but SSE can only determine that a client has disconnected after attempting a full data transmission and receiving a noted failure. Because of this, data can be lost rather quickly, and with many failed connections, this loss can mount dramatically over time.\n\n## Conclusion\nThere is no one event-driven solution that works in every use case. While many would argue that event-driven solutions should be REST based, which suggests REST Hooks as the answer, many others would argue that it is entirely situational, and that REST is not always the silver bullet it’s touted to be.\n\nIf you are building for scalability with low overhead in a browser environment, **WebSockets** are a great solution. Conversely, if you’d like those same benefits but are working in a non-browser system, then **WebHooks** should be your approach. **REST Hooks** are not only great for RESTful services, they’re also much easier to set up than either, and thus are great in low-time high-rush situations. **Pub-Sub** can be great if you need to enforce a division between client and server, and this can further be established and controlled in an even stronger way with **Server Sent**.\n\nSimply put, the best solution will be the one that fits your specific situation and build — any of these solutions, given the correct system, is a great solution. To that end, each solution has a very specific use case.\n\n## TLDR Comparison Table\n| PROTOCOL | RELATED TO | STANDARD BODY | NOTES |\n| ------ | ------ | ------ | ------ |\n| WebSockets | TCP, HTTP-like | IETF, W3C | Two-way communication over TCP<br>Designed for web browsers & web servers<br>Good for lower overhead scenarios<br>Supported in all major browsers |\n| Webhooks | URI, HTTP | - | User defined “HTTP callbacks”<br>Triggered by an event HTTP<br>Requests are made to Webhook URI<br>Enables real-time event triggering|\n| REST Hooks | HTTP | Zapier | Lightweight subscription layer<br>Manipulated by a REST API<br>Essentially a WebHook in REST |\n| Pub-Sub | - | - |Client subscribes to classes<br>Bidirectional<br>Middleman layer between client and server<br>Loose coupling|\n| Server Sent | HTTP, HTML5 , DOM | WHATWG, W3C |Server constantly sends updates to the client<br>Unidirectional push notifications as DOM events|\n","slug":"5-protocols-for-event-driven-api-architectures","published":1,"updated":"2017-07-21T03:28:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5db41ib000081txse2l5z2p","content":"<p>原文：<a href=\"http://nordicapis.com/5-protocols-for-event-driven-api-architectures/\" target=\"_blank\" rel=\"external\">5 Protocols For Event-Driven API Architectures</a></p>\n<p>The internet is a system of communication, and as such, the relationship between client and server, as well as server to server, is one of the most oft-discussed and hotly contested concepts. <strong>event-driven architecture</strong> is a methodology of defining these relationships, and creating systems within a specific set of relationships that allow for extensive functionality.</p>\n<p>In this piece, we’re going to discuss 5 common event-driven methods — <strong>WebSockets</strong>, <strong>WebHooks</strong>, <strong>REST Hooks</strong>, <strong>Pub-Sub</strong>, and <strong>Server Sent Events</strong>. We’ll define what they fundamentally are and do, and how API providers go about using them. Additionally, we’ll provide some pros and cons on each to make choosing a solution for your platform easy and intuitive.</p>\n<h2 id=\"What-is-an-Event-Driven-Architecture\"><a href=\"#What-is-an-Event-Driven-Architecture\" class=\"headerlink\" title=\"What is an Event-Driven Architecture?\"></a>What is an Event-Driven Architecture?</h2><p>Event-driven architectures establish an event that can be consumed and reacted to. But what is an event?</p>\n<p>An event is essentially any significant <strong>change</strong> from one state to another, such as the change from having no messages in your inbox to have a new message in your inbox. This state can be reacted to <strong>internally</strong> (such as when the email program in question realizes a new message has been received), <strong>externally</strong> (when a user sees a notification for a new message), or used to <strong>generate another event</strong> (for instance, the message tally increases by one).</p>\n<p>Event-driven architectures are appealing to API developers because they function very well in <strong>asynchronous</strong> environments. By crafting APIs that <strong>trigger</strong> certain functions on new event delivery, API systems don’t have to inherently wait for synchronous delivery or real time communication. This is hugely beneficial, as eliminating the need to constantly poll endpoints frees resources from otherwise wasteful purposes, reducing both general hardware requirements and call-specific overhead.</p>\n<p>For this reason, event-driven architectures are very, very popular, and lead to improved power, bandwidth, and co-processing than other solutions and architectures such as polling and other poll-centric derivatives.</p>\n<h2 id=\"5-Types-of-Event-Driven-Protocols-for-APIs\"><a href=\"#5-Types-of-Event-Driven-Protocols-for-APIs\" class=\"headerlink\" title=\"5 Types of Event-Driven Protocols for APIs\"></a>5 Types of Event-Driven Protocols for APIs</h2><h3 id=\"1-WebSockets\"><a href=\"#1-WebSockets\" class=\"headerlink\" title=\"1: WebSockets\"></a>1: WebSockets</h3><p><strong>WebSockets</strong> are an interesting event-driven solution, because, for most browsers, they’re actually baked into the application itself. Essentially, WebSocket is a protocol that provides full-duplex communication on a single TCP connection. It was standardized by the Internet Engineering Task Force as <a href=\"https://tools.ietf.org/html/rfc6455\" target=\"_blank\" rel=\"external\">RFC 6455</a>, and the WebSocket API in Web IDL was later standardized under the W3C banner.</p>\n<p>While the protocol itself is meant to be used between <strong>web browsers</strong> and <strong>servers</strong>, the protocol can be used in any case where there is a client-server relationship. The protocol itself is based upon TCP, with the additional HTTP interpretation statement that is considered an “Upgrade request” to allow for interoperability.</p>\n<h4 id=\"Pros\"><a href=\"#Pros\" class=\"headerlink\" title=\"Pros\"></a>Pros</h4><p>Because WebSocket is expressly designed for browser operation, it boasts extremely <strong>low overhead</strong> for what it actually does. By establishing a <strong>full-duplex</strong> conversation using a standardized methodology, connection both to and from the two entities can take place simultaneously, resulting in lower overhead and better throughput.</p>\n<p>Additionally, the fact that these communications take place over TCP 80/443 means that environments that traditionally block non-web based applications for security reasons can still handle this protocol, as firewalls allow communication to and from this port.</p>\n<p>Perhaps the strongest argument for the use of WebSockets are the fact that they are standardized and <strong>natively supported</strong> by all major browsers, ranging from Microsft Edge to Opera, from Firefox to Chrome. This means that any web application that ties into it will be interactable within the vast majority of both browser-based and browser-independent gateways and applications.</p>\n<h4 id=\"Cons\"><a href=\"#Cons\" class=\"headerlink\" title=\"Cons\"></a>Cons</h4><p>WebSockets have one distinct major failing — while it might have support for HTTP-like functionality, <strong>it is not HTTP</strong> whatsoever. This has implications, especially when considering optimizing in HTTP such as caching, proxying, etc., that haven’t quite become apparent.</p>\n<p>Because WebSockets are relatively new, having been only officially standardized in 2011, the industry is still understanding what the side effects mean. Most applications that use WebSockets are designed specifically for everything that a WebSocket is — what has yet to be seen, however, is whether or not this solution is better in the long-run than any stateless solution currently available.</p>\n<p>There is of course the fact that, as with other architectures on this list, WebSockets create an “always on” connection during the duration of data transfer. While this is fine for many uses such as media streaming and live stream calculations, it also essentially means that, for WebSockets, there is no scalability. Ports have hardcoded limitations and bandwidth, and thus in order to “scale”, you must add additional ports to match the maximum load. In stateless systems, this is less of an issue, as requests can wait and be made in such a way as to be independent on the state of the server itself.</p>\n<h3 id=\"2-WebHooks\"><a href=\"#2-WebHooks\" class=\"headerlink\" title=\"2: WebHooks\"></a>2: WebHooks</h3><p><strong>WebHooks</strong> are a similar concept to the WebSocket. They primarily function using <strong>custom callbacks</strong>, or code that is passed as an argument to another chunk of code and executed at a specified point in time. Essentially, a WebHook is a glorified system of “if this, then do”, allowing for users independent of the event firing to craft a custom response to that event within their own system.</p>\n<p>The term was coined by <a href=\"https://twitter.com/progrium\" target=\"_blank\" rel=\"external\">Jeff Lindsay</a> in 2007, and quickly became popular amongst users who wished to create automated responses to exterior behaviors. A great example of this would be a developer pushing a new item to GitHub, which causes an event. A user has a system tied into the URI of a WebHook. When the push is published, the user’s system utilizes the URI of the WebHook to integrate the push into a larger build, thereby creating a compiled component.</p>\n<h4 id=\"Pros-1\"><a href=\"#Pros-1\" class=\"headerlink\" title=\"Pros\"></a>Pros</h4><p>WebHooks function a lot like WebSockets, but they’re different in some key areas. First and foremost, WebSockets are primarily designed for browser-based communications, and while they can be used regardless in any client-server communication, they do not behave well in a <strong>server-to-server</strong> setup.</p>\n<p>WebHooks, on the other hand, work very well in server-to-server systems due to how they operate. Because the system essentially functions as the aforementioned “if this then do”, servers can be configured to tie into pre-formed URIs at any time and execute a given function whenever that event is triggered.</p>\n<p>Additionally, WebHooks have the unique benefit of being <strong>based upon HTTP</strong>, unlike WebSockets. This means that the system can be integrated without utilizing any new infrastructure, allowing speedy adoption and relatively simple setup.</p>\n<h4 id=\"Cons-1\"><a href=\"#Cons-1\" class=\"headerlink\" title=\"Cons\"></a>Cons</h4><p>The problem with WebHooks is that a lot of their functionality can already be placed on the arguably more powerful REST architectural approach. While adopting event-driven architecture is often a requirement of the service being built, it’s a hard sell when it can be mirrored in REST while also giving the wealth of options that REST gives to the user.</p>\n<p>These RESTful solutions such as <a href=\"http://www.restms.org/\" target=\"_blank\" rel=\"external\">RestMS</a> are essentially simply message querying services, though, and do require additional infrastructure, which may or may not be doable considering the purpose of the application.</p>\n<p>Additionally, WebHooks can be <strong>resource intensive</strong> to both the client and the server. If the client needs to notify many servers that an event has occurred, and a server needs to listen to a great deal of clients notifying of this change, you can very quickly run into a situation where your network grows uncontrollably. While HTTP does scale quite well, this is a definite negative to consider.</p>\n<p>However, there are also ways to build a <a href=\"https://en.wikipedia.org/wiki/Message_queuing_service\" target=\"_blank\" rel=\"external\">message queuing service</a> on top of HTTP—some RESTful examples include <a href=\"https://www.iron.io/platform/ironmq/\" target=\"_blank\" rel=\"external\">IronMQ</a> and RestMS.</p>\n<h3 id=\"3-REST-Hooks\"><a href=\"#3-REST-Hooks\" class=\"headerlink\" title=\"3: REST Hooks\"></a>3: REST Hooks</h3><p>Speaking of RESTful examples, <strong>REST Hooks</strong> is essentially “hooking” baked into REST itself. Defined as an initiative from <a href=\"http://resthooks.org/docs/\" target=\"_blank\" rel=\"external\">Zapier</a>, this is a subject <a href=\"http://nordicapis.com/stop-polling-and-consider-using-rest-hooks/\" target=\"_blank\" rel=\"external\">we’ve covered before</a> — hooks are collated to a single target URL as a subscription, which pings the resource requester when a change is noted.</p>\n<p>This approach is a response to the practice of <strong>polling</strong>, in which a client constantly checks for changes to a resource. Under the REST Hooks paradigm, the client instead waits for a change, and reacts to it. To put it simply, this is a WebHook in REST.</p>\n<h4 id=\"Pros-2\"><a href=\"#Pros-2\" class=\"headerlink\" title=\"Pros\"></a>Pros</h4><p>REST Hooks are obviously super powerful in the correct context — being able to passively receive a resource rather than dedicating processing power to constant polling frees up a lot of the client-side cost.</p>\n<p>Perhaps the strongest argument for REST Hooks though, is the fact that it’s <strong>so easy</strong> and <strong>intuitive</strong> to use. While WebHooks utilize HTTP and thus do not need new architecture to set up, they are also limited by the fact that they are built upon HTTP, and can thus be somewhat complex to set up properly and use effectively.</p>\n<p>REST Hooks, though, are <strong>subscription based</strong>, and as such, are simply usable by subscribing. This makes it a very easy to use solution while providing a lot of the usability and effectiveness of more complex systems.</p>\n<h4 id=\"Cons-2\"><a href=\"#Cons-2\" class=\"headerlink\" title=\"Cons\"></a>Cons</h4><p>Of course, every solution has its negatives, and REST Hooks are no different. It could be viewed that REST Hooks actually fly in the face of what REST is — <a href=\"http://nordicapis.com/defining-stateful-vs-stateless-web-services/\" target=\"_blank\" rel=\"external\">session free and stateless</a>. REST Hooks essentially create consistent polling, it’s just moved the polling from one side to another.</p>\n<p>Then, there’s the arguable problem that REST Hooks might be doing something that has already been solved. Some would argue that TCP already does most of what REST Hooks is trying to do, and simply layering more solutions on top of HTTP to get what TCP already does is a poor approach.</p>\n<h3 id=\"4-Pub-Sub\"><a href=\"#4-Pub-Sub\" class=\"headerlink\" title=\"4: Pub-Sub\"></a>4: Pub-Sub</h3><p><strong>Pub-Sub</strong> is a slightly different approach. Referred to by its full name as <strong>publish-subscribe</strong>, the concept is where events are published to a class without knowledge of the client subscribing to the class. Basically, a user will join one or more classes, and then will receive event updates without regard or knowledge to the event publisher.</p>\n<p>The main difference here is one of conscious choice of provider — in the other solutions noted herein, a user consciously communicates with a given server or provider and receives events as pre-determined. Under the Pub-Sub scheme, the user only specifies which class they wish to be part of and what events they are interested in receiving. From there, they receive these events when one is pushed out.</p>\n<p>A way this is often framed in internet discussions is in the frame of a <strong>radio channel</strong>. Record companies, or publishers, issue audio to the station, which then broadcasts this audio to listeners, or subscribers. Pub-sub is the middleman radio station here — listeners don’t know who gave the station the music, nor do the companies know who the listeners are. It is this segmentation that is baked into the pattern.</p>\n<p>When we talk about Pub-Sub, we need to keep in mind that we’re actually talking about two different things. Pub-Sub can mean the methodology and general concept in programming terms, but it can also mean specific provider solutions based upon that methodology. For instance, Google’s <a href=\"https://cloud.google.com/pubsub/docs/overview\" target=\"_blank\" rel=\"external\">Cloud Pub/Sub</a> is an implementation of the general methodology within their cloud service, and allows for asynchronous many-to-many pub-sub relationships as stated above.</p>\n<h4 id=\"Pros-3\"><a href=\"#Pros-3\" class=\"headerlink\" title=\"Pros\"></a>Pros</h4><p>A huge benefit of Pub-Sub is the fact that it’s <strong>loosely coupled</strong>, and thus is extremely scalable and flexible. The only thing the event-provider is doing is generating the content — each other step is done through a separated middleman, and so the content is easily scaled and modulated to the architecture and design of the solution.</p>\n<p>Additionally, Pub-Sub lends itself very well to <strong>testing</strong>. A subscriber is narrowly limited to a set of events that they have requested under a class, so if a failure occurs, this natural segmentation informs the provider as to where the fault is, and which class of users is experiencing the fault.</p>\n<h4 id=\"Cons-3\"><a href=\"#Cons-3\" class=\"headerlink\" title=\"Cons\"></a>Cons</h4><p>Unfortunately, decoupling is also a huge disadvantage for this pattern. By being a <strong>middleman</strong>, Pub-Sub cannot effectively notify the provider that a message has been sent, and the listener is separated from the event and thus may not know if a message wasn’t sent that should have been. Harkening back to the radio explanation, a listener will never know if a song was meant to play on a channel or if the channel is out of range, and once the record executives hand off the music, they’ve got no idea if the user received the songs without direct feedback from them.</p>\n<p>Additionally, while the system is extensible and flexible, instability does occur with high traffic load as subclass after subclass might be constructed to handle further segmentation. This of course leads to the aforementioned instability in addition to increased complexity.</p>\n<p>You must keep in mind that while the relationship between the publisher and subscriber in this model may be beneficial, it also comes with its own difficulties when these relationships need to be modulated. While you can certainly work around this, at this point, you’re fighting the very basis of the pattern, rather than any secondary natures — you’re trying to make dehydrated water, and fighting against the nature of a pattern suggests the pattern to be inherently poor.</p>\n<blockquote>\n<p>Also read: <a href=\"http://nordicapis.com/building-a-backend-for-frontend-shim-for-your-microservices/\" target=\"_blank\" rel=\"external\">Building a Backend for Frontend (BFF) For Your Microservices</a></p>\n</blockquote>\n<h3 id=\"5-Server-Sent-Events\"><a href=\"#5-Server-Sent-Events\" class=\"headerlink\" title=\"5: Server Sent Events\"></a>5: Server Sent Events</h3><p><strong>Server Sent Events</strong>, or SSE, is a communication protocol much like WebSockets, but with the implication of <strong>unidirectional data</strong>. In this architecture, the server is consistently sending updates to the client as an automatic process. This was standardized under HTML5 by the <a href=\"https://www.w3.org/TR/2009/WD-eventsource-20091029/\" target=\"_blank\" rel=\"external\">W3C</a>, and is thus compatible with any solution that is likewise compatible with HTML5.</p>\n<blockquote>\n<p>Of note is that there is a competing standardization from the <a href=\"https://whatwg.org/\" target=\"_blank\" rel=\"external\">Web Hypertext Application Technology Working Group</a> – this is a relic from movement away from “HTML5” and into what WHATWG is calling “HTML Living Standard”. The general working consensus is that, WHATWG’s standardization is prioritized in the rare cases of divergent standards. This could become more of an issue as time marches forward, given that WHATWG was created due to a perceived lack of interest from W3C towards evolving HTML, but for the time being, either standard is generally acceptable.<br>While simple in theory, Server Sent Events are anything but simple when considering benefits and drawbacks.</p>\n</blockquote>\n<h4 id=\"Pros-4\"><a href=\"#Pros-4\" class=\"headerlink\" title=\"Pros\"></a>Pros</h4><p>SSE is <strong>not bidirectional</strong> in its communications — the server is issuing the events in a steady, predictable method. This is hugely beneficial to applications which do not need the two-way communications baked into WebSockets or other such solutions, as this means <strong>lower bandwidth</strong>, and an allowance for the connection to be temporary rather than always-on during the duration of data transfer. By its nature, the data is being transferred one way, and thus there is no need to wait for data to be returned.</p>\n<p>Additionally, at least in theory, SSE is easier to set up in complex situations. You only have to worry about data traveling one direction via one system, thus reducing complexity dramatically. There is no need to define a message exchange protocol, no need to specify data duration or wait times, no need to support bilateral messaging — the single direction saves a lot of complexity.</p>\n<h4 id=\"Cons-4\"><a href=\"#Cons-4\" class=\"headerlink\" title=\"Cons\"></a>Cons</h4><p>That simplicity could be where SSE fails for particular use cases. SSE is a very poor solution for situations that require <strong>bidirectional communication</strong>, and while this seems obvious, it would surprise many developers to see how many systems actually depend on bidirectional communication for simple functionality.</p>\n<p>While much of this can be fixed with workarounds, a developer’s goal in choosing an event-driven protocol should be to find one that works out of the box, not to find a solution that might work if configured properly and given secondary systems upon which to depend.</p>\n<p>There is also the issue of <strong>security</strong> and authentication. While two-way systems can easily use authentication methodologies, SSE handles this using <strong>header forwarding</strong>. While headers can be manipulated and overridden in many languages and applications, the EventSource object in JavaScript does not natively support this, which would cause many adoptees some major headaches.</p>\n<p>Finally, there is a concern over loss of efficiency with <strong>over transmitting</strong> data. A two-direction system can determine when a client or server disconnects, but SSE can only determine that a client has disconnected after attempting a full data transmission and receiving a noted failure. Because of this, data can be lost rather quickly, and with many failed connections, this loss can mount dramatically over time.</p>\n<h2 id=\"Conclusion\"><a href=\"#Conclusion\" class=\"headerlink\" title=\"Conclusion\"></a>Conclusion</h2><p>There is no one event-driven solution that works in every use case. While many would argue that event-driven solutions should be REST based, which suggests REST Hooks as the answer, many others would argue that it is entirely situational, and that REST is not always the silver bullet it’s touted to be.</p>\n<p>If you are building for scalability with low overhead in a browser environment, <strong>WebSockets</strong> are a great solution. Conversely, if you’d like those same benefits but are working in a non-browser system, then <strong>WebHooks</strong> should be your approach. <strong>REST Hooks</strong> are not only great for RESTful services, they’re also much easier to set up than either, and thus are great in low-time high-rush situations. <strong>Pub-Sub</strong> can be great if you need to enforce a division between client and server, and this can further be established and controlled in an even stronger way with <strong>Server Sent</strong>.</p>\n<p>Simply put, the best solution will be the one that fits your specific situation and build — any of these solutions, given the correct system, is a great solution. To that end, each solution has a very specific use case.</p>\n<h2 id=\"TLDR-Comparison-Table\"><a href=\"#TLDR-Comparison-Table\" class=\"headerlink\" title=\"TLDR Comparison Table\"></a>TLDR Comparison Table</h2><table>\n<thead>\n<tr>\n<th>PROTOCOL</th>\n<th>RELATED TO</th>\n<th>STANDARD BODY</th>\n<th>NOTES</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>WebSockets</td>\n<td>TCP, HTTP-like</td>\n<td>IETF, W3C</td>\n<td>Two-way communication over TCP<br>Designed for web browsers &amp; web servers<br>Good for lower overhead scenarios<br>Supported in all major browsers</td>\n</tr>\n<tr>\n<td>Webhooks</td>\n<td>URI, HTTP</td>\n<td>-</td>\n<td>User defined “HTTP callbacks”<br>Triggered by an event HTTP<br>Requests are made to Webhook URI<br>Enables real-time event triggering</td>\n</tr>\n<tr>\n<td>REST Hooks</td>\n<td>HTTP</td>\n<td>Zapier</td>\n<td>Lightweight subscription layer<br>Manipulated by a REST API<br>Essentially a WebHook in REST</td>\n</tr>\n<tr>\n<td>Pub-Sub</td>\n<td>-</td>\n<td>-</td>\n<td>Client subscribes to classes<br>Bidirectional<br>Middleman layer between client and server<br>Loose coupling</td>\n</tr>\n<tr>\n<td>Server Sent</td>\n<td>HTTP, HTML5 , DOM</td>\n<td>WHATWG, W3C</td>\n<td>Server constantly sends updates to the client<br>Unidirectional push notifications as DOM events</td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{}},"excerpt":"","more":"<p>原文：<a href=\"http://nordicapis.com/5-protocols-for-event-driven-api-architectures/\" target=\"_blank\" rel=\"external\">5 Protocols For Event-Driven API Architectures</a></p>\n<p>The internet is a system of communication, and as such, the relationship between client and server, as well as server to server, is one of the most oft-discussed and hotly contested concepts. <strong>event-driven architecture</strong> is a methodology of defining these relationships, and creating systems within a specific set of relationships that allow for extensive functionality.</p>\n<p>In this piece, we’re going to discuss 5 common event-driven methods — <strong>WebSockets</strong>, <strong>WebHooks</strong>, <strong>REST Hooks</strong>, <strong>Pub-Sub</strong>, and <strong>Server Sent Events</strong>. We’ll define what they fundamentally are and do, and how API providers go about using them. Additionally, we’ll provide some pros and cons on each to make choosing a solution for your platform easy and intuitive.</p>\n<h2 id=\"What-is-an-Event-Driven-Architecture\"><a href=\"#What-is-an-Event-Driven-Architecture\" class=\"headerlink\" title=\"What is an Event-Driven Architecture?\"></a>What is an Event-Driven Architecture?</h2><p>Event-driven architectures establish an event that can be consumed and reacted to. But what is an event?</p>\n<p>An event is essentially any significant <strong>change</strong> from one state to another, such as the change from having no messages in your inbox to have a new message in your inbox. This state can be reacted to <strong>internally</strong> (such as when the email program in question realizes a new message has been received), <strong>externally</strong> (when a user sees a notification for a new message), or used to <strong>generate another event</strong> (for instance, the message tally increases by one).</p>\n<p>Event-driven architectures are appealing to API developers because they function very well in <strong>asynchronous</strong> environments. By crafting APIs that <strong>trigger</strong> certain functions on new event delivery, API systems don’t have to inherently wait for synchronous delivery or real time communication. This is hugely beneficial, as eliminating the need to constantly poll endpoints frees resources from otherwise wasteful purposes, reducing both general hardware requirements and call-specific overhead.</p>\n<p>For this reason, event-driven architectures are very, very popular, and lead to improved power, bandwidth, and co-processing than other solutions and architectures such as polling and other poll-centric derivatives.</p>\n<h2 id=\"5-Types-of-Event-Driven-Protocols-for-APIs\"><a href=\"#5-Types-of-Event-Driven-Protocols-for-APIs\" class=\"headerlink\" title=\"5 Types of Event-Driven Protocols for APIs\"></a>5 Types of Event-Driven Protocols for APIs</h2><h3 id=\"1-WebSockets\"><a href=\"#1-WebSockets\" class=\"headerlink\" title=\"1: WebSockets\"></a>1: WebSockets</h3><p><strong>WebSockets</strong> are an interesting event-driven solution, because, for most browsers, they’re actually baked into the application itself. Essentially, WebSocket is a protocol that provides full-duplex communication on a single TCP connection. It was standardized by the Internet Engineering Task Force as <a href=\"https://tools.ietf.org/html/rfc6455\" target=\"_blank\" rel=\"external\">RFC 6455</a>, and the WebSocket API in Web IDL was later standardized under the W3C banner.</p>\n<p>While the protocol itself is meant to be used between <strong>web browsers</strong> and <strong>servers</strong>, the protocol can be used in any case where there is a client-server relationship. The protocol itself is based upon TCP, with the additional HTTP interpretation statement that is considered an “Upgrade request” to allow for interoperability.</p>\n<h4 id=\"Pros\"><a href=\"#Pros\" class=\"headerlink\" title=\"Pros\"></a>Pros</h4><p>Because WebSocket is expressly designed for browser operation, it boasts extremely <strong>low overhead</strong> for what it actually does. By establishing a <strong>full-duplex</strong> conversation using a standardized methodology, connection both to and from the two entities can take place simultaneously, resulting in lower overhead and better throughput.</p>\n<p>Additionally, the fact that these communications take place over TCP 80/443 means that environments that traditionally block non-web based applications for security reasons can still handle this protocol, as firewalls allow communication to and from this port.</p>\n<p>Perhaps the strongest argument for the use of WebSockets are the fact that they are standardized and <strong>natively supported</strong> by all major browsers, ranging from Microsft Edge to Opera, from Firefox to Chrome. This means that any web application that ties into it will be interactable within the vast majority of both browser-based and browser-independent gateways and applications.</p>\n<h4 id=\"Cons\"><a href=\"#Cons\" class=\"headerlink\" title=\"Cons\"></a>Cons</h4><p>WebSockets have one distinct major failing — while it might have support for HTTP-like functionality, <strong>it is not HTTP</strong> whatsoever. This has implications, especially when considering optimizing in HTTP such as caching, proxying, etc., that haven’t quite become apparent.</p>\n<p>Because WebSockets are relatively new, having been only officially standardized in 2011, the industry is still understanding what the side effects mean. Most applications that use WebSockets are designed specifically for everything that a WebSocket is — what has yet to be seen, however, is whether or not this solution is better in the long-run than any stateless solution currently available.</p>\n<p>There is of course the fact that, as with other architectures on this list, WebSockets create an “always on” connection during the duration of data transfer. While this is fine for many uses such as media streaming and live stream calculations, it also essentially means that, for WebSockets, there is no scalability. Ports have hardcoded limitations and bandwidth, and thus in order to “scale”, you must add additional ports to match the maximum load. In stateless systems, this is less of an issue, as requests can wait and be made in such a way as to be independent on the state of the server itself.</p>\n<h3 id=\"2-WebHooks\"><a href=\"#2-WebHooks\" class=\"headerlink\" title=\"2: WebHooks\"></a>2: WebHooks</h3><p><strong>WebHooks</strong> are a similar concept to the WebSocket. They primarily function using <strong>custom callbacks</strong>, or code that is passed as an argument to another chunk of code and executed at a specified point in time. Essentially, a WebHook is a glorified system of “if this, then do”, allowing for users independent of the event firing to craft a custom response to that event within their own system.</p>\n<p>The term was coined by <a href=\"https://twitter.com/progrium\" target=\"_blank\" rel=\"external\">Jeff Lindsay</a> in 2007, and quickly became popular amongst users who wished to create automated responses to exterior behaviors. A great example of this would be a developer pushing a new item to GitHub, which causes an event. A user has a system tied into the URI of a WebHook. When the push is published, the user’s system utilizes the URI of the WebHook to integrate the push into a larger build, thereby creating a compiled component.</p>\n<h4 id=\"Pros-1\"><a href=\"#Pros-1\" class=\"headerlink\" title=\"Pros\"></a>Pros</h4><p>WebHooks function a lot like WebSockets, but they’re different in some key areas. First and foremost, WebSockets are primarily designed for browser-based communications, and while they can be used regardless in any client-server communication, they do not behave well in a <strong>server-to-server</strong> setup.</p>\n<p>WebHooks, on the other hand, work very well in server-to-server systems due to how they operate. Because the system essentially functions as the aforementioned “if this then do”, servers can be configured to tie into pre-formed URIs at any time and execute a given function whenever that event is triggered.</p>\n<p>Additionally, WebHooks have the unique benefit of being <strong>based upon HTTP</strong>, unlike WebSockets. This means that the system can be integrated without utilizing any new infrastructure, allowing speedy adoption and relatively simple setup.</p>\n<h4 id=\"Cons-1\"><a href=\"#Cons-1\" class=\"headerlink\" title=\"Cons\"></a>Cons</h4><p>The problem with WebHooks is that a lot of their functionality can already be placed on the arguably more powerful REST architectural approach. While adopting event-driven architecture is often a requirement of the service being built, it’s a hard sell when it can be mirrored in REST while also giving the wealth of options that REST gives to the user.</p>\n<p>These RESTful solutions such as <a href=\"http://www.restms.org/\" target=\"_blank\" rel=\"external\">RestMS</a> are essentially simply message querying services, though, and do require additional infrastructure, which may or may not be doable considering the purpose of the application.</p>\n<p>Additionally, WebHooks can be <strong>resource intensive</strong> to both the client and the server. If the client needs to notify many servers that an event has occurred, and a server needs to listen to a great deal of clients notifying of this change, you can very quickly run into a situation where your network grows uncontrollably. While HTTP does scale quite well, this is a definite negative to consider.</p>\n<p>However, there are also ways to build a <a href=\"https://en.wikipedia.org/wiki/Message_queuing_service\" target=\"_blank\" rel=\"external\">message queuing service</a> on top of HTTP—some RESTful examples include <a href=\"https://www.iron.io/platform/ironmq/\" target=\"_blank\" rel=\"external\">IronMQ</a> and RestMS.</p>\n<h3 id=\"3-REST-Hooks\"><a href=\"#3-REST-Hooks\" class=\"headerlink\" title=\"3: REST Hooks\"></a>3: REST Hooks</h3><p>Speaking of RESTful examples, <strong>REST Hooks</strong> is essentially “hooking” baked into REST itself. Defined as an initiative from <a href=\"http://resthooks.org/docs/\" target=\"_blank\" rel=\"external\">Zapier</a>, this is a subject <a href=\"http://nordicapis.com/stop-polling-and-consider-using-rest-hooks/\" target=\"_blank\" rel=\"external\">we’ve covered before</a> — hooks are collated to a single target URL as a subscription, which pings the resource requester when a change is noted.</p>\n<p>This approach is a response to the practice of <strong>polling</strong>, in which a client constantly checks for changes to a resource. Under the REST Hooks paradigm, the client instead waits for a change, and reacts to it. To put it simply, this is a WebHook in REST.</p>\n<h4 id=\"Pros-2\"><a href=\"#Pros-2\" class=\"headerlink\" title=\"Pros\"></a>Pros</h4><p>REST Hooks are obviously super powerful in the correct context — being able to passively receive a resource rather than dedicating processing power to constant polling frees up a lot of the client-side cost.</p>\n<p>Perhaps the strongest argument for REST Hooks though, is the fact that it’s <strong>so easy</strong> and <strong>intuitive</strong> to use. While WebHooks utilize HTTP and thus do not need new architecture to set up, they are also limited by the fact that they are built upon HTTP, and can thus be somewhat complex to set up properly and use effectively.</p>\n<p>REST Hooks, though, are <strong>subscription based</strong>, and as such, are simply usable by subscribing. This makes it a very easy to use solution while providing a lot of the usability and effectiveness of more complex systems.</p>\n<h4 id=\"Cons-2\"><a href=\"#Cons-2\" class=\"headerlink\" title=\"Cons\"></a>Cons</h4><p>Of course, every solution has its negatives, and REST Hooks are no different. It could be viewed that REST Hooks actually fly in the face of what REST is — <a href=\"http://nordicapis.com/defining-stateful-vs-stateless-web-services/\" target=\"_blank\" rel=\"external\">session free and stateless</a>. REST Hooks essentially create consistent polling, it’s just moved the polling from one side to another.</p>\n<p>Then, there’s the arguable problem that REST Hooks might be doing something that has already been solved. Some would argue that TCP already does most of what REST Hooks is trying to do, and simply layering more solutions on top of HTTP to get what TCP already does is a poor approach.</p>\n<h3 id=\"4-Pub-Sub\"><a href=\"#4-Pub-Sub\" class=\"headerlink\" title=\"4: Pub-Sub\"></a>4: Pub-Sub</h3><p><strong>Pub-Sub</strong> is a slightly different approach. Referred to by its full name as <strong>publish-subscribe</strong>, the concept is where events are published to a class without knowledge of the client subscribing to the class. Basically, a user will join one or more classes, and then will receive event updates without regard or knowledge to the event publisher.</p>\n<p>The main difference here is one of conscious choice of provider — in the other solutions noted herein, a user consciously communicates with a given server or provider and receives events as pre-determined. Under the Pub-Sub scheme, the user only specifies which class they wish to be part of and what events they are interested in receiving. From there, they receive these events when one is pushed out.</p>\n<p>A way this is often framed in internet discussions is in the frame of a <strong>radio channel</strong>. Record companies, or publishers, issue audio to the station, which then broadcasts this audio to listeners, or subscribers. Pub-sub is the middleman radio station here — listeners don’t know who gave the station the music, nor do the companies know who the listeners are. It is this segmentation that is baked into the pattern.</p>\n<p>When we talk about Pub-Sub, we need to keep in mind that we’re actually talking about two different things. Pub-Sub can mean the methodology and general concept in programming terms, but it can also mean specific provider solutions based upon that methodology. For instance, Google’s <a href=\"https://cloud.google.com/pubsub/docs/overview\" target=\"_blank\" rel=\"external\">Cloud Pub/Sub</a> is an implementation of the general methodology within their cloud service, and allows for asynchronous many-to-many pub-sub relationships as stated above.</p>\n<h4 id=\"Pros-3\"><a href=\"#Pros-3\" class=\"headerlink\" title=\"Pros\"></a>Pros</h4><p>A huge benefit of Pub-Sub is the fact that it’s <strong>loosely coupled</strong>, and thus is extremely scalable and flexible. The only thing the event-provider is doing is generating the content — each other step is done through a separated middleman, and so the content is easily scaled and modulated to the architecture and design of the solution.</p>\n<p>Additionally, Pub-Sub lends itself very well to <strong>testing</strong>. A subscriber is narrowly limited to a set of events that they have requested under a class, so if a failure occurs, this natural segmentation informs the provider as to where the fault is, and which class of users is experiencing the fault.</p>\n<h4 id=\"Cons-3\"><a href=\"#Cons-3\" class=\"headerlink\" title=\"Cons\"></a>Cons</h4><p>Unfortunately, decoupling is also a huge disadvantage for this pattern. By being a <strong>middleman</strong>, Pub-Sub cannot effectively notify the provider that a message has been sent, and the listener is separated from the event and thus may not know if a message wasn’t sent that should have been. Harkening back to the radio explanation, a listener will never know if a song was meant to play on a channel or if the channel is out of range, and once the record executives hand off the music, they’ve got no idea if the user received the songs without direct feedback from them.</p>\n<p>Additionally, while the system is extensible and flexible, instability does occur with high traffic load as subclass after subclass might be constructed to handle further segmentation. This of course leads to the aforementioned instability in addition to increased complexity.</p>\n<p>You must keep in mind that while the relationship between the publisher and subscriber in this model may be beneficial, it also comes with its own difficulties when these relationships need to be modulated. While you can certainly work around this, at this point, you’re fighting the very basis of the pattern, rather than any secondary natures — you’re trying to make dehydrated water, and fighting against the nature of a pattern suggests the pattern to be inherently poor.</p>\n<blockquote>\n<p>Also read: <a href=\"http://nordicapis.com/building-a-backend-for-frontend-shim-for-your-microservices/\" target=\"_blank\" rel=\"external\">Building a Backend for Frontend (BFF) For Your Microservices</a></p>\n</blockquote>\n<h3 id=\"5-Server-Sent-Events\"><a href=\"#5-Server-Sent-Events\" class=\"headerlink\" title=\"5: Server Sent Events\"></a>5: Server Sent Events</h3><p><strong>Server Sent Events</strong>, or SSE, is a communication protocol much like WebSockets, but with the implication of <strong>unidirectional data</strong>. In this architecture, the server is consistently sending updates to the client as an automatic process. This was standardized under HTML5 by the <a href=\"https://www.w3.org/TR/2009/WD-eventsource-20091029/\" target=\"_blank\" rel=\"external\">W3C</a>, and is thus compatible with any solution that is likewise compatible with HTML5.</p>\n<blockquote>\n<p>Of note is that there is a competing standardization from the <a href=\"https://whatwg.org/\" target=\"_blank\" rel=\"external\">Web Hypertext Application Technology Working Group</a> – this is a relic from movement away from “HTML5” and into what WHATWG is calling “HTML Living Standard”. The general working consensus is that, WHATWG’s standardization is prioritized in the rare cases of divergent standards. This could become more of an issue as time marches forward, given that WHATWG was created due to a perceived lack of interest from W3C towards evolving HTML, but for the time being, either standard is generally acceptable.<br>While simple in theory, Server Sent Events are anything but simple when considering benefits and drawbacks.</p>\n</blockquote>\n<h4 id=\"Pros-4\"><a href=\"#Pros-4\" class=\"headerlink\" title=\"Pros\"></a>Pros</h4><p>SSE is <strong>not bidirectional</strong> in its communications — the server is issuing the events in a steady, predictable method. This is hugely beneficial to applications which do not need the two-way communications baked into WebSockets or other such solutions, as this means <strong>lower bandwidth</strong>, and an allowance for the connection to be temporary rather than always-on during the duration of data transfer. By its nature, the data is being transferred one way, and thus there is no need to wait for data to be returned.</p>\n<p>Additionally, at least in theory, SSE is easier to set up in complex situations. You only have to worry about data traveling one direction via one system, thus reducing complexity dramatically. There is no need to define a message exchange protocol, no need to specify data duration or wait times, no need to support bilateral messaging — the single direction saves a lot of complexity.</p>\n<h4 id=\"Cons-4\"><a href=\"#Cons-4\" class=\"headerlink\" title=\"Cons\"></a>Cons</h4><p>That simplicity could be where SSE fails for particular use cases. SSE is a very poor solution for situations that require <strong>bidirectional communication</strong>, and while this seems obvious, it would surprise many developers to see how many systems actually depend on bidirectional communication for simple functionality.</p>\n<p>While much of this can be fixed with workarounds, a developer’s goal in choosing an event-driven protocol should be to find one that works out of the box, not to find a solution that might work if configured properly and given secondary systems upon which to depend.</p>\n<p>There is also the issue of <strong>security</strong> and authentication. While two-way systems can easily use authentication methodologies, SSE handles this using <strong>header forwarding</strong>. While headers can be manipulated and overridden in many languages and applications, the EventSource object in JavaScript does not natively support this, which would cause many adoptees some major headaches.</p>\n<p>Finally, there is a concern over loss of efficiency with <strong>over transmitting</strong> data. A two-direction system can determine when a client or server disconnects, but SSE can only determine that a client has disconnected after attempting a full data transmission and receiving a noted failure. Because of this, data can be lost rather quickly, and with many failed connections, this loss can mount dramatically over time.</p>\n<h2 id=\"Conclusion\"><a href=\"#Conclusion\" class=\"headerlink\" title=\"Conclusion\"></a>Conclusion</h2><p>There is no one event-driven solution that works in every use case. While many would argue that event-driven solutions should be REST based, which suggests REST Hooks as the answer, many others would argue that it is entirely situational, and that REST is not always the silver bullet it’s touted to be.</p>\n<p>If you are building for scalability with low overhead in a browser environment, <strong>WebSockets</strong> are a great solution. Conversely, if you’d like those same benefits but are working in a non-browser system, then <strong>WebHooks</strong> should be your approach. <strong>REST Hooks</strong> are not only great for RESTful services, they’re also much easier to set up than either, and thus are great in low-time high-rush situations. <strong>Pub-Sub</strong> can be great if you need to enforce a division between client and server, and this can further be established and controlled in an even stronger way with <strong>Server Sent</strong>.</p>\n<p>Simply put, the best solution will be the one that fits your specific situation and build — any of these solutions, given the correct system, is a great solution. To that end, each solution has a very specific use case.</p>\n<h2 id=\"TLDR-Comparison-Table\"><a href=\"#TLDR-Comparison-Table\" class=\"headerlink\" title=\"TLDR Comparison Table\"></a>TLDR Comparison Table</h2><table>\n<thead>\n<tr>\n<th>PROTOCOL</th>\n<th>RELATED TO</th>\n<th>STANDARD BODY</th>\n<th>NOTES</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>WebSockets</td>\n<td>TCP, HTTP-like</td>\n<td>IETF, W3C</td>\n<td>Two-way communication over TCP<br>Designed for web browsers &amp; web servers<br>Good for lower overhead scenarios<br>Supported in all major browsers</td>\n</tr>\n<tr>\n<td>Webhooks</td>\n<td>URI, HTTP</td>\n<td>-</td>\n<td>User defined “HTTP callbacks”<br>Triggered by an event HTTP<br>Requests are made to Webhook URI<br>Enables real-time event triggering</td>\n</tr>\n<tr>\n<td>REST Hooks</td>\n<td>HTTP</td>\n<td>Zapier</td>\n<td>Lightweight subscription layer<br>Manipulated by a REST API<br>Essentially a WebHook in REST</td>\n</tr>\n<tr>\n<td>Pub-Sub</td>\n<td>-</td>\n<td>-</td>\n<td>Client subscribes to classes<br>Bidirectional<br>Middleman layer between client and server<br>Loose coupling</td>\n</tr>\n<tr>\n<td>Server Sent</td>\n<td>HTTP, HTML5 , DOM</td>\n<td>WHATWG, W3C</td>\n<td>Server constantly sends updates to the client<br>Unidirectional push notifications as DOM events</td>\n</tr>\n</tbody>\n</table>\n"},{"title":"大前端周刊 第一期 （本期小编：王祥）","date":"2017-06-23T03:18:25.000Z","_content":"\n## 基础\n\n* [Promise](http://es6.ruanyifeng.com/#docs/promise)\n在Javascript的单线程异步架构下，Promise会是很多异步服务的核心知识点，Node 8.X已经可以方便的将回调方式转换为Promise。\n\n* [异步函数async](http://es6.ruanyifeng.com/#docs/async)\n使用异步函数可以实现“用同步的写法，完成异步的事情”，Node 8.X已经在编译器层面对async做了优化。\n* [语义化版本 2.0.0](http://semver.org/lang/zh-CN/)\n玩开源项目的基础，组件发布的约定。\n* [package.json规则](https://docs.npmjs.com/files/package.json)\n项目的依赖列表，区别开发环境、生产环境、面向的平台和组件的规范（CMD、AMD和UMD）等。\n\n## 单元测试工具\nWeb 应用中的单元测试更加重要，在 Web 产品快速迭代的时期，每个测试用例都给应用的稳定性提供了一层保障。 API 升级，测试用例可以很好地检查代码是否向下兼容。 对于各种可能的输入，一旦测试覆盖，都能明确它的输出。 代码改动后，可以通过测试结果判断代码的改动是否影响已确定的结果。\n\n* [mocha单元测试](https://mochajs.org/)\nNPM里每天有25W的下载量，同时支持Node、浏览器多平台的测试用例的执行。\n\n* [power-assert断言库](https://www.npmjs.com/package/power-assert)\npower-assert可以零学习成本，直观的展示出判断条件和结果。\n\n```\n1) Array #indexOf() should return index when the value is present:\n     AssertionError: # path/to/test/mocha_node.js:10\n\n  assert(ary.indexOf(zero) === two)\n         |   |       |     |   |\n         |   |       |     |   2\n         |   -1      0     false\n         [1,2,3]\n\n  [number] two\n  => 2\n  [number] ary.indexOf(zero)\n  => -1\n```\n\n## 文章\n\n* [JavaScript专题之跟着underscore学防抖](https://github.com/mqyqingfeng/Blog/issues/22)\n对防抖的原理介绍的很清晰，从最简单的实现版本一步一步讲解到实现复杂的版本。\n让我对防抖有了重新的认识。\n\n* [从前端开发看面向未来的敏捷学习法](http://www.jianshu.com/p/fd7055705c62)\n授人以鱼不如授人以渔\n前端技术更新速度很快，快速学习已经成了每个工程师必备技能。\n除了掌握技术知识，解决问题的能力在实际项目中也很重要，文中以实际案例给出分解思路和系统敏捷学习新知识思路。\n\n* [前端工程师做事的三重境界：我的进阶之路](https://zhuanlan.zhihu.com/p/26660510)\n从程序员到工程师的进阶之路，精益求精才能称得上是工程师。作者认为这三个单词（Programmer、Developer、Enginner）对应不用的境界。\n\n* [浏览器缓存机制剖析](http://louiszhai.github.io/2017/04/07/http-cache/)\n正如文中所述“缓存一直是前端优化的主战场, 利用好缓存就成功了一半”，利用好缓存在前端优化地位中举足轻重，本文能够带领大家对浏览器缓存机制有一个初步了解。\n\n* [vue-mixins使用注意事项和高级用法](https://www.deboy.cn/Vue-mixins-advance-tips.html)\n在项目开发中经常会碰到两个组件的业务逻辑有所相似，可能共享相同的底层业务逻辑；此时需要考虑如何来合理地划分代码，即避免冗余代码，也不能过度抽象。\n\n* [也谈JavaScript数组去重](https://www.toobug.net/article/array_unique_in_javascript.html)\n去重，首先要思考什么是相等，从最初的循环，到Set集合。\n\n* [大前端公共知识梳理：这些知识你都掌握了吗？](https://mp.weixin.qq.com/s?__biz=MzIwNjQwMzUwMQ==&mid=2247485277&idx=1&sn=82703e13febb1e7947cc18d1f57fc375&key=6b0fbfcb936d93fa91a745202d0f37bffff65fd2cba5ff2cfa25618c8d03951944ae6eb2f4db18aaf1c8893ddaeffb404684dbd7f6159925dbab9411094f960daba3c6f46c1f93d34f9a6d476104fc63&ascene=0&uin=MTQwNzQzODYwMA%3D%3D&version=12020810&nettype=WIFI&fontScale=100&pass_ticket=xJ0pJsFuIsM3Ce35cuVqghSLUWaqU91w%2FEgBgn2%2BhouemlzbFvOIXP3KmJlioe0D)\n文章覆盖非常全面，所介绍基础知识、技术栈、能力、领域有很多都是目前我所欠缺的，介于此推荐给大家。。。看完最直观的感受就是自己是个假前端\n\n* [重温ES6核心概念和基本用法](https://segmentfault.com/a/1190000009885614)\n文章梳理了ES6核心概念及基础用法，推荐给大家。\n","source":"_posts/weekly-1.md","raw":"---\ntitle: 大前端周刊 第一期 （本期小编：王祥）\ndate: 2017-06-23 11:18:25\ntags: [weekly,全栈,Node]\n---\n\n## 基础\n\n* [Promise](http://es6.ruanyifeng.com/#docs/promise)\n在Javascript的单线程异步架构下，Promise会是很多异步服务的核心知识点，Node 8.X已经可以方便的将回调方式转换为Promise。\n\n* [异步函数async](http://es6.ruanyifeng.com/#docs/async)\n使用异步函数可以实现“用同步的写法，完成异步的事情”，Node 8.X已经在编译器层面对async做了优化。\n* [语义化版本 2.0.0](http://semver.org/lang/zh-CN/)\n玩开源项目的基础，组件发布的约定。\n* [package.json规则](https://docs.npmjs.com/files/package.json)\n项目的依赖列表，区别开发环境、生产环境、面向的平台和组件的规范（CMD、AMD和UMD）等。\n\n## 单元测试工具\nWeb 应用中的单元测试更加重要，在 Web 产品快速迭代的时期，每个测试用例都给应用的稳定性提供了一层保障。 API 升级，测试用例可以很好地检查代码是否向下兼容。 对于各种可能的输入，一旦测试覆盖，都能明确它的输出。 代码改动后，可以通过测试结果判断代码的改动是否影响已确定的结果。\n\n* [mocha单元测试](https://mochajs.org/)\nNPM里每天有25W的下载量，同时支持Node、浏览器多平台的测试用例的执行。\n\n* [power-assert断言库](https://www.npmjs.com/package/power-assert)\npower-assert可以零学习成本，直观的展示出判断条件和结果。\n\n```\n1) Array #indexOf() should return index when the value is present:\n     AssertionError: # path/to/test/mocha_node.js:10\n\n  assert(ary.indexOf(zero) === two)\n         |   |       |     |   |\n         |   |       |     |   2\n         |   -1      0     false\n         [1,2,3]\n\n  [number] two\n  => 2\n  [number] ary.indexOf(zero)\n  => -1\n```\n\n## 文章\n\n* [JavaScript专题之跟着underscore学防抖](https://github.com/mqyqingfeng/Blog/issues/22)\n对防抖的原理介绍的很清晰，从最简单的实现版本一步一步讲解到实现复杂的版本。\n让我对防抖有了重新的认识。\n\n* [从前端开发看面向未来的敏捷学习法](http://www.jianshu.com/p/fd7055705c62)\n授人以鱼不如授人以渔\n前端技术更新速度很快，快速学习已经成了每个工程师必备技能。\n除了掌握技术知识，解决问题的能力在实际项目中也很重要，文中以实际案例给出分解思路和系统敏捷学习新知识思路。\n\n* [前端工程师做事的三重境界：我的进阶之路](https://zhuanlan.zhihu.com/p/26660510)\n从程序员到工程师的进阶之路，精益求精才能称得上是工程师。作者认为这三个单词（Programmer、Developer、Enginner）对应不用的境界。\n\n* [浏览器缓存机制剖析](http://louiszhai.github.io/2017/04/07/http-cache/)\n正如文中所述“缓存一直是前端优化的主战场, 利用好缓存就成功了一半”，利用好缓存在前端优化地位中举足轻重，本文能够带领大家对浏览器缓存机制有一个初步了解。\n\n* [vue-mixins使用注意事项和高级用法](https://www.deboy.cn/Vue-mixins-advance-tips.html)\n在项目开发中经常会碰到两个组件的业务逻辑有所相似，可能共享相同的底层业务逻辑；此时需要考虑如何来合理地划分代码，即避免冗余代码，也不能过度抽象。\n\n* [也谈JavaScript数组去重](https://www.toobug.net/article/array_unique_in_javascript.html)\n去重，首先要思考什么是相等，从最初的循环，到Set集合。\n\n* [大前端公共知识梳理：这些知识你都掌握了吗？](https://mp.weixin.qq.com/s?__biz=MzIwNjQwMzUwMQ==&mid=2247485277&idx=1&sn=82703e13febb1e7947cc18d1f57fc375&key=6b0fbfcb936d93fa91a745202d0f37bffff65fd2cba5ff2cfa25618c8d03951944ae6eb2f4db18aaf1c8893ddaeffb404684dbd7f6159925dbab9411094f960daba3c6f46c1f93d34f9a6d476104fc63&ascene=0&uin=MTQwNzQzODYwMA%3D%3D&version=12020810&nettype=WIFI&fontScale=100&pass_ticket=xJ0pJsFuIsM3Ce35cuVqghSLUWaqU91w%2FEgBgn2%2BhouemlzbFvOIXP3KmJlioe0D)\n文章覆盖非常全面，所介绍基础知识、技术栈、能力、领域有很多都是目前我所欠缺的，介于此推荐给大家。。。看完最直观的感受就是自己是个假前端\n\n* [重温ES6核心概念和基本用法](https://segmentfault.com/a/1190000009885614)\n文章梳理了ES6核心概念及基础用法，推荐给大家。\n","slug":"weekly-1","published":1,"updated":"2017-06-23T09:01:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5db41ip000781tx6mi78k8u","content":"<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><ul>\n<li><p><a href=\"http://es6.ruanyifeng.com/#docs/promise\" target=\"_blank\" rel=\"external\">Promise</a><br>在Javascript的单线程异步架构下，Promise会是很多异步服务的核心知识点，Node 8.X已经可以方便的将回调方式转换为Promise。</p>\n</li>\n<li><p><a href=\"http://es6.ruanyifeng.com/#docs/async\" target=\"_blank\" rel=\"external\">异步函数async</a><br>使用异步函数可以实现“用同步的写法，完成异步的事情”，Node 8.X已经在编译器层面对async做了优化。</p>\n</li>\n<li><a href=\"http://semver.org/lang/zh-CN/\" target=\"_blank\" rel=\"external\">语义化版本 2.0.0</a><br>玩开源项目的基础，组件发布的约定。</li>\n<li><a href=\"https://docs.npmjs.com/files/package.json\" target=\"_blank\" rel=\"external\">package.json规则</a><br>项目的依赖列表，区别开发环境、生产环境、面向的平台和组件的规范（CMD、AMD和UMD）等。</li>\n</ul>\n<h2 id=\"单元测试工具\"><a href=\"#单元测试工具\" class=\"headerlink\" title=\"单元测试工具\"></a>单元测试工具</h2><p>Web 应用中的单元测试更加重要，在 Web 产品快速迭代的时期，每个测试用例都给应用的稳定性提供了一层保障。 API 升级，测试用例可以很好地检查代码是否向下兼容。 对于各种可能的输入，一旦测试覆盖，都能明确它的输出。 代码改动后，可以通过测试结果判断代码的改动是否影响已确定的结果。</p>\n<ul>\n<li><p><a href=\"https://mochajs.org/\" target=\"_blank\" rel=\"external\">mocha单元测试</a><br>NPM里每天有25W的下载量，同时支持Node、浏览器多平台的测试用例的执行。</p>\n</li>\n<li><p><a href=\"https://www.npmjs.com/package/power-assert\" target=\"_blank\" rel=\"external\">power-assert断言库</a><br>power-assert可以零学习成本，直观的展示出判断条件和结果。</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">1) Array #indexOf() should return index when the value is present:</div><div class=\"line\">     AssertionError: # path/to/test/mocha_node.js:10</div><div class=\"line\"></div><div class=\"line\">  assert(ary.indexOf(zero) === two)</div><div class=\"line\">         |   |       |     |   |</div><div class=\"line\">         |   |       |     |   2</div><div class=\"line\">         |   -1      0     false</div><div class=\"line\">         [1,2,3]</div><div class=\"line\"></div><div class=\"line\">  [number] two</div><div class=\"line\">  =&gt; 2</div><div class=\"line\">  [number] ary.indexOf(zero)</div><div class=\"line\">  =&gt; -1</div></pre></td></tr></table></figure>\n<h2 id=\"文章\"><a href=\"#文章\" class=\"headerlink\" title=\"文章\"></a>文章</h2><ul>\n<li><p><a href=\"https://github.com/mqyqingfeng/Blog/issues/22\" target=\"_blank\" rel=\"external\">JavaScript专题之跟着underscore学防抖</a><br>对防抖的原理介绍的很清晰，从最简单的实现版本一步一步讲解到实现复杂的版本。<br>让我对防抖有了重新的认识。</p>\n</li>\n<li><p><a href=\"http://www.jianshu.com/p/fd7055705c62\" target=\"_blank\" rel=\"external\">从前端开发看面向未来的敏捷学习法</a><br>授人以鱼不如授人以渔<br>前端技术更新速度很快，快速学习已经成了每个工程师必备技能。<br>除了掌握技术知识，解决问题的能力在实际项目中也很重要，文中以实际案例给出分解思路和系统敏捷学习新知识思路。</p>\n</li>\n<li><p><a href=\"https://zhuanlan.zhihu.com/p/26660510\" target=\"_blank\" rel=\"external\">前端工程师做事的三重境界：我的进阶之路</a><br>从程序员到工程师的进阶之路，精益求精才能称得上是工程师。作者认为这三个单词（Programmer、Developer、Enginner）对应不用的境界。</p>\n</li>\n<li><p><a href=\"http://louiszhai.github.io/2017/04/07/http-cache/\" target=\"_blank\" rel=\"external\">浏览器缓存机制剖析</a><br>正如文中所述“缓存一直是前端优化的主战场, 利用好缓存就成功了一半”，利用好缓存在前端优化地位中举足轻重，本文能够带领大家对浏览器缓存机制有一个初步了解。</p>\n</li>\n<li><p><a href=\"https://www.deboy.cn/Vue-mixins-advance-tips.html\" target=\"_blank\" rel=\"external\">vue-mixins使用注意事项和高级用法</a><br>在项目开发中经常会碰到两个组件的业务逻辑有所相似，可能共享相同的底层业务逻辑；此时需要考虑如何来合理地划分代码，即避免冗余代码，也不能过度抽象。</p>\n</li>\n<li><p><a href=\"https://www.toobug.net/article/array_unique_in_javascript.html\" target=\"_blank\" rel=\"external\">也谈JavaScript数组去重</a><br>去重，首先要思考什么是相等，从最初的循环，到Set集合。</p>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzIwNjQwMzUwMQ==&amp;mid=2247485277&amp;idx=1&amp;sn=82703e13febb1e7947cc18d1f57fc375&amp;key=6b0fbfcb936d93fa91a745202d0f37bffff65fd2cba5ff2cfa25618c8d03951944ae6eb2f4db18aaf1c8893ddaeffb404684dbd7f6159925dbab9411094f960daba3c6f46c1f93d34f9a6d476104fc63&amp;ascene=0&amp;uin=MTQwNzQzODYwMA%3D%3D&amp;version=12020810&amp;nettype=WIFI&amp;fontScale=100&amp;pass_ticket=xJ0pJsFuIsM3Ce35cuVqghSLUWaqU91w%2FEgBgn2%2BhouemlzbFvOIXP3KmJlioe0D\" target=\"_blank\" rel=\"external\">大前端公共知识梳理：这些知识你都掌握了吗？</a><br>文章覆盖非常全面，所介绍基础知识、技术栈、能力、领域有很多都是目前我所欠缺的，介于此推荐给大家。。。看完最直观的感受就是自己是个假前端</p>\n</li>\n<li><p><a href=\"https://segmentfault.com/a/1190000009885614\" target=\"_blank\" rel=\"external\">重温ES6核心概念和基本用法</a><br>文章梳理了ES6核心概念及基础用法，推荐给大家。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><ul>\n<li><p><a href=\"http://es6.ruanyifeng.com/#docs/promise\" target=\"_blank\" rel=\"external\">Promise</a><br>在Javascript的单线程异步架构下，Promise会是很多异步服务的核心知识点，Node 8.X已经可以方便的将回调方式转换为Promise。</p>\n</li>\n<li><p><a href=\"http://es6.ruanyifeng.com/#docs/async\" target=\"_blank\" rel=\"external\">异步函数async</a><br>使用异步函数可以实现“用同步的写法，完成异步的事情”，Node 8.X已经在编译器层面对async做了优化。</p>\n</li>\n<li><a href=\"http://semver.org/lang/zh-CN/\" target=\"_blank\" rel=\"external\">语义化版本 2.0.0</a><br>玩开源项目的基础，组件发布的约定。</li>\n<li><a href=\"https://docs.npmjs.com/files/package.json\" target=\"_blank\" rel=\"external\">package.json规则</a><br>项目的依赖列表，区别开发环境、生产环境、面向的平台和组件的规范（CMD、AMD和UMD）等。</li>\n</ul>\n<h2 id=\"单元测试工具\"><a href=\"#单元测试工具\" class=\"headerlink\" title=\"单元测试工具\"></a>单元测试工具</h2><p>Web 应用中的单元测试更加重要，在 Web 产品快速迭代的时期，每个测试用例都给应用的稳定性提供了一层保障。 API 升级，测试用例可以很好地检查代码是否向下兼容。 对于各种可能的输入，一旦测试覆盖，都能明确它的输出。 代码改动后，可以通过测试结果判断代码的改动是否影响已确定的结果。</p>\n<ul>\n<li><p><a href=\"https://mochajs.org/\" target=\"_blank\" rel=\"external\">mocha单元测试</a><br>NPM里每天有25W的下载量，同时支持Node、浏览器多平台的测试用例的执行。</p>\n</li>\n<li><p><a href=\"https://www.npmjs.com/package/power-assert\" target=\"_blank\" rel=\"external\">power-assert断言库</a><br>power-assert可以零学习成本，直观的展示出判断条件和结果。</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">1) Array #indexOf() should return index when the value is present:</div><div class=\"line\">     AssertionError: # path/to/test/mocha_node.js:10</div><div class=\"line\"></div><div class=\"line\">  assert(ary.indexOf(zero) === two)</div><div class=\"line\">         |   |       |     |   |</div><div class=\"line\">         |   |       |     |   2</div><div class=\"line\">         |   -1      0     false</div><div class=\"line\">         [1,2,3]</div><div class=\"line\"></div><div class=\"line\">  [number] two</div><div class=\"line\">  =&gt; 2</div><div class=\"line\">  [number] ary.indexOf(zero)</div><div class=\"line\">  =&gt; -1</div></pre></td></tr></table></figure>\n<h2 id=\"文章\"><a href=\"#文章\" class=\"headerlink\" title=\"文章\"></a>文章</h2><ul>\n<li><p><a href=\"https://github.com/mqyqingfeng/Blog/issues/22\" target=\"_blank\" rel=\"external\">JavaScript专题之跟着underscore学防抖</a><br>对防抖的原理介绍的很清晰，从最简单的实现版本一步一步讲解到实现复杂的版本。<br>让我对防抖有了重新的认识。</p>\n</li>\n<li><p><a href=\"http://www.jianshu.com/p/fd7055705c62\" target=\"_blank\" rel=\"external\">从前端开发看面向未来的敏捷学习法</a><br>授人以鱼不如授人以渔<br>前端技术更新速度很快，快速学习已经成了每个工程师必备技能。<br>除了掌握技术知识，解决问题的能力在实际项目中也很重要，文中以实际案例给出分解思路和系统敏捷学习新知识思路。</p>\n</li>\n<li><p><a href=\"https://zhuanlan.zhihu.com/p/26660510\" target=\"_blank\" rel=\"external\">前端工程师做事的三重境界：我的进阶之路</a><br>从程序员到工程师的进阶之路，精益求精才能称得上是工程师。作者认为这三个单词（Programmer、Developer、Enginner）对应不用的境界。</p>\n</li>\n<li><p><a href=\"http://louiszhai.github.io/2017/04/07/http-cache/\" target=\"_blank\" rel=\"external\">浏览器缓存机制剖析</a><br>正如文中所述“缓存一直是前端优化的主战场, 利用好缓存就成功了一半”，利用好缓存在前端优化地位中举足轻重，本文能够带领大家对浏览器缓存机制有一个初步了解。</p>\n</li>\n<li><p><a href=\"https://www.deboy.cn/Vue-mixins-advance-tips.html\" target=\"_blank\" rel=\"external\">vue-mixins使用注意事项和高级用法</a><br>在项目开发中经常会碰到两个组件的业务逻辑有所相似，可能共享相同的底层业务逻辑；此时需要考虑如何来合理地划分代码，即避免冗余代码，也不能过度抽象。</p>\n</li>\n<li><p><a href=\"https://www.toobug.net/article/array_unique_in_javascript.html\" target=\"_blank\" rel=\"external\">也谈JavaScript数组去重</a><br>去重，首先要思考什么是相等，从最初的循环，到Set集合。</p>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzIwNjQwMzUwMQ==&amp;mid=2247485277&amp;idx=1&amp;sn=82703e13febb1e7947cc18d1f57fc375&amp;key=6b0fbfcb936d93fa91a745202d0f37bffff65fd2cba5ff2cfa25618c8d03951944ae6eb2f4db18aaf1c8893ddaeffb404684dbd7f6159925dbab9411094f960daba3c6f46c1f93d34f9a6d476104fc63&amp;ascene=0&amp;uin=MTQwNzQzODYwMA%3D%3D&amp;version=12020810&amp;nettype=WIFI&amp;fontScale=100&amp;pass_ticket=xJ0pJsFuIsM3Ce35cuVqghSLUWaqU91w%2FEgBgn2%2BhouemlzbFvOIXP3KmJlioe0D\" target=\"_blank\" rel=\"external\">大前端公共知识梳理：这些知识你都掌握了吗？</a><br>文章覆盖非常全面，所介绍基础知识、技术栈、能力、领域有很多都是目前我所欠缺的，介于此推荐给大家。。。看完最直观的感受就是自己是个假前端</p>\n</li>\n<li><p><a href=\"https://segmentfault.com/a/1190000009885614\" target=\"_blank\" rel=\"external\">重温ES6核心概念和基本用法</a><br>文章梳理了ES6核心概念及基础用法，推荐给大家。</p>\n</li>\n</ul>\n"},{"title":"大前端周刊 第二期 （本期小编：胡国伟）","date":"2017-06-30T03:18:25.000Z","_content":"\n## 基础\n* [Class 的基本语法](http://es6.ruanyifeng.com/#docs/class)\n尽管基本上，`ES6`的`class`可以看作只是一个语法糖，但使得`JavaScript`对象原型的写法更加清晰、更像面向对象编程的语法，更接近传统语言的写法。\n\n* [Module 的语法](http://es6.ruanyifeng.com/#docs/module)\n相交于社区提供了各种模块化解决方案，`ES6`语言标准的层面上实现了模块功能，成为浏览器和服务器通用的模块解决方案。\n\n* [数组的扩展](http://es6.ruanyifeng.com/#docs/array)\n`ES6`内置新数组方法，无需再自己再实现相应的`polyfill`了，赶紧学习充能，搭配[该文（*【深度长文】JavaScript数组所有API全解密*）](http://louiszhai.github.io/2017/04/28/array/)食用，更易消化。\n\n* [webpack 中文](https://webpack-china.org/)\n旧版的`webpack`官方文档有些糟糕，幸好后来有了新版，并且还有志愿者维护了相对应的中文版本，这下查阅学习就更轻松了。近日`webpack 3.0` 已经释出，大家赶快跟进。\n\n* [EditorConfig使用介绍](https://segmentfault.com/a/1190000007599845)\n团队合作，统一编辑器行为非常必要，本文对`EditorConfig`中的配置进行了讲解。\nps：[EditorConfig](http://editorconfig.org/)规范在这里。\n\n## 文章\n\n*   1. [Server-Sent Events 教程](http://www.ruanyifeng.com/blog/2017/05/server-sent_events.html)\n    2. [WebSocket 教程](http://www.ruanyifeng.com/blog/2017/05/websocket.html) <br/>\n这两篇文章一起读，就可以很全面的了解现代浏览器和服务器通信技术。\n\n* [深入理解 JavaScript 异步](https://github.com/wangfupeng1988/js-async-tutorial)\n这个系列文章把异步方面的知识以及原理讲解的比较清楚，从传统的方式到`promise`到`generator`到`async`，值得一读。\n\n* [koa2从起步到填坑](http://www.jianshu.com/p/6b816c609669)\n比较系统简介`koa2`使用，包含一些例子，可以让人更快上手。\n\n* [现代前端科技解析 —— 数据响应式系统](https://www.404forest.com/2017/06/28/modern-web-development-tech-analysis-data-reactivity-system/)\n文章讲解数据响应式系统及其构建，分步骤实现了`vue2.0`的响应式，还有详细的代码示例及注释。\n\n* [关于前端开发谈谈单元测试](https://segmentfault.com/a/1190000000317146)\n阐述了做单元测试的必要性，\n着重介绍了`Jasmine`的常用语法，\n并对其他流行测试框架和工具做了介绍。\n\n* [Three.js入门指南](http://www.ituring.com.cn/book/1272)\n关于`Three.js`中文文章资料还是不够丰富，以至于这本免费小书时至今日还是`Three.js`入门的最佳选择之一。\n\n*   1. [测试你的前端代码 – part1（介绍篇）](https://mp.weixin.qq.com/s/jUJXmis0_u6BzQDT2mCltA)\n    2. [测试你的前端代码 – part2（单元测试）](https://mp.weixin.qq.com/s/pYUePHOsZegMf4MmJCoJeA)\n    3. [测试你的前端代码 – part3（端到端测试）](https://mp.weixin.qq.com/s/8UfR8bsPd2bkmPg_xkAKKg)\n    4. [测试你的前端代码 – part4（集成测试）](https://mp.weixin.qq.com/s/CpNUn5AWbP4aH0yirwuizQ)\n<br>\n文章由浅入深的介绍前端工程的测试，覆盖单元测试、端到端测试、集成测试，较为简单的事例介绍有利于你快速掌握这些知识。\n\n* [学用 JavaScript 设计模式](http://www.oschina.net/translate/learning-javascript-design-patterns?cmp)\n文章讲解数据响应式系统及其构建，分步骤实现了 vue2.0的响应式，还有详细的代码示例及注释。\n\n","source":"_posts/weekly-2.md","raw":"---\ntitle: 大前端周刊 第二期 （本期小编：胡国伟）\ndate: 2017-06-30 11:18:25\ntags: [weekly,框架,测试,设计模式,three.js]\n---\n\n## 基础\n* [Class 的基本语法](http://es6.ruanyifeng.com/#docs/class)\n尽管基本上，`ES6`的`class`可以看作只是一个语法糖，但使得`JavaScript`对象原型的写法更加清晰、更像面向对象编程的语法，更接近传统语言的写法。\n\n* [Module 的语法](http://es6.ruanyifeng.com/#docs/module)\n相交于社区提供了各种模块化解决方案，`ES6`语言标准的层面上实现了模块功能，成为浏览器和服务器通用的模块解决方案。\n\n* [数组的扩展](http://es6.ruanyifeng.com/#docs/array)\n`ES6`内置新数组方法，无需再自己再实现相应的`polyfill`了，赶紧学习充能，搭配[该文（*【深度长文】JavaScript数组所有API全解密*）](http://louiszhai.github.io/2017/04/28/array/)食用，更易消化。\n\n* [webpack 中文](https://webpack-china.org/)\n旧版的`webpack`官方文档有些糟糕，幸好后来有了新版，并且还有志愿者维护了相对应的中文版本，这下查阅学习就更轻松了。近日`webpack 3.0` 已经释出，大家赶快跟进。\n\n* [EditorConfig使用介绍](https://segmentfault.com/a/1190000007599845)\n团队合作，统一编辑器行为非常必要，本文对`EditorConfig`中的配置进行了讲解。\nps：[EditorConfig](http://editorconfig.org/)规范在这里。\n\n## 文章\n\n*   1. [Server-Sent Events 教程](http://www.ruanyifeng.com/blog/2017/05/server-sent_events.html)\n    2. [WebSocket 教程](http://www.ruanyifeng.com/blog/2017/05/websocket.html) <br/>\n这两篇文章一起读，就可以很全面的了解现代浏览器和服务器通信技术。\n\n* [深入理解 JavaScript 异步](https://github.com/wangfupeng1988/js-async-tutorial)\n这个系列文章把异步方面的知识以及原理讲解的比较清楚，从传统的方式到`promise`到`generator`到`async`，值得一读。\n\n* [koa2从起步到填坑](http://www.jianshu.com/p/6b816c609669)\n比较系统简介`koa2`使用，包含一些例子，可以让人更快上手。\n\n* [现代前端科技解析 —— 数据响应式系统](https://www.404forest.com/2017/06/28/modern-web-development-tech-analysis-data-reactivity-system/)\n文章讲解数据响应式系统及其构建，分步骤实现了`vue2.0`的响应式，还有详细的代码示例及注释。\n\n* [关于前端开发谈谈单元测试](https://segmentfault.com/a/1190000000317146)\n阐述了做单元测试的必要性，\n着重介绍了`Jasmine`的常用语法，\n并对其他流行测试框架和工具做了介绍。\n\n* [Three.js入门指南](http://www.ituring.com.cn/book/1272)\n关于`Three.js`中文文章资料还是不够丰富，以至于这本免费小书时至今日还是`Three.js`入门的最佳选择之一。\n\n*   1. [测试你的前端代码 – part1（介绍篇）](https://mp.weixin.qq.com/s/jUJXmis0_u6BzQDT2mCltA)\n    2. [测试你的前端代码 – part2（单元测试）](https://mp.weixin.qq.com/s/pYUePHOsZegMf4MmJCoJeA)\n    3. [测试你的前端代码 – part3（端到端测试）](https://mp.weixin.qq.com/s/8UfR8bsPd2bkmPg_xkAKKg)\n    4. [测试你的前端代码 – part4（集成测试）](https://mp.weixin.qq.com/s/CpNUn5AWbP4aH0yirwuizQ)\n<br>\n文章由浅入深的介绍前端工程的测试，覆盖单元测试、端到端测试、集成测试，较为简单的事例介绍有利于你快速掌握这些知识。\n\n* [学用 JavaScript 设计模式](http://www.oschina.net/translate/learning-javascript-design-patterns?cmp)\n文章讲解数据响应式系统及其构建，分步骤实现了 vue2.0的响应式，还有详细的代码示例及注释。\n\n","slug":"weekly-2","published":1,"updated":"2017-07-04T03:52:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5db41ir000881txzmq787h5","content":"<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><ul>\n<li><p><a href=\"http://es6.ruanyifeng.com/#docs/class\" target=\"_blank\" rel=\"external\">Class 的基本语法</a><br>尽管基本上，<code>ES6</code>的<code>class</code>可以看作只是一个语法糖，但使得<code>JavaScript</code>对象原型的写法更加清晰、更像面向对象编程的语法，更接近传统语言的写法。</p>\n</li>\n<li><p><a href=\"http://es6.ruanyifeng.com/#docs/module\" target=\"_blank\" rel=\"external\">Module 的语法</a><br>相交于社区提供了各种模块化解决方案，<code>ES6</code>语言标准的层面上实现了模块功能，成为浏览器和服务器通用的模块解决方案。</p>\n</li>\n<li><p><a href=\"http://es6.ruanyifeng.com/#docs/array\" target=\"_blank\" rel=\"external\">数组的扩展</a><br><code>ES6</code>内置新数组方法，无需再自己再实现相应的<code>polyfill</code>了，赶紧学习充能，搭配<a href=\"http://louiszhai.github.io/2017/04/28/array/\" target=\"_blank\" rel=\"external\">该文（<em>【深度长文】JavaScript数组所有API全解密</em>）</a>食用，更易消化。</p>\n</li>\n<li><p><a href=\"https://webpack-china.org/\" target=\"_blank\" rel=\"external\">webpack 中文</a><br>旧版的<code>webpack</code>官方文档有些糟糕，幸好后来有了新版，并且还有志愿者维护了相对应的中文版本，这下查阅学习就更轻松了。近日<code>webpack 3.0</code> 已经释出，大家赶快跟进。</p>\n</li>\n<li><p><a href=\"https://segmentfault.com/a/1190000007599845\" target=\"_blank\" rel=\"external\">EditorConfig使用介绍</a><br>团队合作，统一编辑器行为非常必要，本文对<code>EditorConfig</code>中的配置进行了讲解。<br>ps：<a href=\"http://editorconfig.org/\" target=\"_blank\" rel=\"external\">EditorConfig</a>规范在这里。</p>\n</li>\n</ul>\n<h2 id=\"文章\"><a href=\"#文章\" class=\"headerlink\" title=\"文章\"></a>文章</h2><ul>\n<li><ol>\n<li><a href=\"http://www.ruanyifeng.com/blog/2017/05/server-sent_events.html\" target=\"_blank\" rel=\"external\">Server-Sent Events 教程</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2017/05/websocket.html\" target=\"_blank\" rel=\"external\">WebSocket 教程</a> <br><br>这两篇文章一起读，就可以很全面的了解现代浏览器和服务器通信技术。</li>\n</ol>\n</li>\n<li><p><a href=\"https://github.com/wangfupeng1988/js-async-tutorial\" target=\"_blank\" rel=\"external\">深入理解 JavaScript 异步</a><br>这个系列文章把异步方面的知识以及原理讲解的比较清楚，从传统的方式到<code>promise</code>到<code>generator</code>到<code>async</code>，值得一读。</p>\n</li>\n<li><p><a href=\"http://www.jianshu.com/p/6b816c609669\" target=\"_blank\" rel=\"external\">koa2从起步到填坑</a><br>比较系统简介<code>koa2</code>使用，包含一些例子，可以让人更快上手。</p>\n</li>\n<li><p><a href=\"https://www.404forest.com/2017/06/28/modern-web-development-tech-analysis-data-reactivity-system/\" target=\"_blank\" rel=\"external\">现代前端科技解析 —— 数据响应式系统</a><br>文章讲解数据响应式系统及其构建，分步骤实现了<code>vue2.0</code>的响应式，还有详细的代码示例及注释。</p>\n</li>\n<li><p><a href=\"https://segmentfault.com/a/1190000000317146\" target=\"_blank\" rel=\"external\">关于前端开发谈谈单元测试</a><br>阐述了做单元测试的必要性，<br>着重介绍了<code>Jasmine</code>的常用语法，<br>并对其他流行测试框架和工具做了介绍。</p>\n</li>\n<li><p><a href=\"http://www.ituring.com.cn/book/1272\" target=\"_blank\" rel=\"external\">Three.js入门指南</a><br>关于<code>Three.js</code>中文文章资料还是不够丰富，以至于这本免费小书时至今日还是<code>Three.js</code>入门的最佳选择之一。</p>\n</li>\n<li><ol>\n<li><a href=\"https://mp.weixin.qq.com/s/jUJXmis0_u6BzQDT2mCltA\" target=\"_blank\" rel=\"external\">测试你的前端代码 – part1（介绍篇）</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/pYUePHOsZegMf4MmJCoJeA\" target=\"_blank\" rel=\"external\">测试你的前端代码 – part2（单元测试）</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/8UfR8bsPd2bkmPg_xkAKKg\" target=\"_blank\" rel=\"external\">测试你的前端代码 – part3（端到端测试）</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/CpNUn5AWbP4aH0yirwuizQ\" target=\"_blank\" rel=\"external\">测试你的前端代码 – part4（集成测试）</a><br><br><br>文章由浅入深的介绍前端工程的测试，覆盖单元测试、端到端测试、集成测试，较为简单的事例介绍有利于你快速掌握这些知识。</li>\n</ol>\n</li>\n<li><p><a href=\"http://www.oschina.net/translate/learning-javascript-design-patterns?cmp\" target=\"_blank\" rel=\"external\">学用 JavaScript 设计模式</a><br>文章讲解数据响应式系统及其构建，分步骤实现了 vue2.0的响应式，还有详细的代码示例及注释。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><ul>\n<li><p><a href=\"http://es6.ruanyifeng.com/#docs/class\" target=\"_blank\" rel=\"external\">Class 的基本语法</a><br>尽管基本上，<code>ES6</code>的<code>class</code>可以看作只是一个语法糖，但使得<code>JavaScript</code>对象原型的写法更加清晰、更像面向对象编程的语法，更接近传统语言的写法。</p>\n</li>\n<li><p><a href=\"http://es6.ruanyifeng.com/#docs/module\" target=\"_blank\" rel=\"external\">Module 的语法</a><br>相交于社区提供了各种模块化解决方案，<code>ES6</code>语言标准的层面上实现了模块功能，成为浏览器和服务器通用的模块解决方案。</p>\n</li>\n<li><p><a href=\"http://es6.ruanyifeng.com/#docs/array\" target=\"_blank\" rel=\"external\">数组的扩展</a><br><code>ES6</code>内置新数组方法，无需再自己再实现相应的<code>polyfill</code>了，赶紧学习充能，搭配<a href=\"http://louiszhai.github.io/2017/04/28/array/\" target=\"_blank\" rel=\"external\">该文（<em>【深度长文】JavaScript数组所有API全解密</em>）</a>食用，更易消化。</p>\n</li>\n<li><p><a href=\"https://webpack-china.org/\" target=\"_blank\" rel=\"external\">webpack 中文</a><br>旧版的<code>webpack</code>官方文档有些糟糕，幸好后来有了新版，并且还有志愿者维护了相对应的中文版本，这下查阅学习就更轻松了。近日<code>webpack 3.0</code> 已经释出，大家赶快跟进。</p>\n</li>\n<li><p><a href=\"https://segmentfault.com/a/1190000007599845\" target=\"_blank\" rel=\"external\">EditorConfig使用介绍</a><br>团队合作，统一编辑器行为非常必要，本文对<code>EditorConfig</code>中的配置进行了讲解。<br>ps：<a href=\"http://editorconfig.org/\" target=\"_blank\" rel=\"external\">EditorConfig</a>规范在这里。</p>\n</li>\n</ul>\n<h2 id=\"文章\"><a href=\"#文章\" class=\"headerlink\" title=\"文章\"></a>文章</h2><ul>\n<li><ol>\n<li><a href=\"http://www.ruanyifeng.com/blog/2017/05/server-sent_events.html\" target=\"_blank\" rel=\"external\">Server-Sent Events 教程</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2017/05/websocket.html\" target=\"_blank\" rel=\"external\">WebSocket 教程</a> <br><br>这两篇文章一起读，就可以很全面的了解现代浏览器和服务器通信技术。</li>\n</ol>\n</li>\n<li><p><a href=\"https://github.com/wangfupeng1988/js-async-tutorial\" target=\"_blank\" rel=\"external\">深入理解 JavaScript 异步</a><br>这个系列文章把异步方面的知识以及原理讲解的比较清楚，从传统的方式到<code>promise</code>到<code>generator</code>到<code>async</code>，值得一读。</p>\n</li>\n<li><p><a href=\"http://www.jianshu.com/p/6b816c609669\" target=\"_blank\" rel=\"external\">koa2从起步到填坑</a><br>比较系统简介<code>koa2</code>使用，包含一些例子，可以让人更快上手。</p>\n</li>\n<li><p><a href=\"https://www.404forest.com/2017/06/28/modern-web-development-tech-analysis-data-reactivity-system/\" target=\"_blank\" rel=\"external\">现代前端科技解析 —— 数据响应式系统</a><br>文章讲解数据响应式系统及其构建，分步骤实现了<code>vue2.0</code>的响应式，还有详细的代码示例及注释。</p>\n</li>\n<li><p><a href=\"https://segmentfault.com/a/1190000000317146\" target=\"_blank\" rel=\"external\">关于前端开发谈谈单元测试</a><br>阐述了做单元测试的必要性，<br>着重介绍了<code>Jasmine</code>的常用语法，<br>并对其他流行测试框架和工具做了介绍。</p>\n</li>\n<li><p><a href=\"http://www.ituring.com.cn/book/1272\" target=\"_blank\" rel=\"external\">Three.js入门指南</a><br>关于<code>Three.js</code>中文文章资料还是不够丰富，以至于这本免费小书时至今日还是<code>Three.js</code>入门的最佳选择之一。</p>\n</li>\n<li><ol>\n<li><a href=\"https://mp.weixin.qq.com/s/jUJXmis0_u6BzQDT2mCltA\" target=\"_blank\" rel=\"external\">测试你的前端代码 – part1（介绍篇）</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/pYUePHOsZegMf4MmJCoJeA\" target=\"_blank\" rel=\"external\">测试你的前端代码 – part2（单元测试）</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/8UfR8bsPd2bkmPg_xkAKKg\" target=\"_blank\" rel=\"external\">测试你的前端代码 – part3（端到端测试）</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/CpNUn5AWbP4aH0yirwuizQ\" target=\"_blank\" rel=\"external\">测试你的前端代码 – part4（集成测试）</a><br><br><br>文章由浅入深的介绍前端工程的测试，覆盖单元测试、端到端测试、集成测试，较为简单的事例介绍有利于你快速掌握这些知识。</li>\n</ol>\n</li>\n<li><p><a href=\"http://www.oschina.net/translate/learning-javascript-design-patterns?cmp\" target=\"_blank\" rel=\"external\">学用 JavaScript 设计模式</a><br>文章讲解数据响应式系统及其构建，分步骤实现了 vue2.0的响应式，还有详细的代码示例及注释。</p>\n</li>\n</ul>\n"},{"title":"大前端周刊 第四期 （本期小编：李丽娇）","date":"2017-07-12T07:16:43.000Z","_content":"\n## 基础\n* [SVG的用法](http://www.webhek.com/post/svg.html)\n**SVG基础和使用介绍**\n\n* [浏览器的渲染原理简介](http://coolshell.cn/articles/9666.html)\n**由浅到深、简单易懂的浏览器渲染原理介绍**\n\n* [Mongoose学习参考文档——基础篇](http://ourjs.com/detail/53ad24edb984bb4659000013)\n**Nodejs使用MongoDB的详细介绍**\n\n\n## 文章\n* [ECMAScript 6 入门-Symbol](http://es6.ruanyifeng.com/#docs/symbol)\n  [symbols类型](http://www.infoq.com/cn/articles/es6-in-depth-symbols)\n<small>*推荐人：王祥*</small>\n继六种数据类型（Undefined、Null、Boolean、Number、String、Object）后，ES6又新增了Symbols类型。Symbols类型比较抽象，要了解相关的适应场景，可以看这两篇文章。\n\n* [Vue 与 iOS 的组件化](https://juejin.im/post/59626ca0f265da6c2442fbdf)\n<small>*推荐人：张成斌*</small>\n对Vue的组件化有一个非常清晰的讲解。组件化原理，组件化分，组件间传递都有涉及。另外笔者是一名普通的全职 iOS 开发者，还介绍iOS的组件化的东西，对前端和移动端进行了一些对比。\n\n* [SVG Sprite技术介绍](http://www.zhangxinxu.com/wordpress/2014/07/introduce-svg-sprite-technology/)\n<small>*推荐人：李丽娇*</small>\n使用svg文件显示小图标已经成为趋势，随之而来地，svg文件合并也成为必然需求。文中介绍了svg sprite的使用原理，并介绍了多种生成svg sprite的方式来满足偏前端、偏命令、偏设计各类coder的需求。\n\n* [ECharts 统计扩展教程](http://efe.baidu.com/blog/echarts-statistical-extension-tutorial/)\n<small>*推荐人：胡国伟*</small>\nECharts 统计扩展，包含的功能有直方图、聚类、回归、以及常用的汇总统计。通过统计扩展和 ECharts 的结合，可以使大家方便地实现可视分析，也就是将数据分析的结果，通过可视化直观地呈现出来。\n\n* [前端性能优化相关](https://github.com/wy-ei/notebook/issues/34#issuecomment-266946255)\n<small>*推荐人：陶明*</small>\n从多角度进行性能问题剖析，对JavaScript，DOM，CSS都介绍了性能优化方面的问题因素及解决方案；内容介绍不是很详细，例如对于debounce 进行消抖只是简单说明，这方面在第一期成斌有推荐详细的[文章](https://github.com/mqyqingfeng/Blog/issues/22)。\n\n* [JavaScript问题集锦](https://github.com/creeperyang/blog/issues/2)\n<small>*推荐人：李志伟*</small>\n文章整理了一些比较有价值且常见的JS问题，看似简单，但深究其原理还是很有必要的，相信对你的JS基础功底是个考验。\n\n* [浅谈 JS 对象之扩展、密封及冻结三大特性](https://segmentfault.com/a/1190000003894119)\n<small>*推荐人：耿少真*</small>\n由浅入深讨论JS中对象的扩展、密封及冻结特性，从三种不同的冻结程度介绍了 js 冻结对象的方法。\n##### 扩展特性:\n  - Object.isExtensible 方法\n  - Object.preventExtensions 方法\n##### 密封特性:\n  - Object.isSealed 方法\n  - Object.seal 方法\n##### 冻结特性\n  - Object.isFrozen 方法\n  - Object.freeze 方法\n\n* [十大经典排序算法](https://github.com/hustcc/JS-Sorting-Algorithm)\n<small>*推荐人：郭俊兵*</small>\n排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。\n\n* [Javascript模块化编程（一）：模块的写法](http://www.ruanyifeng.com/blog/2012/10/javascript_module.html)\n  [Javascript模块化编程（二）：AMD规范](http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html)\n  [Javascript模块化编程（三）：require.js的用法](http://www.ruanyifeng.com/blog/2012/11/require_js.html)\n<small>*推荐人：包京京*</small>\n阮一峰的文章最大的好处就是解释的清楚，很多大牛工程师不善表达，自己会但不一定能教得会。\n三篇系列文章介绍了：js模块花的基本概念，AMD规范以及require.js的实践。\n","source":"_posts/weekly-4.md","raw":"---\ntitle: 大前端周刊 第四期 （本期小编：李丽娇）\ndate: 2017-07-12 15:16:43\ntags:\n---\n\n## 基础\n* [SVG的用法](http://www.webhek.com/post/svg.html)\n**SVG基础和使用介绍**\n\n* [浏览器的渲染原理简介](http://coolshell.cn/articles/9666.html)\n**由浅到深、简单易懂的浏览器渲染原理介绍**\n\n* [Mongoose学习参考文档——基础篇](http://ourjs.com/detail/53ad24edb984bb4659000013)\n**Nodejs使用MongoDB的详细介绍**\n\n\n## 文章\n* [ECMAScript 6 入门-Symbol](http://es6.ruanyifeng.com/#docs/symbol)\n  [symbols类型](http://www.infoq.com/cn/articles/es6-in-depth-symbols)\n<small>*推荐人：王祥*</small>\n继六种数据类型（Undefined、Null、Boolean、Number、String、Object）后，ES6又新增了Symbols类型。Symbols类型比较抽象，要了解相关的适应场景，可以看这两篇文章。\n\n* [Vue 与 iOS 的组件化](https://juejin.im/post/59626ca0f265da6c2442fbdf)\n<small>*推荐人：张成斌*</small>\n对Vue的组件化有一个非常清晰的讲解。组件化原理，组件化分，组件间传递都有涉及。另外笔者是一名普通的全职 iOS 开发者，还介绍iOS的组件化的东西，对前端和移动端进行了一些对比。\n\n* [SVG Sprite技术介绍](http://www.zhangxinxu.com/wordpress/2014/07/introduce-svg-sprite-technology/)\n<small>*推荐人：李丽娇*</small>\n使用svg文件显示小图标已经成为趋势，随之而来地，svg文件合并也成为必然需求。文中介绍了svg sprite的使用原理，并介绍了多种生成svg sprite的方式来满足偏前端、偏命令、偏设计各类coder的需求。\n\n* [ECharts 统计扩展教程](http://efe.baidu.com/blog/echarts-statistical-extension-tutorial/)\n<small>*推荐人：胡国伟*</small>\nECharts 统计扩展，包含的功能有直方图、聚类、回归、以及常用的汇总统计。通过统计扩展和 ECharts 的结合，可以使大家方便地实现可视分析，也就是将数据分析的结果，通过可视化直观地呈现出来。\n\n* [前端性能优化相关](https://github.com/wy-ei/notebook/issues/34#issuecomment-266946255)\n<small>*推荐人：陶明*</small>\n从多角度进行性能问题剖析，对JavaScript，DOM，CSS都介绍了性能优化方面的问题因素及解决方案；内容介绍不是很详细，例如对于debounce 进行消抖只是简单说明，这方面在第一期成斌有推荐详细的[文章](https://github.com/mqyqingfeng/Blog/issues/22)。\n\n* [JavaScript问题集锦](https://github.com/creeperyang/blog/issues/2)\n<small>*推荐人：李志伟*</small>\n文章整理了一些比较有价值且常见的JS问题，看似简单，但深究其原理还是很有必要的，相信对你的JS基础功底是个考验。\n\n* [浅谈 JS 对象之扩展、密封及冻结三大特性](https://segmentfault.com/a/1190000003894119)\n<small>*推荐人：耿少真*</small>\n由浅入深讨论JS中对象的扩展、密封及冻结特性，从三种不同的冻结程度介绍了 js 冻结对象的方法。\n##### 扩展特性:\n  - Object.isExtensible 方法\n  - Object.preventExtensions 方法\n##### 密封特性:\n  - Object.isSealed 方法\n  - Object.seal 方法\n##### 冻结特性\n  - Object.isFrozen 方法\n  - Object.freeze 方法\n\n* [十大经典排序算法](https://github.com/hustcc/JS-Sorting-Algorithm)\n<small>*推荐人：郭俊兵*</small>\n排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。\n\n* [Javascript模块化编程（一）：模块的写法](http://www.ruanyifeng.com/blog/2012/10/javascript_module.html)\n  [Javascript模块化编程（二）：AMD规范](http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html)\n  [Javascript模块化编程（三）：require.js的用法](http://www.ruanyifeng.com/blog/2012/11/require_js.html)\n<small>*推荐人：包京京*</small>\n阮一峰的文章最大的好处就是解释的清楚，很多大牛工程师不善表达，自己会但不一定能教得会。\n三篇系列文章介绍了：js模块花的基本概念，AMD规范以及require.js的实践。\n","slug":"weekly-4","published":1,"updated":"2017-07-12T15:59:01.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5db41iu000a81txr1f619x8","content":"<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><ul>\n<li><p><a href=\"http://www.webhek.com/post/svg.html\" target=\"_blank\" rel=\"external\">SVG的用法</a><br><strong>SVG基础和使用介绍</strong></p>\n</li>\n<li><p><a href=\"http://coolshell.cn/articles/9666.html\" target=\"_blank\" rel=\"external\">浏览器的渲染原理简介</a><br><strong>由浅到深、简单易懂的浏览器渲染原理介绍</strong></p>\n</li>\n<li><p><a href=\"http://ourjs.com/detail/53ad24edb984bb4659000013\" target=\"_blank\" rel=\"external\">Mongoose学习参考文档——基础篇</a><br><strong>Nodejs使用MongoDB的详细介绍</strong></p>\n</li>\n</ul>\n<h2 id=\"文章\"><a href=\"#文章\" class=\"headerlink\" title=\"文章\"></a>文章</h2><ul>\n<li><p><a href=\"http://es6.ruanyifeng.com/#docs/symbol\" target=\"_blank\" rel=\"external\">ECMAScript 6 入门-Symbol</a><br><a href=\"http://www.infoq.com/cn/articles/es6-in-depth-symbols\" target=\"_blank\" rel=\"external\">symbols类型</a><br><small><em>推荐人：王祥</em></small><br>继六种数据类型（Undefined、Null、Boolean、Number、String、Object）后，ES6又新增了Symbols类型。Symbols类型比较抽象，要了解相关的适应场景，可以看这两篇文章。</p>\n</li>\n<li><p><a href=\"https://juejin.im/post/59626ca0f265da6c2442fbdf\" target=\"_blank\" rel=\"external\">Vue 与 iOS 的组件化</a><br><small><em>推荐人：张成斌</em></small><br>对Vue的组件化有一个非常清晰的讲解。组件化原理，组件化分，组件间传递都有涉及。另外笔者是一名普通的全职 iOS 开发者，还介绍iOS的组件化的东西，对前端和移动端进行了一些对比。</p>\n</li>\n<li><p><a href=\"http://www.zhangxinxu.com/wordpress/2014/07/introduce-svg-sprite-technology/\" target=\"_blank\" rel=\"external\">SVG Sprite技术介绍</a><br><small><em>推荐人：李丽娇</em></small><br>使用svg文件显示小图标已经成为趋势，随之而来地，svg文件合并也成为必然需求。文中介绍了svg sprite的使用原理，并介绍了多种生成svg sprite的方式来满足偏前端、偏命令、偏设计各类coder的需求。</p>\n</li>\n<li><p><a href=\"http://efe.baidu.com/blog/echarts-statistical-extension-tutorial/\" target=\"_blank\" rel=\"external\">ECharts 统计扩展教程</a><br><small><em>推荐人：胡国伟</em></small><br>ECharts 统计扩展，包含的功能有直方图、聚类、回归、以及常用的汇总统计。通过统计扩展和 ECharts 的结合，可以使大家方便地实现可视分析，也就是将数据分析的结果，通过可视化直观地呈现出来。</p>\n</li>\n<li><p><a href=\"https://github.com/wy-ei/notebook/issues/34#issuecomment-266946255\" target=\"_blank\" rel=\"external\">前端性能优化相关</a><br><small><em>推荐人：陶明</em></small><br>从多角度进行性能问题剖析，对JavaScript，DOM，CSS都介绍了性能优化方面的问题因素及解决方案；内容介绍不是很详细，例如对于debounce 进行消抖只是简单说明，这方面在第一期成斌有推荐详细的<a href=\"https://github.com/mqyqingfeng/Blog/issues/22\" target=\"_blank\" rel=\"external\">文章</a>。</p>\n</li>\n<li><p><a href=\"https://github.com/creeperyang/blog/issues/2\" target=\"_blank\" rel=\"external\">JavaScript问题集锦</a><br><small><em>推荐人：李志伟</em></small><br>文章整理了一些比较有价值且常见的JS问题，看似简单，但深究其原理还是很有必要的，相信对你的JS基础功底是个考验。</p>\n</li>\n<li><p><a href=\"https://segmentfault.com/a/1190000003894119\" target=\"_blank\" rel=\"external\">浅谈 JS 对象之扩展、密封及冻结三大特性</a><br><small><em>推荐人：耿少真</em></small><br>由浅入深讨论JS中对象的扩展、密封及冻结特性，从三种不同的冻结程度介绍了 js 冻结对象的方法。</p>\n<h5 id=\"扩展特性\"><a href=\"#扩展特性\" class=\"headerlink\" title=\"扩展特性:\"></a>扩展特性:</h5><ul>\n<li>Object.isExtensible 方法</li>\n<li>Object.preventExtensions 方法<h5 id=\"密封特性\"><a href=\"#密封特性\" class=\"headerlink\" title=\"密封特性:\"></a>密封特性:</h5></li>\n<li>Object.isSealed 方法</li>\n<li>Object.seal 方法<h5 id=\"冻结特性\"><a href=\"#冻结特性\" class=\"headerlink\" title=\"冻结特性\"></a>冻结特性</h5></li>\n<li>Object.isFrozen 方法</li>\n<li>Object.freeze 方法</li>\n</ul>\n</li>\n<li><p><a href=\"https://github.com/hustcc/JS-Sorting-Algorithm\" target=\"_blank\" rel=\"external\">十大经典排序算法</a><br><small><em>推荐人：郭俊兵</em></small><br>排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。</p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2012/10/javascript_module.html\" target=\"_blank\" rel=\"external\">Javascript模块化编程（一）：模块的写法</a><br><a href=\"http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html\" target=\"_blank\" rel=\"external\">Javascript模块化编程（二）：AMD规范</a><br><a href=\"http://www.ruanyifeng.com/blog/2012/11/require_js.html\" target=\"_blank\" rel=\"external\">Javascript模块化编程（三）：require.js的用法</a><br><small><em>推荐人：包京京</em></small><br>阮一峰的文章最大的好处就是解释的清楚，很多大牛工程师不善表达，自己会但不一定能教得会。<br>三篇系列文章介绍了：js模块花的基本概念，AMD规范以及require.js的实践。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><ul>\n<li><p><a href=\"http://www.webhek.com/post/svg.html\" target=\"_blank\" rel=\"external\">SVG的用法</a><br><strong>SVG基础和使用介绍</strong></p>\n</li>\n<li><p><a href=\"http://coolshell.cn/articles/9666.html\" target=\"_blank\" rel=\"external\">浏览器的渲染原理简介</a><br><strong>由浅到深、简单易懂的浏览器渲染原理介绍</strong></p>\n</li>\n<li><p><a href=\"http://ourjs.com/detail/53ad24edb984bb4659000013\" target=\"_blank\" rel=\"external\">Mongoose学习参考文档——基础篇</a><br><strong>Nodejs使用MongoDB的详细介绍</strong></p>\n</li>\n</ul>\n<h2 id=\"文章\"><a href=\"#文章\" class=\"headerlink\" title=\"文章\"></a>文章</h2><ul>\n<li><p><a href=\"http://es6.ruanyifeng.com/#docs/symbol\" target=\"_blank\" rel=\"external\">ECMAScript 6 入门-Symbol</a><br><a href=\"http://www.infoq.com/cn/articles/es6-in-depth-symbols\" target=\"_blank\" rel=\"external\">symbols类型</a><br><small><em>推荐人：王祥</em></small><br>继六种数据类型（Undefined、Null、Boolean、Number、String、Object）后，ES6又新增了Symbols类型。Symbols类型比较抽象，要了解相关的适应场景，可以看这两篇文章。</p>\n</li>\n<li><p><a href=\"https://juejin.im/post/59626ca0f265da6c2442fbdf\" target=\"_blank\" rel=\"external\">Vue 与 iOS 的组件化</a><br><small><em>推荐人：张成斌</em></small><br>对Vue的组件化有一个非常清晰的讲解。组件化原理，组件化分，组件间传递都有涉及。另外笔者是一名普通的全职 iOS 开发者，还介绍iOS的组件化的东西，对前端和移动端进行了一些对比。</p>\n</li>\n<li><p><a href=\"http://www.zhangxinxu.com/wordpress/2014/07/introduce-svg-sprite-technology/\" target=\"_blank\" rel=\"external\">SVG Sprite技术介绍</a><br><small><em>推荐人：李丽娇</em></small><br>使用svg文件显示小图标已经成为趋势，随之而来地，svg文件合并也成为必然需求。文中介绍了svg sprite的使用原理，并介绍了多种生成svg sprite的方式来满足偏前端、偏命令、偏设计各类coder的需求。</p>\n</li>\n<li><p><a href=\"http://efe.baidu.com/blog/echarts-statistical-extension-tutorial/\" target=\"_blank\" rel=\"external\">ECharts 统计扩展教程</a><br><small><em>推荐人：胡国伟</em></small><br>ECharts 统计扩展，包含的功能有直方图、聚类、回归、以及常用的汇总统计。通过统计扩展和 ECharts 的结合，可以使大家方便地实现可视分析，也就是将数据分析的结果，通过可视化直观地呈现出来。</p>\n</li>\n<li><p><a href=\"https://github.com/wy-ei/notebook/issues/34#issuecomment-266946255\" target=\"_blank\" rel=\"external\">前端性能优化相关</a><br><small><em>推荐人：陶明</em></small><br>从多角度进行性能问题剖析，对JavaScript，DOM，CSS都介绍了性能优化方面的问题因素及解决方案；内容介绍不是很详细，例如对于debounce 进行消抖只是简单说明，这方面在第一期成斌有推荐详细的<a href=\"https://github.com/mqyqingfeng/Blog/issues/22\" target=\"_blank\" rel=\"external\">文章</a>。</p>\n</li>\n<li><p><a href=\"https://github.com/creeperyang/blog/issues/2\" target=\"_blank\" rel=\"external\">JavaScript问题集锦</a><br><small><em>推荐人：李志伟</em></small><br>文章整理了一些比较有价值且常见的JS问题，看似简单，但深究其原理还是很有必要的，相信对你的JS基础功底是个考验。</p>\n</li>\n<li><p><a href=\"https://segmentfault.com/a/1190000003894119\" target=\"_blank\" rel=\"external\">浅谈 JS 对象之扩展、密封及冻结三大特性</a><br><small><em>推荐人：耿少真</em></small><br>由浅入深讨论JS中对象的扩展、密封及冻结特性，从三种不同的冻结程度介绍了 js 冻结对象的方法。</p>\n<h5 id=\"扩展特性\"><a href=\"#扩展特性\" class=\"headerlink\" title=\"扩展特性:\"></a>扩展特性:</h5><ul>\n<li>Object.isExtensible 方法</li>\n<li>Object.preventExtensions 方法<h5 id=\"密封特性\"><a href=\"#密封特性\" class=\"headerlink\" title=\"密封特性:\"></a>密封特性:</h5></li>\n<li>Object.isSealed 方法</li>\n<li>Object.seal 方法<h5 id=\"冻结特性\"><a href=\"#冻结特性\" class=\"headerlink\" title=\"冻结特性\"></a>冻结特性</h5></li>\n<li>Object.isFrozen 方法</li>\n<li>Object.freeze 方法</li>\n</ul>\n</li>\n<li><p><a href=\"https://github.com/hustcc/JS-Sorting-Algorithm\" target=\"_blank\" rel=\"external\">十大经典排序算法</a><br><small><em>推荐人：郭俊兵</em></small><br>排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。</p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2012/10/javascript_module.html\" target=\"_blank\" rel=\"external\">Javascript模块化编程（一）：模块的写法</a><br><a href=\"http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html\" target=\"_blank\" rel=\"external\">Javascript模块化编程（二）：AMD规范</a><br><a href=\"http://www.ruanyifeng.com/blog/2012/11/require_js.html\" target=\"_blank\" rel=\"external\">Javascript模块化编程（三）：require.js的用法</a><br><small><em>推荐人：包京京</em></small><br>阮一峰的文章最大的好处就是解释的清楚，很多大牛工程师不善表达，自己会但不一定能教得会。<br>三篇系列文章介绍了：js模块花的基本概念，AMD规范以及require.js的实践。</p>\n</li>\n</ul>\n"},{"title":"大前端周刊 第三期 （本期小编：李志伟）","date":"2017-07-07T05:10:51.000Z","_content":"\n## 基础\n* [JavaScript系列](https://juejin.im/post/59278e312f301e006c2e1510)\n相信作为“前端程序猿(媛)”的你一定了解作用域、原型、原型链、继承、闭包……在前端框架的盛行之下，却让初学者忽略了JS基础的学习，但基础不稳必然限制你的发展空间，当你了解了底层，就能很轻松明白框架的原理。\n\n* [排序算法](https://juejin.im/post/57dcd394a22b9d00610c5ec8)\n什么？在这个“用数据说话”的时代，你不懂排序算法？那你算什么男人~算什么男人~ 不对不对 算什么猿人~算什么猿人...咳咳，言归正传，平时开发我们常用的快速排序、冒泡排序、选择排序你是否了解其利弊。除此之外还有什么排序算法呢？快来一起学习吧。\n\n* [Iterator 遍历器](http://es6.ruanyifeng.com/#docs/iterator)\nIterator为各种不同的数据结构提供了统一的访问机制。它可以提供统一的、简便的接口，使得数据结构的成员按某种次序排列，而es6新增for...of循环，就是由Iterator接口提供消费的。\n\n* [TCP协议简介](http://www.ruanyifeng.com/blog/2017/06/tcp-protocol.html)\nTCP作为互联网核心协议之一，“三次握手”“四次挥手”你是否有所了解？快来完善自己的知识体系吧。\nps:详解请参考[这里](http://www.jianshu.com/p/ef892323e68f)\n\n* [正则表达式](http://www.jianshu.com/p/e7bb97218946)\n业务中有很多复杂的逻辑判断？常常嵌套多个if？快来这里学习下吧，熟练掌握正则表达式会使得你的开发效率得到极大提升。\n\n## 资源整理\n* [前端知识点大百科全书](https://github.com/Wscats/Good-text-Share)\n* [前端资源汇集](http://www.jianshu.com/p/c3dae0951f74)\n如此之全的知识整理、资源汇集，都掌握的话你可以神挡杀神佛挡杀佛了。\n\n## 文章\n\n* [一劳永逸的搞定flex布局](https://juejin.im/post/58e3a5a0a0bb9f0069fc16bb)\n你是否还在使用浮动布局？写各种line-height实现居中？不妨试试flexBox布局，它简单易用的写法可以轻松实现各种布局，让你的布局更快速高效。\n\n* [Vue的数据依赖实现原理简析](https://segmentfault.com/a/1190000010014281)\n主要从初始化的数据层面上分析了Vue是如何管理依赖来到达数据的动态响应。\ninitState的过程中，将props,computed,data等属性通过Object.defineProperty来改造其getter/setter属性，并为每一个响应式属性实例化一个observer观察者。这个observer内部dep记录了这个响应式属性的所有依赖。\n当响应式属性调用setter函数时，通过dep.notify()方法去遍历所有的依赖，调用watcher.update()去完成数据的动态响应。\n\n* [靠谱程序员必备技能——重构](https://mp.weixin.qq.com/s?__biz=MzIyNjE4NjI2Nw==&mid=2652558943&idx=1&sn=1516afcf876b9fb4a17ce048c5ade58d)\n当项目变得难以维护，重构便便迫在眉睫，但很多所谓重构仅仅算是重写，随着时间推移，项目再次变得难以维护，周而复始，陷入怪圈。如何避免重构变成重写，本文给了一些很好的建议。\n\n* [我接触过的前端数据结构与算法](https://zhuanlan.zhihu.com/p/27659059)\n只要是工程师就必须学好计算机基础，只有这样才能适应计算机技术的快速发展，前端工程师更是如此。\n\n* [Vuex 通俗版教程](https://yeaseonzhang.github.io/2017/03/16/Vuex-%E9%80%9A%E4%BF%97%E7%89%88/)\nVuex 类似 Redux 的状态管理器，用来管理Vue的所有组件状态。\n一般在你开发大型单页应用（SPA），会出现多个视图组件依赖同一个状态，来自不同视图的行为需要变更同一个状态。\n遇到以上情况时候，可以考虑使用Vuex，它能把组件的共享状态抽取出来，当做一个全局单例模式进行管理。这样不管你在何处改变状态，都会通知使用该状态的组件做出相应修改。\n\n* [学习Vue.js源码](https://stffe.github.io/vue/2017/03/03/%E5%AD%A6%E4%B9%A0Vue%E6%BA%90%E7%A0%81.html)\n文中介绍了vue项目目录结构和数据绑定实现，没有太深入，但可以作为初步了解。\n\n* [GitHub —— 你不得不上的交友网站](https://segmentfault.com/a/1190000009985489#articleHeader9)\n文章整理了GitHub入门，搭建发布个人博客及个人项目发布，还介绍了一些工具，插件及开源项目；内容比较丰富。\n\n* [彻底搞清楚javascript中的require、import和export](http://meiminjun.github.io/import%E5%92%8Cexport%E7%AC%94%E8%AE%B0/)\n通过介绍CMD、AMD、ES6的模块规范，来引申出平时业务中经常用到require、import和export的用法以及含义。\n\n* [工具推荐](https://github.com/istanbuljs/nyc)\n覆盖率工具 istanbul 替换为 nyc，多进程覆盖率的测试速度提升了几倍。都是同一作者的作品，后者目前活跃度高，并支持前端很多新特性。\n\n```\n$ npm i nyc --save-dev\n$ ./node_modules/.bin/nyc ./node_modules/.bin/mocha\n```\n执行单元测试命令后，还会直观的给出代码覆盖率报告，以[Flclover](http://flcloverjs.org/)为例：\n```\n------------------------------------|----------|----------|----------|----------|----------------|\nFile                                |  % Stmts | % Branch |  % Funcs |  % Lines |Uncovered Lines |\n------------------------------------|----------|----------|----------|----------|----------------|\nAll files                           |    79.41 |    66.67 |    61.11 |    81.82 |                |\n flclover                           |      100 |      100 |      100 |      100 |                |\n  index.js                          |      100 |      100 |      100 |      100 |                |\n flclover/lib                       |    88.52 |    82.35 |    81.82 |    88.52 |                |\n  application.js                    |      100 |      100 |      100 |      100 |                |\n  flclover.js                       |       30 |        0 |        0 |       30 |... 13,14,17,19 |\n flclover/lib/middleware/bodyparser |      100 |      100 |      100 |      100 |                |\n  index.js                          |      100 |      100 |      100 |      100 |                |\n flclover/lib/middleware/logger     |    55.56 |       50 |       50 |    55.56 |                |\n  index.js                          |    55.56 |       50 |       50 |    55.56 |... 39,42,45,48 |\n flclover/lib/utils                 |    71.43 |    33.33 |        0 |    83.33 |                |\n  index.js                          |    81.25 |    33.33 |        0 |      100 |           7,10 |\n  logger.js                         |       40 |      100 |        0 |       40 |         4,9,13 |\n------------------------------------|----------|----------|----------|----------|----------------|\n```","source":"_posts/weekly-3.md","raw":"---\ntitle: 大前端周刊 第三期 （本期小编：李志伟）\ndate: 2017-07-07 13:10:51\ntags: [weekly,es6,vue,算法,工具,必备技能]\n---\n\n## 基础\n* [JavaScript系列](https://juejin.im/post/59278e312f301e006c2e1510)\n相信作为“前端程序猿(媛)”的你一定了解作用域、原型、原型链、继承、闭包……在前端框架的盛行之下，却让初学者忽略了JS基础的学习，但基础不稳必然限制你的发展空间，当你了解了底层，就能很轻松明白框架的原理。\n\n* [排序算法](https://juejin.im/post/57dcd394a22b9d00610c5ec8)\n什么？在这个“用数据说话”的时代，你不懂排序算法？那你算什么男人~算什么男人~ 不对不对 算什么猿人~算什么猿人...咳咳，言归正传，平时开发我们常用的快速排序、冒泡排序、选择排序你是否了解其利弊。除此之外还有什么排序算法呢？快来一起学习吧。\n\n* [Iterator 遍历器](http://es6.ruanyifeng.com/#docs/iterator)\nIterator为各种不同的数据结构提供了统一的访问机制。它可以提供统一的、简便的接口，使得数据结构的成员按某种次序排列，而es6新增for...of循环，就是由Iterator接口提供消费的。\n\n* [TCP协议简介](http://www.ruanyifeng.com/blog/2017/06/tcp-protocol.html)\nTCP作为互联网核心协议之一，“三次握手”“四次挥手”你是否有所了解？快来完善自己的知识体系吧。\nps:详解请参考[这里](http://www.jianshu.com/p/ef892323e68f)\n\n* [正则表达式](http://www.jianshu.com/p/e7bb97218946)\n业务中有很多复杂的逻辑判断？常常嵌套多个if？快来这里学习下吧，熟练掌握正则表达式会使得你的开发效率得到极大提升。\n\n## 资源整理\n* [前端知识点大百科全书](https://github.com/Wscats/Good-text-Share)\n* [前端资源汇集](http://www.jianshu.com/p/c3dae0951f74)\n如此之全的知识整理、资源汇集，都掌握的话你可以神挡杀神佛挡杀佛了。\n\n## 文章\n\n* [一劳永逸的搞定flex布局](https://juejin.im/post/58e3a5a0a0bb9f0069fc16bb)\n你是否还在使用浮动布局？写各种line-height实现居中？不妨试试flexBox布局，它简单易用的写法可以轻松实现各种布局，让你的布局更快速高效。\n\n* [Vue的数据依赖实现原理简析](https://segmentfault.com/a/1190000010014281)\n主要从初始化的数据层面上分析了Vue是如何管理依赖来到达数据的动态响应。\ninitState的过程中，将props,computed,data等属性通过Object.defineProperty来改造其getter/setter属性，并为每一个响应式属性实例化一个observer观察者。这个observer内部dep记录了这个响应式属性的所有依赖。\n当响应式属性调用setter函数时，通过dep.notify()方法去遍历所有的依赖，调用watcher.update()去完成数据的动态响应。\n\n* [靠谱程序员必备技能——重构](https://mp.weixin.qq.com/s?__biz=MzIyNjE4NjI2Nw==&mid=2652558943&idx=1&sn=1516afcf876b9fb4a17ce048c5ade58d)\n当项目变得难以维护，重构便便迫在眉睫，但很多所谓重构仅仅算是重写，随着时间推移，项目再次变得难以维护，周而复始，陷入怪圈。如何避免重构变成重写，本文给了一些很好的建议。\n\n* [我接触过的前端数据结构与算法](https://zhuanlan.zhihu.com/p/27659059)\n只要是工程师就必须学好计算机基础，只有这样才能适应计算机技术的快速发展，前端工程师更是如此。\n\n* [Vuex 通俗版教程](https://yeaseonzhang.github.io/2017/03/16/Vuex-%E9%80%9A%E4%BF%97%E7%89%88/)\nVuex 类似 Redux 的状态管理器，用来管理Vue的所有组件状态。\n一般在你开发大型单页应用（SPA），会出现多个视图组件依赖同一个状态，来自不同视图的行为需要变更同一个状态。\n遇到以上情况时候，可以考虑使用Vuex，它能把组件的共享状态抽取出来，当做一个全局单例模式进行管理。这样不管你在何处改变状态，都会通知使用该状态的组件做出相应修改。\n\n* [学习Vue.js源码](https://stffe.github.io/vue/2017/03/03/%E5%AD%A6%E4%B9%A0Vue%E6%BA%90%E7%A0%81.html)\n文中介绍了vue项目目录结构和数据绑定实现，没有太深入，但可以作为初步了解。\n\n* [GitHub —— 你不得不上的交友网站](https://segmentfault.com/a/1190000009985489#articleHeader9)\n文章整理了GitHub入门，搭建发布个人博客及个人项目发布，还介绍了一些工具，插件及开源项目；内容比较丰富。\n\n* [彻底搞清楚javascript中的require、import和export](http://meiminjun.github.io/import%E5%92%8Cexport%E7%AC%94%E8%AE%B0/)\n通过介绍CMD、AMD、ES6的模块规范，来引申出平时业务中经常用到require、import和export的用法以及含义。\n\n* [工具推荐](https://github.com/istanbuljs/nyc)\n覆盖率工具 istanbul 替换为 nyc，多进程覆盖率的测试速度提升了几倍。都是同一作者的作品，后者目前活跃度高，并支持前端很多新特性。\n\n```\n$ npm i nyc --save-dev\n$ ./node_modules/.bin/nyc ./node_modules/.bin/mocha\n```\n执行单元测试命令后，还会直观的给出代码覆盖率报告，以[Flclover](http://flcloverjs.org/)为例：\n```\n------------------------------------|----------|----------|----------|----------|----------------|\nFile                                |  % Stmts | % Branch |  % Funcs |  % Lines |Uncovered Lines |\n------------------------------------|----------|----------|----------|----------|----------------|\nAll files                           |    79.41 |    66.67 |    61.11 |    81.82 |                |\n flclover                           |      100 |      100 |      100 |      100 |                |\n  index.js                          |      100 |      100 |      100 |      100 |                |\n flclover/lib                       |    88.52 |    82.35 |    81.82 |    88.52 |                |\n  application.js                    |      100 |      100 |      100 |      100 |                |\n  flclover.js                       |       30 |        0 |        0 |       30 |... 13,14,17,19 |\n flclover/lib/middleware/bodyparser |      100 |      100 |      100 |      100 |                |\n  index.js                          |      100 |      100 |      100 |      100 |                |\n flclover/lib/middleware/logger     |    55.56 |       50 |       50 |    55.56 |                |\n  index.js                          |    55.56 |       50 |       50 |    55.56 |... 39,42,45,48 |\n flclover/lib/utils                 |    71.43 |    33.33 |        0 |    83.33 |                |\n  index.js                          |    81.25 |    33.33 |        0 |      100 |           7,10 |\n  logger.js                         |       40 |      100 |        0 |       40 |         4,9,13 |\n------------------------------------|----------|----------|----------|----------|----------------|\n```","slug":"weekly-3","published":1,"updated":"2017-07-12T15:54:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5db41ix000b81txsyyz52hc","content":"<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><ul>\n<li><p><a href=\"https://juejin.im/post/59278e312f301e006c2e1510\" target=\"_blank\" rel=\"external\">JavaScript系列</a><br>相信作为“前端程序猿(媛)”的你一定了解作用域、原型、原型链、继承、闭包……在前端框架的盛行之下，却让初学者忽略了JS基础的学习，但基础不稳必然限制你的发展空间，当你了解了底层，就能很轻松明白框架的原理。</p>\n</li>\n<li><p><a href=\"https://juejin.im/post/57dcd394a22b9d00610c5ec8\" target=\"_blank\" rel=\"external\">排序算法</a><br>什么？在这个“用数据说话”的时代，你不懂排序算法？那你算什么男人~算什么男人~ 不对不对 算什么猿人~算什么猿人…咳咳，言归正传，平时开发我们常用的快速排序、冒泡排序、选择排序你是否了解其利弊。除此之外还有什么排序算法呢？快来一起学习吧。</p>\n</li>\n<li><p><a href=\"http://es6.ruanyifeng.com/#docs/iterator\" target=\"_blank\" rel=\"external\">Iterator 遍历器</a><br>Iterator为各种不同的数据结构提供了统一的访问机制。它可以提供统一的、简便的接口，使得数据结构的成员按某种次序排列，而es6新增for…of循环，就是由Iterator接口提供消费的。</p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2017/06/tcp-protocol.html\" target=\"_blank\" rel=\"external\">TCP协议简介</a><br>TCP作为互联网核心协议之一，“三次握手”“四次挥手”你是否有所了解？快来完善自己的知识体系吧。<br>ps:详解请参考<a href=\"http://www.jianshu.com/p/ef892323e68f\" target=\"_blank\" rel=\"external\">这里</a></p>\n</li>\n<li><p><a href=\"http://www.jianshu.com/p/e7bb97218946\" target=\"_blank\" rel=\"external\">正则表达式</a><br>业务中有很多复杂的逻辑判断？常常嵌套多个if？快来这里学习下吧，熟练掌握正则表达式会使得你的开发效率得到极大提升。</p>\n</li>\n</ul>\n<h2 id=\"资源整理\"><a href=\"#资源整理\" class=\"headerlink\" title=\"资源整理\"></a>资源整理</h2><ul>\n<li><a href=\"https://github.com/Wscats/Good-text-Share\" target=\"_blank\" rel=\"external\">前端知识点大百科全书</a></li>\n<li><a href=\"http://www.jianshu.com/p/c3dae0951f74\" target=\"_blank\" rel=\"external\">前端资源汇集</a><br>如此之全的知识整理、资源汇集，都掌握的话你可以神挡杀神佛挡杀佛了。</li>\n</ul>\n<h2 id=\"文章\"><a href=\"#文章\" class=\"headerlink\" title=\"文章\"></a>文章</h2><ul>\n<li><p><a href=\"https://juejin.im/post/58e3a5a0a0bb9f0069fc16bb\" target=\"_blank\" rel=\"external\">一劳永逸的搞定flex布局</a><br>你是否还在使用浮动布局？写各种line-height实现居中？不妨试试flexBox布局，它简单易用的写法可以轻松实现各种布局，让你的布局更快速高效。</p>\n</li>\n<li><p><a href=\"https://segmentfault.com/a/1190000010014281\" target=\"_blank\" rel=\"external\">Vue的数据依赖实现原理简析</a><br>主要从初始化的数据层面上分析了Vue是如何管理依赖来到达数据的动态响应。<br>initState的过程中，将props,computed,data等属性通过Object.defineProperty来改造其getter/setter属性，并为每一个响应式属性实例化一个observer观察者。这个observer内部dep记录了这个响应式属性的所有依赖。<br>当响应式属性调用setter函数时，通过dep.notify()方法去遍历所有的依赖，调用watcher.update()去完成数据的动态响应。</p>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzIyNjE4NjI2Nw==&amp;mid=2652558943&amp;idx=1&amp;sn=1516afcf876b9fb4a17ce048c5ade58d\" target=\"_blank\" rel=\"external\">靠谱程序员必备技能——重构</a><br>当项目变得难以维护，重构便便迫在眉睫，但很多所谓重构仅仅算是重写，随着时间推移，项目再次变得难以维护，周而复始，陷入怪圈。如何避免重构变成重写，本文给了一些很好的建议。</p>\n</li>\n<li><p><a href=\"https://zhuanlan.zhihu.com/p/27659059\" target=\"_blank\" rel=\"external\">我接触过的前端数据结构与算法</a><br>只要是工程师就必须学好计算机基础，只有这样才能适应计算机技术的快速发展，前端工程师更是如此。</p>\n</li>\n<li><p><a href=\"https://yeaseonzhang.github.io/2017/03/16/Vuex-%E9%80%9A%E4%BF%97%E7%89%88/\" target=\"_blank\" rel=\"external\">Vuex 通俗版教程</a><br>Vuex 类似 Redux 的状态管理器，用来管理Vue的所有组件状态。<br>一般在你开发大型单页应用（SPA），会出现多个视图组件依赖同一个状态，来自不同视图的行为需要变更同一个状态。<br>遇到以上情况时候，可以考虑使用Vuex，它能把组件的共享状态抽取出来，当做一个全局单例模式进行管理。这样不管你在何处改变状态，都会通知使用该状态的组件做出相应修改。</p>\n</li>\n<li><p><a href=\"https://stffe.github.io/vue/2017/03/03/%E5%AD%A6%E4%B9%A0Vue%E6%BA%90%E7%A0%81.html\" target=\"_blank\" rel=\"external\">学习Vue.js源码</a><br>文中介绍了vue项目目录结构和数据绑定实现，没有太深入，但可以作为初步了解。</p>\n</li>\n<li><p><a href=\"https://segmentfault.com/a/1190000009985489#articleHeader9\" target=\"_blank\" rel=\"external\">GitHub —— 你不得不上的交友网站</a><br>文章整理了GitHub入门，搭建发布个人博客及个人项目发布，还介绍了一些工具，插件及开源项目；内容比较丰富。</p>\n</li>\n<li><p><a href=\"http://meiminjun.github.io/import%E5%92%8Cexport%E7%AC%94%E8%AE%B0/\" target=\"_blank\" rel=\"external\">彻底搞清楚javascript中的require、import和export</a><br>通过介绍CMD、AMD、ES6的模块规范，来引申出平时业务中经常用到require、import和export的用法以及含义。</p>\n</li>\n<li><p><a href=\"https://github.com/istanbuljs/nyc\" target=\"_blank\" rel=\"external\">工具推荐</a><br>覆盖率工具 istanbul 替换为 nyc，多进程覆盖率的测试速度提升了几倍。都是同一作者的作品，后者目前活跃度高，并支持前端很多新特性。</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm i nyc --save-dev</div><div class=\"line\">$ ./node_modules/.bin/nyc ./node_modules/.bin/mocha</div></pre></td></tr></table></figure>\n<p>执行单元测试命令后，还会直观的给出代码覆盖率报告，以<a href=\"http://flcloverjs.org/\" target=\"_blank\" rel=\"external\">Flclover</a>为例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">------------------------------------|----------|----------|----------|----------|----------------|</div><div class=\"line\">File                                |  % Stmts | % Branch |  % Funcs |  % Lines |Uncovered Lines |</div><div class=\"line\">------------------------------------|----------|----------|----------|----------|----------------|</div><div class=\"line\">All files                           |    79.41 |    66.67 |    61.11 |    81.82 |                |</div><div class=\"line\"> flclover                           |      100 |      100 |      100 |      100 |                |</div><div class=\"line\">  index.js                          |      100 |      100 |      100 |      100 |                |</div><div class=\"line\"> flclover/lib                       |    88.52 |    82.35 |    81.82 |    88.52 |                |</div><div class=\"line\">  application.js                    |      100 |      100 |      100 |      100 |                |</div><div class=\"line\">  flclover.js                       |       30 |        0 |        0 |       30 |... 13,14,17,19 |</div><div class=\"line\"> flclover/lib/middleware/bodyparser |      100 |      100 |      100 |      100 |                |</div><div class=\"line\">  index.js                          |      100 |      100 |      100 |      100 |                |</div><div class=\"line\"> flclover/lib/middleware/logger     |    55.56 |       50 |       50 |    55.56 |                |</div><div class=\"line\">  index.js                          |    55.56 |       50 |       50 |    55.56 |... 39,42,45,48 |</div><div class=\"line\"> flclover/lib/utils                 |    71.43 |    33.33 |        0 |    83.33 |                |</div><div class=\"line\">  index.js                          |    81.25 |    33.33 |        0 |      100 |           7,10 |</div><div class=\"line\">  logger.js                         |       40 |      100 |        0 |       40 |         4,9,13 |</div><div class=\"line\">------------------------------------|----------|----------|----------|----------|----------------|</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><ul>\n<li><p><a href=\"https://juejin.im/post/59278e312f301e006c2e1510\" target=\"_blank\" rel=\"external\">JavaScript系列</a><br>相信作为“前端程序猿(媛)”的你一定了解作用域、原型、原型链、继承、闭包……在前端框架的盛行之下，却让初学者忽略了JS基础的学习，但基础不稳必然限制你的发展空间，当你了解了底层，就能很轻松明白框架的原理。</p>\n</li>\n<li><p><a href=\"https://juejin.im/post/57dcd394a22b9d00610c5ec8\" target=\"_blank\" rel=\"external\">排序算法</a><br>什么？在这个“用数据说话”的时代，你不懂排序算法？那你算什么男人~算什么男人~ 不对不对 算什么猿人~算什么猿人…咳咳，言归正传，平时开发我们常用的快速排序、冒泡排序、选择排序你是否了解其利弊。除此之外还有什么排序算法呢？快来一起学习吧。</p>\n</li>\n<li><p><a href=\"http://es6.ruanyifeng.com/#docs/iterator\" target=\"_blank\" rel=\"external\">Iterator 遍历器</a><br>Iterator为各种不同的数据结构提供了统一的访问机制。它可以提供统一的、简便的接口，使得数据结构的成员按某种次序排列，而es6新增for…of循环，就是由Iterator接口提供消费的。</p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2017/06/tcp-protocol.html\" target=\"_blank\" rel=\"external\">TCP协议简介</a><br>TCP作为互联网核心协议之一，“三次握手”“四次挥手”你是否有所了解？快来完善自己的知识体系吧。<br>ps:详解请参考<a href=\"http://www.jianshu.com/p/ef892323e68f\" target=\"_blank\" rel=\"external\">这里</a></p>\n</li>\n<li><p><a href=\"http://www.jianshu.com/p/e7bb97218946\" target=\"_blank\" rel=\"external\">正则表达式</a><br>业务中有很多复杂的逻辑判断？常常嵌套多个if？快来这里学习下吧，熟练掌握正则表达式会使得你的开发效率得到极大提升。</p>\n</li>\n</ul>\n<h2 id=\"资源整理\"><a href=\"#资源整理\" class=\"headerlink\" title=\"资源整理\"></a>资源整理</h2><ul>\n<li><a href=\"https://github.com/Wscats/Good-text-Share\" target=\"_blank\" rel=\"external\">前端知识点大百科全书</a></li>\n<li><a href=\"http://www.jianshu.com/p/c3dae0951f74\" target=\"_blank\" rel=\"external\">前端资源汇集</a><br>如此之全的知识整理、资源汇集，都掌握的话你可以神挡杀神佛挡杀佛了。</li>\n</ul>\n<h2 id=\"文章\"><a href=\"#文章\" class=\"headerlink\" title=\"文章\"></a>文章</h2><ul>\n<li><p><a href=\"https://juejin.im/post/58e3a5a0a0bb9f0069fc16bb\" target=\"_blank\" rel=\"external\">一劳永逸的搞定flex布局</a><br>你是否还在使用浮动布局？写各种line-height实现居中？不妨试试flexBox布局，它简单易用的写法可以轻松实现各种布局，让你的布局更快速高效。</p>\n</li>\n<li><p><a href=\"https://segmentfault.com/a/1190000010014281\" target=\"_blank\" rel=\"external\">Vue的数据依赖实现原理简析</a><br>主要从初始化的数据层面上分析了Vue是如何管理依赖来到达数据的动态响应。<br>initState的过程中，将props,computed,data等属性通过Object.defineProperty来改造其getter/setter属性，并为每一个响应式属性实例化一个observer观察者。这个observer内部dep记录了这个响应式属性的所有依赖。<br>当响应式属性调用setter函数时，通过dep.notify()方法去遍历所有的依赖，调用watcher.update()去完成数据的动态响应。</p>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzIyNjE4NjI2Nw==&amp;mid=2652558943&amp;idx=1&amp;sn=1516afcf876b9fb4a17ce048c5ade58d\" target=\"_blank\" rel=\"external\">靠谱程序员必备技能——重构</a><br>当项目变得难以维护，重构便便迫在眉睫，但很多所谓重构仅仅算是重写，随着时间推移，项目再次变得难以维护，周而复始，陷入怪圈。如何避免重构变成重写，本文给了一些很好的建议。</p>\n</li>\n<li><p><a href=\"https://zhuanlan.zhihu.com/p/27659059\" target=\"_blank\" rel=\"external\">我接触过的前端数据结构与算法</a><br>只要是工程师就必须学好计算机基础，只有这样才能适应计算机技术的快速发展，前端工程师更是如此。</p>\n</li>\n<li><p><a href=\"https://yeaseonzhang.github.io/2017/03/16/Vuex-%E9%80%9A%E4%BF%97%E7%89%88/\" target=\"_blank\" rel=\"external\">Vuex 通俗版教程</a><br>Vuex 类似 Redux 的状态管理器，用来管理Vue的所有组件状态。<br>一般在你开发大型单页应用（SPA），会出现多个视图组件依赖同一个状态，来自不同视图的行为需要变更同一个状态。<br>遇到以上情况时候，可以考虑使用Vuex，它能把组件的共享状态抽取出来，当做一个全局单例模式进行管理。这样不管你在何处改变状态，都会通知使用该状态的组件做出相应修改。</p>\n</li>\n<li><p><a href=\"https://stffe.github.io/vue/2017/03/03/%E5%AD%A6%E4%B9%A0Vue%E6%BA%90%E7%A0%81.html\" target=\"_blank\" rel=\"external\">学习Vue.js源码</a><br>文中介绍了vue项目目录结构和数据绑定实现，没有太深入，但可以作为初步了解。</p>\n</li>\n<li><p><a href=\"https://segmentfault.com/a/1190000009985489#articleHeader9\" target=\"_blank\" rel=\"external\">GitHub —— 你不得不上的交友网站</a><br>文章整理了GitHub入门，搭建发布个人博客及个人项目发布，还介绍了一些工具，插件及开源项目；内容比较丰富。</p>\n</li>\n<li><p><a href=\"http://meiminjun.github.io/import%E5%92%8Cexport%E7%AC%94%E8%AE%B0/\" target=\"_blank\" rel=\"external\">彻底搞清楚javascript中的require、import和export</a><br>通过介绍CMD、AMD、ES6的模块规范，来引申出平时业务中经常用到require、import和export的用法以及含义。</p>\n</li>\n<li><p><a href=\"https://github.com/istanbuljs/nyc\" target=\"_blank\" rel=\"external\">工具推荐</a><br>覆盖率工具 istanbul 替换为 nyc，多进程覆盖率的测试速度提升了几倍。都是同一作者的作品，后者目前活跃度高，并支持前端很多新特性。</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm i nyc --save-dev</div><div class=\"line\">$ ./node_modules/.bin/nyc ./node_modules/.bin/mocha</div></pre></td></tr></table></figure>\n<p>执行单元测试命令后，还会直观的给出代码覆盖率报告，以<a href=\"http://flcloverjs.org/\" target=\"_blank\" rel=\"external\">Flclover</a>为例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">------------------------------------|----------|----------|----------|----------|----------------|</div><div class=\"line\">File                                |  % Stmts | % Branch |  % Funcs |  % Lines |Uncovered Lines |</div><div class=\"line\">------------------------------------|----------|----------|----------|----------|----------------|</div><div class=\"line\">All files                           |    79.41 |    66.67 |    61.11 |    81.82 |                |</div><div class=\"line\"> flclover                           |      100 |      100 |      100 |      100 |                |</div><div class=\"line\">  index.js                          |      100 |      100 |      100 |      100 |                |</div><div class=\"line\"> flclover/lib                       |    88.52 |    82.35 |    81.82 |    88.52 |                |</div><div class=\"line\">  application.js                    |      100 |      100 |      100 |      100 |                |</div><div class=\"line\">  flclover.js                       |       30 |        0 |        0 |       30 |... 13,14,17,19 |</div><div class=\"line\"> flclover/lib/middleware/bodyparser |      100 |      100 |      100 |      100 |                |</div><div class=\"line\">  index.js                          |      100 |      100 |      100 |      100 |                |</div><div class=\"line\"> flclover/lib/middleware/logger     |    55.56 |       50 |       50 |    55.56 |                |</div><div class=\"line\">  index.js                          |    55.56 |       50 |       50 |    55.56 |... 39,42,45,48 |</div><div class=\"line\"> flclover/lib/utils                 |    71.43 |    33.33 |        0 |    83.33 |                |</div><div class=\"line\">  index.js                          |    81.25 |    33.33 |        0 |      100 |           7,10 |</div><div class=\"line\">  logger.js                         |       40 |      100 |        0 |       40 |         4,9,13 |</div><div class=\"line\">------------------------------------|----------|----------|----------|----------|----------------|</div></pre></td></tr></table></figure></p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cj5db41ib000081txse2l5z2p","tag_id":"cj5db41ig000181txh704tmaw","_id":"cj5db41ii000481tx7icjnlei"},{"post_id":"cj5db41ib000081txse2l5z2p","tag_id":"cj5db41ii000281txwk8whszw","_id":"cj5db41ii000581tx1wvm5wy7"},{"post_id":"cj5db41ib000081txse2l5z2p","tag_id":"cj5db41ii000381txatfhc4of","_id":"cj5db41ii000681tx269prx9x"},{"post_id":"cj5db41ip000781tx6mi78k8u","tag_id":"cj5db41it000981txiyqsgeey","_id":"cj5db41j6000d81txm13ku7y7"},{"post_id":"cj5db41ip000781tx6mi78k8u","tag_id":"cj5db41ii000281txwk8whszw","_id":"cj5db41j6000e81txcap4kiqd"},{"post_id":"cj5db41ip000781tx6mi78k8u","tag_id":"cj5db41ii000381txatfhc4of","_id":"cj5db41j7000g81txs9p3udbh"},{"post_id":"cj5db41ir000881txzmq787h5","tag_id":"cj5db41it000981txiyqsgeey","_id":"cj5db41jb000l81txs6wxfqb6"},{"post_id":"cj5db41ir000881txzmq787h5","tag_id":"cj5db41j6000f81txh5w1xhxy","_id":"cj5db41jb000m81tx5jfcqk9a"},{"post_id":"cj5db41ir000881txzmq787h5","tag_id":"cj5db41j7000h81txt12vt78w","_id":"cj5db41jb000o81txodvvhudk"},{"post_id":"cj5db41ir000881txzmq787h5","tag_id":"cj5db41j9000i81txann6utle","_id":"cj5db41jc000p81tx5tws7ei7"},{"post_id":"cj5db41ir000881txzmq787h5","tag_id":"cj5db41j9000j81txi4krrmdw","_id":"cj5db41jc000r81txbhmkcbtq"},{"post_id":"cj5db41ix000b81txsyyz52hc","tag_id":"cj5db41it000981txiyqsgeey","_id":"cj5db41jf000u81tx2ec6pbhv"},{"post_id":"cj5db41ix000b81txsyyz52hc","tag_id":"cj5db41ja000k81tx9c6l43iz","_id":"cj5db41jf000v81txj3d0werd"},{"post_id":"cj5db41ix000b81txsyyz52hc","tag_id":"cj5db41jb000n81txkfnyf57r","_id":"cj5db41jf000w81txateejxnk"},{"post_id":"cj5db41ix000b81txsyyz52hc","tag_id":"cj5db41jc000q81txb5dokr72","_id":"cj5db41jf000x81txgu2cp3eg"},{"post_id":"cj5db41ix000b81txsyyz52hc","tag_id":"cj5db41jc000s81txtu9czkek","_id":"cj5db41jf000y81txkjo54i80"},{"post_id":"cj5db41ix000b81txsyyz52hc","tag_id":"cj5db41jd000t81txsex2hh9o","_id":"cj5db41jf000z81txz16gq1ft"}],"Tag":[{"name":"Event-Driven","_id":"cj5db41ig000181txh704tmaw"},{"name":"全栈","_id":"cj5db41ii000281txwk8whszw"},{"name":"Node","_id":"cj5db41ii000381txatfhc4of"},{"name":"weekly","_id":"cj5db41it000981txiyqsgeey"},{"name":"框架","_id":"cj5db41j6000f81txh5w1xhxy"},{"name":"测试","_id":"cj5db41j7000h81txt12vt78w"},{"name":"设计模式","_id":"cj5db41j9000i81txann6utle"},{"name":"three.js","_id":"cj5db41j9000j81txi4krrmdw"},{"name":"es6","_id":"cj5db41ja000k81tx9c6l43iz"},{"name":"vue","_id":"cj5db41jb000n81txkfnyf57r"},{"name":"算法","_id":"cj5db41jc000q81txb5dokr72"},{"name":"工具","_id":"cj5db41jc000s81txtu9czkek"},{"name":"必备技能","_id":"cj5db41jd000t81txsex2hh9o"}]}}