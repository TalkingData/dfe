{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/Hacker/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/images/icon-heart.svg","path":"images/icon-heart.svg","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/categories.styl","path":"css/components/categories.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/footer.styl","path":"css/components/footer.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/archive.styl","path":"css/components/archive.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/base/normalize.css","path":"css/base/normalize.css","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/article.styl","path":"css/components/article.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/header.styl","path":"css/components/header.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/icon.styl","path":"css/components/icon.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/layout.styl","path":"css/components/layout.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/pagination.styl","path":"css/components/pagination.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/responsive.styl","path":"css/components/responsive.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/syntax.styl","path":"css/components/syntax.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/tags.styl","path":"css/components/tags.styl","modified":1,"renderable":1}],"Cache":[{"_id":"themes/Hacker/.gitignore","hash":"803c06a7086b5817c03d2e8672da27bc56ba2bce","modified":1498192818000},{"_id":"themes/Hacker/README_zh-CN.md","hash":"d6c9200e96bb3633c3a84de169f91e6c34a5ea14","modified":1498192818000},{"_id":"themes/Hacker/README.md","hash":"71077f7bdebc6e8d36f763e715ec2d55ddca4141","modified":1498192818000},{"_id":"themes/Hacker/LICENSE","hash":"3127907a7623734f830e8c69ccee03b693bf993e","modified":1498192818000},{"_id":"themes/Hacker/_config.yml","hash":"5d8cc859c48024451a316c50ab16ba58702b062d","modified":1498192818000},{"_id":"source/_posts/weekly-2.md","hash":"40bd5d87fea2e892b52216d66d84efb47a0e9a3b","modified":1499140362000},{"_id":"source/_posts/weekly-3.md","hash":"78d8a48f1f24aa905127662fabf14e92a769cf28","modified":1499874885000},{"_id":"source/_posts/weekly-1.md","hash":"95f5d7afb0a322d85ea9589b92e8495d4408fa5c","modified":1498208484000},{"_id":"source/_posts/5-protocols-for-event-driven-api-architectures.md","hash":"8fc472d56a43aaa7ee1f935501969b469e717c19","modified":1500607722000},{"_id":"source/_posts/weekly-4.md","hash":"fda3d78cba035d916cc7887921adba94868e3142","modified":1502247016000},{"_id":"source/_posts/weekly-6.md","hash":"c5f0d19908864cf65cfbfd087e9bd40b9ea99066","modified":1502247016000},{"_id":"source/_posts/weekly-5.md","hash":"bd2bc2ed619a37c40ff6a8e9cee75d7691d8aed8","modified":1502247016000},{"_id":"source/_posts/weekly-9.md","hash":"98d79ec37a6d53f4f2be10aebeccdd957ddc78cc","modified":1503083415000},{"_id":"source/_posts/weekly-7.md","hash":"272ee8435dd57dcc471798cb2a728a0a70326b69","modified":1502247016000},{"_id":"source/_posts/weekly-8.md","hash":"e3dbc9d377538f3b6e3256b19205c074ec025b55","modified":1503083370000},{"_id":"themes/Hacker/layout/archive.ejs","hash":"2238cbe29009aafb16969d2c70dceb3f71772123","modified":1498192818000},{"_id":"themes/Hacker/languages/zh-CN.yml","hash":"18638177b944e0deb4a8c26a1c4a980901151132","modified":1498192818000},{"_id":"themes/Hacker/languages/default.yml","hash":"ef90548952b1f9cc88dbe9daad882786212aec38","modified":1498192818000},{"_id":"themes/Hacker/layout/categories.ejs","hash":"bfad4e7eade650c535f0194974e2646619657b8b","modified":1498192818000},{"_id":"themes/Hacker/layout/page.ejs","hash":"84e00bbcc643dff4bd02880b3bbea658f510835f","modified":1498192818000},{"_id":"themes/Hacker/layout/post.ejs","hash":"84e00bbcc643dff4bd02880b3bbea658f510835f","modified":1498192818000},{"_id":"themes/Hacker/layout/index.ejs","hash":"1d2c487a95d25e763b5f7e004194eb6ee6b18135","modified":1498192818000},{"_id":"themes/Hacker/layout/layout.ejs","hash":"341e77b5f07457e4ccd69634f511da05a5d89f18","modified":1498192818000},{"_id":"themes/Hacker/layout/tags.ejs","hash":"ee89e6a9c14bdb5e5e8cf975a558c780fe8dabff","modified":1498192818000},{"_id":"themes/Hacker/layout/components/archive.ejs","hash":"1f79ebaf52b8229cf5c58bb8325cf0177859a05c","modified":1498192818000},{"_id":"themes/Hacker/layout/components/article.ejs","hash":"5a08e05eb271589a2ed69fdd08516fa8457af3ed","modified":1498192818000},{"_id":"themes/Hacker/layout/components/comment.ejs","hash":"34b72f9819b5298be101f5c568cc7f2a52ab0f7d","modified":1498192818000},{"_id":"themes/Hacker/layout/components/categories.ejs","hash":"3665bf5d1c7181db22dc1c48d62ebf42757d8c27","modified":1498192818000},{"_id":"themes/Hacker/layout/components/googleanalytics.ejs","hash":"fa11251ace0fc61cbcffb74f32fbf5bdbb201ff2","modified":1498192818000},{"_id":"themes/Hacker/layout/components/head.ejs","hash":"10475fdfc513c9380f18d034e15b3b051c8e9269","modified":1498192818000},{"_id":"themes/Hacker/layout/components/header.ejs","hash":"929a8eafa278d49c2f41d3581e2608eca80d7856","modified":1498192818000},{"_id":"themes/Hacker/layout/components/footer.ejs","hash":"538795f4af3a98e824aefc4b68a1bcd210c091e9","modified":1498192818000},{"_id":"themes/Hacker/layout/components/pagination.ejs","hash":"4ab5e3b0239e467923a0f91c771bcc9ee7889cfe","modified":1498192818000},{"_id":"themes/Hacker/source/css/style.styl","hash":"208e5f6d010e4e2c5590dae5e4fca8de592d3ef1","modified":1498192818000},{"_id":"themes/Hacker/source/images/icon-heart.svg","hash":"ec483e96c88eea013fd8ac71a34a875107397f43","modified":1498192818000},{"_id":"themes/Hacker/source/css/components/categories.styl","hash":"c67e20d60351295cb178b568af42d430f4bcc3e6","modified":1498192818000},{"_id":"themes/Hacker/source/css/components/footer.styl","hash":"80ef890252d31d3bbfe71740fdcfc54ae14cad8e","modified":1498192818000},{"_id":"themes/Hacker/source/css/components/archive.styl","hash":"de701a1dee6e870140565044a08c2c45cfcd4bc3","modified":1498192818000},{"_id":"themes/Hacker/source/css/base/normalize.css","hash":"e58275a588bb631a37a2988145eea231ed23176b","modified":1498192818000},{"_id":"themes/Hacker/source/css/components/article.styl","hash":"e99f13c6744ddaa7f7bfcf0662e4dc6840fae8fa","modified":1498192818000},{"_id":"themes/Hacker/source/css/components/header.styl","hash":"fa5e6d715d288a327406df78225284c70530cb98","modified":1498192818000},{"_id":"themes/Hacker/source/css/components/icon.styl","hash":"8da3ff5b6cd1609fdfe0c564d47391367abc8808","modified":1498192818000},{"_id":"themes/Hacker/source/css/components/layout.styl","hash":"73c1688b95b20cd67669bc5567420f5be8448c9f","modified":1498192818000},{"_id":"themes/Hacker/source/css/components/pagination.styl","hash":"c20a9920bb444c22b20e588f97eba4e03f09a439","modified":1498192818000},{"_id":"themes/Hacker/source/css/components/responsive.styl","hash":"053e7ec4c22845422440660b7e1d6b0dea5b4fbd","modified":1498192818000},{"_id":"themes/Hacker/source/css/components/syntax.styl","hash":"68b7deadab1ac13603eb5e812e1060db25227fd0","modified":1498192818000},{"_id":"themes/Hacker/source/css/components/tags.styl","hash":"684cf4eb4b8671476365e955dceebf096cc0e6ed","modified":1498192818000},{"_id":"public/atom.xml","hash":"c7909502a89f42d48d5d3d38e376d6855fda58fa","modified":1503083427592},{"_id":"public/2017/08/18/weekly-9/index.html","hash":"f8577bfc395946e5d96e03a20780f6df77b74e92","modified":1503083427943},{"_id":"public/2017/08/11/weekly-8/index.html","hash":"74628cdc25d4a59f07cb5815fc43069a8d47ce9f","modified":1503083427943},{"_id":"public/2017/08/04/weekly-7/index.html","hash":"fe272ed7bb92e68f6ba8d930215238be7f55a3d2","modified":1503083427943},{"_id":"public/2017/07/28/weekly-6/index.html","hash":"835297506d4b514489cdd80cbe5677d9edab24af","modified":1503083427943},{"_id":"public/2017/07/21/weekly-5/index.html","hash":"4727d0d860d2d7672dc311c71f64a3310b28cab8","modified":1503083427943},{"_id":"public/2017/07/12/weekly-4/index.html","hash":"c2f872608fee6f45dc6a7cc44af8ec614052710a","modified":1503083427943},{"_id":"public/2017/07/07/weekly-3/index.html","hash":"c239e3df521a1a3638a4fa836cee6a867f9e1ccc","modified":1503083427943},{"_id":"public/2017/06/30/weekly-2/index.html","hash":"082a776021ca1a79e6fb18a98291fcae3374c002","modified":1503083427943},{"_id":"public/2017/06/23/weekly-1/index.html","hash":"5d6408e619fc1ff5a55183a54c56d7a8deda9847","modified":1503083427943},{"_id":"public/archives/index.html","hash":"d73e304f138887de5a4f2fc80b131aaae81484aa","modified":1503083427943},{"_id":"public/archives/2017/index.html","hash":"17c355907ca166f9fd016d4d427013663c503e8b","modified":1503083427943},{"_id":"public/archives/2017/06/index.html","hash":"7785b5c9683a43e2a518a46334eb2b281754f4c9","modified":1503083427943},{"_id":"public/archives/2017/07/index.html","hash":"21792816540c009fa10c7f5df0f897f54e06d1e1","modified":1503083427943},{"_id":"public/archives/2017/08/index.html","hash":"e2cf9ca08d79bdbad82e2f4cf53ca3e3cd60d2fb","modified":1503083427943},{"_id":"public/tags/weekly/index.html","hash":"ba5c96a81c14e3f78adaf8f0aeb05f1a2daa702f","modified":1503083427943},{"_id":"public/tags/es6/index.html","hash":"ffbbfb37d45e328bfb79c69cb7255ca94080ac11","modified":1503083427943},{"_id":"public/tags/vue/index.html","hash":"28973471229ccbfd3c465427c8b1f30a435371d1","modified":1503083427943},{"_id":"public/tags/算法/index.html","hash":"5e8368032ec5adafa4d248cde01b1335d7cf0b69","modified":1503083427943},{"_id":"public/tags/工具/index.html","hash":"305f3d9b6be547a80defa499f61113b6f079ee7f","modified":1503083427943},{"_id":"public/tags/必备技能/index.html","hash":"684462f6beaaddd81b145b65e0444a34ebd80751","modified":1503083427943},{"_id":"public/tags/框架/index.html","hash":"61e814f30817a502dc48b20d2d608d3710858ffd","modified":1503083427943},{"_id":"public/tags/测试/index.html","hash":"1f37df8698cc8cb466d7abefcd1b3b30a31b3378","modified":1503083427944},{"_id":"public/tags/设计模式/index.html","hash":"0f9935bc07ba9ed37445ecf2ecb802c6921a1fbb","modified":1503083427944},{"_id":"public/tags/three-js/index.html","hash":"0fca59241b8d42eb961313b92cc66ec780ff82e2","modified":1503083427944},{"_id":"public/tags/全栈/index.html","hash":"0feef4981a7047551224a9bc1a4d2f906eabfc00","modified":1503083427944},{"_id":"public/tags/Node/index.html","hash":"c9a9b992f9943d74820879a802e277aebb098545","modified":1503083427944},{"_id":"public/tags/Echarts/index.html","hash":"2cbf854fa90dad9cfc599d1d6db8ea955ef7c13b","modified":1503083427944},{"_id":"public/tags/ES6/index.html","hash":"5c08947f052f7d3295bbc998e5e0c8b92852ae9f","modified":1503083427944},{"_id":"public/tags/Vue/index.html","hash":"6e7652c6209b1138f1a651255fb2a85d6e6aa306","modified":1503083427944},{"_id":"public/tags/SVG/index.html","hash":"b88453367fdbc9fe75f9791d803fa62cc5135f68","modified":1503083427944},{"_id":"public/tags/模块化/index.html","hash":"0a1fc94e341354afff0a09f0a21bdd5992c7ac73","modified":1503083427944},{"_id":"public/tags/性能优化/index.html","hash":"d8ba83ac8db89b480574a776dc982a6baea46b80","modified":1503083427944},{"_id":"public/tags/Event-Driven/index.html","hash":"2c212f22711765e465768438d2da5b2262947e65","modified":1503083427944},{"_id":"public/tags/Vuex/index.html","hash":"1e3b580065953857a22bf734c4631d414bf82069","modified":1503083427944},{"_id":"public/tags/WebSocket/index.html","hash":"934dab82a40e7b713021f664f0cecf731c0ced95","modified":1503083427944},{"_id":"public/tags/node/index.html","hash":"2a68cf238fa2e475c2277f264c588120f9bff726","modified":1503083427944},{"_id":"public/tags/http/index.html","hash":"fa834e9a86a8c75fe538659f78c9f55fb39491b5","modified":1503083427944},{"_id":"public/tags/iView/index.html","hash":"8339e347ff5e47417a5c7808cf41d215b3fd5d77","modified":1503083427945},{"_id":"public/tags/Git/index.html","hash":"d80a3fd18610c990279d6f68191ac4a4f49932a3","modified":1503083427945},{"_id":"public/tags/Zepto/index.html","hash":"ceb74ee5844473ae4634fca8222f4ba3103d7af3","modified":1503083427945},{"_id":"public/tags/事件驱动/index.html","hash":"c3b0e9e60e72d617dbeea16aa2ab71f83d178d53","modified":1503083427945},{"_id":"public/tags/工程化实践/index.html","hash":"5c54669a5b53c85030ba2fd715fcf8a1a5aa2b6f","modified":1503083427945},{"_id":"public/tags/Webpack/index.html","hash":"8b67b62707dba754f87486c2361bf12bb510a860","modified":1503083427945},{"_id":"public/tags/PWA/index.html","hash":"40f13c4c80188d27c3dbb8595860cdbbabce53da","modified":1503083427945},{"_id":"public/tags/持续部署/index.html","hash":"5d907fa8bf105dce7cb98332e7fcc755d89e4c7c","modified":1503083427945},{"_id":"public/tags/模块/index.html","hash":"8ec4455a132426fbd15f696c58673b411df42d49","modified":1503083427945},{"_id":"public/tags/函数式/index.html","hash":"f7c91fecb3f54a2f2e4d2a0397a774520aab3a46","modified":1503083427945},{"_id":"public/tags/API设计，单元测试/index.html","hash":"97a4b4c510f420bec0b5e0964ad6f24b147b4c19","modified":1503083427945},{"_id":"public/2017/07/21/5-protocols-for-event-driven-api-architectures/index.html","hash":"32858b5d45d09f20b922478f07b856508e27df13","modified":1503083427945},{"_id":"public/index.html","hash":"e116e0f01d4bd4b9317d75df1bec0334057404a6","modified":1503083427945},{"_id":"public/images/icon-heart.svg","hash":"ec483e96c88eea013fd8ac71a34a875107397f43","modified":1503083427948},{"_id":"public/css/components/categories.css","hash":"f181d27640f1408f032c5386836c4c2322724f8d","modified":1503083428417},{"_id":"public/css/components/footer.css","hash":"602def895fd52f288b6e93932284aa2e52b7fee0","modified":1503083428417},{"_id":"public/css/base/normalize.css","hash":"e58275a588bb631a37a2988145eea231ed23176b","modified":1503083428417},{"_id":"public/css/components/archive.css","hash":"14902abf01556a3e23e03ac18c87fa7a5a39d89a","modified":1503083428417},{"_id":"public/css/components/article.css","hash":"563b6fd19e1f5ba4787acd2ef2e1ee876e521cab","modified":1503083428417},{"_id":"public/css/components/header.css","hash":"51f8a4c736f3b180a7c4c8f804d8060031df6a34","modified":1503083428417},{"_id":"public/css/components/icon.css","hash":"cdaf1a152184ff7def760f14095e4a2fa16cd6bd","modified":1503083428417},{"_id":"public/css/components/layout.css","hash":"b8625c7b90a973f2e37897f346e6f80b779fd9ca","modified":1503083428417},{"_id":"public/css/components/responsive.css","hash":"216eb94fc69007de995fc8d382670ba00a9574e8","modified":1503083428417},{"_id":"public/css/components/pagination.css","hash":"2f3f9bb1bc6513d08865e7a2fb2160cc47d4a229","modified":1503083428418},{"_id":"public/css/components/syntax.css","hash":"00970bfdb168aa13622c829920907ca3416829f8","modified":1503083428418},{"_id":"public/css/components/tags.css","hash":"1566e94c23ae19dbfc7d2cf433e68242ed657dea","modified":1503083428418},{"_id":"public/css/style.css","hash":"48373889a036d403ca34bc085cabeb302e2a08ee","modified":1503083428418}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"大前端周刊 第三期 （本期小编：李志伟）","date":"2017-07-07T05:10:51.000Z","_content":"\n## 基础\n* [JavaScript系列](https://juejin.im/post/59278e312f301e006c2e1510)\n相信作为“前端程序猿(媛)”的你一定了解作用域、原型、原型链、继承、闭包……在前端框架的盛行之下，却让初学者忽略了JS基础的学习，但基础不稳必然限制你的发展空间，当你了解了底层，就能很轻松明白框架的原理。\n\n* [排序算法](https://juejin.im/post/57dcd394a22b9d00610c5ec8)\n什么？在这个“用数据说话”的时代，你不懂排序算法？那你算什么男人~算什么男人~ 不对不对 算什么猿人~算什么猿人...咳咳，言归正传，平时开发我们常用的快速排序、冒泡排序、选择排序你是否了解其利弊。除此之外还有什么排序算法呢？快来一起学习吧。\n\n* [Iterator 遍历器](http://es6.ruanyifeng.com/#docs/iterator)\nIterator为各种不同的数据结构提供了统一的访问机制。它可以提供统一的、简便的接口，使得数据结构的成员按某种次序排列，而es6新增for...of循环，就是由Iterator接口提供消费的。\n\n* [TCP协议简介](http://www.ruanyifeng.com/blog/2017/06/tcp-protocol.html)\nTCP作为互联网核心协议之一，“三次握手”“四次挥手”你是否有所了解？快来完善自己的知识体系吧。\nps:详解请参考[这里](http://www.jianshu.com/p/ef892323e68f)\n\n* [正则表达式](http://www.jianshu.com/p/e7bb97218946)\n业务中有很多复杂的逻辑判断？常常嵌套多个if？快来这里学习下吧，熟练掌握正则表达式会使得你的开发效率得到极大提升。\n\n## 资源整理\n* [前端知识点大百科全书](https://github.com/Wscats/Good-text-Share)\n* [前端资源汇集](http://www.jianshu.com/p/c3dae0951f74)\n如此之全的知识整理、资源汇集，都掌握的话你可以神挡杀神佛挡杀佛了。\n\n## 文章\n\n* [一劳永逸的搞定flex布局](https://juejin.im/post/58e3a5a0a0bb9f0069fc16bb)\n你是否还在使用浮动布局？写各种line-height实现居中？不妨试试flexBox布局，它简单易用的写法可以轻松实现各种布局，让你的布局更快速高效。\n\n* [Vue的数据依赖实现原理简析](https://segmentfault.com/a/1190000010014281)\n主要从初始化的数据层面上分析了Vue是如何管理依赖来到达数据的动态响应。\ninitState的过程中，将props,computed,data等属性通过Object.defineProperty来改造其getter/setter属性，并为每一个响应式属性实例化一个observer观察者。这个observer内部dep记录了这个响应式属性的所有依赖。\n当响应式属性调用setter函数时，通过dep.notify()方法去遍历所有的依赖，调用watcher.update()去完成数据的动态响应。\n\n* [靠谱程序员必备技能——重构](https://mp.weixin.qq.com/s?__biz=MzIyNjE4NjI2Nw==&mid=2652558943&idx=1&sn=1516afcf876b9fb4a17ce048c5ade58d)\n当项目变得难以维护，重构便便迫在眉睫，但很多所谓重构仅仅算是重写，随着时间推移，项目再次变得难以维护，周而复始，陷入怪圈。如何避免重构变成重写，本文给了一些很好的建议。\n\n* [我接触过的前端数据结构与算法](https://zhuanlan.zhihu.com/p/27659059)\n只要是工程师就必须学好计算机基础，只有这样才能适应计算机技术的快速发展，前端工程师更是如此。\n\n* [Vuex 通俗版教程](https://yeaseonzhang.github.io/2017/03/16/Vuex-%E9%80%9A%E4%BF%97%E7%89%88/)\nVuex 类似 Redux 的状态管理器，用来管理Vue的所有组件状态。\n一般在你开发大型单页应用（SPA），会出现多个视图组件依赖同一个状态，来自不同视图的行为需要变更同一个状态。\n遇到以上情况时候，可以考虑使用Vuex，它能把组件的共享状态抽取出来，当做一个全局单例模式进行管理。这样不管你在何处改变状态，都会通知使用该状态的组件做出相应修改。\n\n* [学习Vue.js源码](https://stffe.github.io/vue/2017/03/03/%E5%AD%A6%E4%B9%A0Vue%E6%BA%90%E7%A0%81.html)\n文中介绍了vue项目目录结构和数据绑定实现，没有太深入，但可以作为初步了解。\n\n* [GitHub —— 你不得不上的交友网站](https://segmentfault.com/a/1190000009985489#articleHeader9)\n文章整理了GitHub入门，搭建发布个人博客及个人项目发布，还介绍了一些工具，插件及开源项目；内容比较丰富。\n\n* [彻底搞清楚javascript中的require、import和export](http://meiminjun.github.io/import%E5%92%8Cexport%E7%AC%94%E8%AE%B0/)\n通过介绍CMD、AMD、ES6的模块规范，来引申出平时业务中经常用到require、import和export的用法以及含义。\n\n* [工具推荐](https://github.com/istanbuljs/nyc)\n覆盖率工具 istanbul 替换为 nyc，多进程覆盖率的测试速度提升了几倍。都是同一作者的作品，后者目前活跃度高，并支持前端很多新特性。\n\n```\n$ npm i nyc --save-dev\n$ ./node_modules/.bin/nyc ./node_modules/.bin/mocha\n```\n执行单元测试命令后，还会直观的给出代码覆盖率报告，以[Flclover](http://flcloverjs.org/)为例：\n```\n------------------------------------|----------|----------|----------|----------|----------------|\nFile                                |  % Stmts | % Branch |  % Funcs |  % Lines |Uncovered Lines |\n------------------------------------|----------|----------|----------|----------|----------------|\nAll files                           |    79.41 |    66.67 |    61.11 |    81.82 |                |\n flclover                           |      100 |      100 |      100 |      100 |                |\n  index.js                          |      100 |      100 |      100 |      100 |                |\n flclover/lib                       |    88.52 |    82.35 |    81.82 |    88.52 |                |\n  application.js                    |      100 |      100 |      100 |      100 |                |\n  flclover.js                       |       30 |        0 |        0 |       30 |... 13,14,17,19 |\n flclover/lib/middleware/bodyparser |      100 |      100 |      100 |      100 |                |\n  index.js                          |      100 |      100 |      100 |      100 |                |\n flclover/lib/middleware/logger     |    55.56 |       50 |       50 |    55.56 |                |\n  index.js                          |    55.56 |       50 |       50 |    55.56 |... 39,42,45,48 |\n flclover/lib/utils                 |    71.43 |    33.33 |        0 |    83.33 |                |\n  index.js                          |    81.25 |    33.33 |        0 |      100 |           7,10 |\n  logger.js                         |       40 |      100 |        0 |       40 |         4,9,13 |\n------------------------------------|----------|----------|----------|----------|----------------|\n```","source":"_posts/weekly-3.md","raw":"---\ntitle: 大前端周刊 第三期 （本期小编：李志伟）\ndate: 2017-07-07 13:10:51\ntags: [weekly,es6,vue,算法,工具,必备技能]\n---\n\n## 基础\n* [JavaScript系列](https://juejin.im/post/59278e312f301e006c2e1510)\n相信作为“前端程序猿(媛)”的你一定了解作用域、原型、原型链、继承、闭包……在前端框架的盛行之下，却让初学者忽略了JS基础的学习，但基础不稳必然限制你的发展空间，当你了解了底层，就能很轻松明白框架的原理。\n\n* [排序算法](https://juejin.im/post/57dcd394a22b9d00610c5ec8)\n什么？在这个“用数据说话”的时代，你不懂排序算法？那你算什么男人~算什么男人~ 不对不对 算什么猿人~算什么猿人...咳咳，言归正传，平时开发我们常用的快速排序、冒泡排序、选择排序你是否了解其利弊。除此之外还有什么排序算法呢？快来一起学习吧。\n\n* [Iterator 遍历器](http://es6.ruanyifeng.com/#docs/iterator)\nIterator为各种不同的数据结构提供了统一的访问机制。它可以提供统一的、简便的接口，使得数据结构的成员按某种次序排列，而es6新增for...of循环，就是由Iterator接口提供消费的。\n\n* [TCP协议简介](http://www.ruanyifeng.com/blog/2017/06/tcp-protocol.html)\nTCP作为互联网核心协议之一，“三次握手”“四次挥手”你是否有所了解？快来完善自己的知识体系吧。\nps:详解请参考[这里](http://www.jianshu.com/p/ef892323e68f)\n\n* [正则表达式](http://www.jianshu.com/p/e7bb97218946)\n业务中有很多复杂的逻辑判断？常常嵌套多个if？快来这里学习下吧，熟练掌握正则表达式会使得你的开发效率得到极大提升。\n\n## 资源整理\n* [前端知识点大百科全书](https://github.com/Wscats/Good-text-Share)\n* [前端资源汇集](http://www.jianshu.com/p/c3dae0951f74)\n如此之全的知识整理、资源汇集，都掌握的话你可以神挡杀神佛挡杀佛了。\n\n## 文章\n\n* [一劳永逸的搞定flex布局](https://juejin.im/post/58e3a5a0a0bb9f0069fc16bb)\n你是否还在使用浮动布局？写各种line-height实现居中？不妨试试flexBox布局，它简单易用的写法可以轻松实现各种布局，让你的布局更快速高效。\n\n* [Vue的数据依赖实现原理简析](https://segmentfault.com/a/1190000010014281)\n主要从初始化的数据层面上分析了Vue是如何管理依赖来到达数据的动态响应。\ninitState的过程中，将props,computed,data等属性通过Object.defineProperty来改造其getter/setter属性，并为每一个响应式属性实例化一个observer观察者。这个observer内部dep记录了这个响应式属性的所有依赖。\n当响应式属性调用setter函数时，通过dep.notify()方法去遍历所有的依赖，调用watcher.update()去完成数据的动态响应。\n\n* [靠谱程序员必备技能——重构](https://mp.weixin.qq.com/s?__biz=MzIyNjE4NjI2Nw==&mid=2652558943&idx=1&sn=1516afcf876b9fb4a17ce048c5ade58d)\n当项目变得难以维护，重构便便迫在眉睫，但很多所谓重构仅仅算是重写，随着时间推移，项目再次变得难以维护，周而复始，陷入怪圈。如何避免重构变成重写，本文给了一些很好的建议。\n\n* [我接触过的前端数据结构与算法](https://zhuanlan.zhihu.com/p/27659059)\n只要是工程师就必须学好计算机基础，只有这样才能适应计算机技术的快速发展，前端工程师更是如此。\n\n* [Vuex 通俗版教程](https://yeaseonzhang.github.io/2017/03/16/Vuex-%E9%80%9A%E4%BF%97%E7%89%88/)\nVuex 类似 Redux 的状态管理器，用来管理Vue的所有组件状态。\n一般在你开发大型单页应用（SPA），会出现多个视图组件依赖同一个状态，来自不同视图的行为需要变更同一个状态。\n遇到以上情况时候，可以考虑使用Vuex，它能把组件的共享状态抽取出来，当做一个全局单例模式进行管理。这样不管你在何处改变状态，都会通知使用该状态的组件做出相应修改。\n\n* [学习Vue.js源码](https://stffe.github.io/vue/2017/03/03/%E5%AD%A6%E4%B9%A0Vue%E6%BA%90%E7%A0%81.html)\n文中介绍了vue项目目录结构和数据绑定实现，没有太深入，但可以作为初步了解。\n\n* [GitHub —— 你不得不上的交友网站](https://segmentfault.com/a/1190000009985489#articleHeader9)\n文章整理了GitHub入门，搭建发布个人博客及个人项目发布，还介绍了一些工具，插件及开源项目；内容比较丰富。\n\n* [彻底搞清楚javascript中的require、import和export](http://meiminjun.github.io/import%E5%92%8Cexport%E7%AC%94%E8%AE%B0/)\n通过介绍CMD、AMD、ES6的模块规范，来引申出平时业务中经常用到require、import和export的用法以及含义。\n\n* [工具推荐](https://github.com/istanbuljs/nyc)\n覆盖率工具 istanbul 替换为 nyc，多进程覆盖率的测试速度提升了几倍。都是同一作者的作品，后者目前活跃度高，并支持前端很多新特性。\n\n```\n$ npm i nyc --save-dev\n$ ./node_modules/.bin/nyc ./node_modules/.bin/mocha\n```\n执行单元测试命令后，还会直观的给出代码覆盖率报告，以[Flclover](http://flcloverjs.org/)为例：\n```\n------------------------------------|----------|----------|----------|----------|----------------|\nFile                                |  % Stmts | % Branch |  % Funcs |  % Lines |Uncovered Lines |\n------------------------------------|----------|----------|----------|----------|----------------|\nAll files                           |    79.41 |    66.67 |    61.11 |    81.82 |                |\n flclover                           |      100 |      100 |      100 |      100 |                |\n  index.js                          |      100 |      100 |      100 |      100 |                |\n flclover/lib                       |    88.52 |    82.35 |    81.82 |    88.52 |                |\n  application.js                    |      100 |      100 |      100 |      100 |                |\n  flclover.js                       |       30 |        0 |        0 |       30 |... 13,14,17,19 |\n flclover/lib/middleware/bodyparser |      100 |      100 |      100 |      100 |                |\n  index.js                          |      100 |      100 |      100 |      100 |                |\n flclover/lib/middleware/logger     |    55.56 |       50 |       50 |    55.56 |                |\n  index.js                          |    55.56 |       50 |       50 |    55.56 |... 39,42,45,48 |\n flclover/lib/utils                 |    71.43 |    33.33 |        0 |    83.33 |                |\n  index.js                          |    81.25 |    33.33 |        0 |      100 |           7,10 |\n  logger.js                         |       40 |      100 |        0 |       40 |         4,9,13 |\n------------------------------------|----------|----------|----------|----------|----------------|\n```","slug":"weekly-3","published":1,"updated":"2017-07-12T15:54:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6i92auf0000e1txl53kbr1t","content":"<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><ul>\n<li><p><a href=\"https://juejin.im/post/59278e312f301e006c2e1510\" target=\"_blank\" rel=\"external\">JavaScript系列</a><br>相信作为“前端程序猿(媛)”的你一定了解作用域、原型、原型链、继承、闭包……在前端框架的盛行之下，却让初学者忽略了JS基础的学习，但基础不稳必然限制你的发展空间，当你了解了底层，就能很轻松明白框架的原理。</p>\n</li>\n<li><p><a href=\"https://juejin.im/post/57dcd394a22b9d00610c5ec8\" target=\"_blank\" rel=\"external\">排序算法</a><br>什么？在这个“用数据说话”的时代，你不懂排序算法？那你算什么男人~算什么男人~ 不对不对 算什么猿人~算什么猿人…咳咳，言归正传，平时开发我们常用的快速排序、冒泡排序、选择排序你是否了解其利弊。除此之外还有什么排序算法呢？快来一起学习吧。</p>\n</li>\n<li><p><a href=\"http://es6.ruanyifeng.com/#docs/iterator\" target=\"_blank\" rel=\"external\">Iterator 遍历器</a><br>Iterator为各种不同的数据结构提供了统一的访问机制。它可以提供统一的、简便的接口，使得数据结构的成员按某种次序排列，而es6新增for…of循环，就是由Iterator接口提供消费的。</p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2017/06/tcp-protocol.html\" target=\"_blank\" rel=\"external\">TCP协议简介</a><br>TCP作为互联网核心协议之一，“三次握手”“四次挥手”你是否有所了解？快来完善自己的知识体系吧。<br>ps:详解请参考<a href=\"http://www.jianshu.com/p/ef892323e68f\" target=\"_blank\" rel=\"external\">这里</a></p>\n</li>\n<li><p><a href=\"http://www.jianshu.com/p/e7bb97218946\" target=\"_blank\" rel=\"external\">正则表达式</a><br>业务中有很多复杂的逻辑判断？常常嵌套多个if？快来这里学习下吧，熟练掌握正则表达式会使得你的开发效率得到极大提升。</p>\n</li>\n</ul>\n<h2 id=\"资源整理\"><a href=\"#资源整理\" class=\"headerlink\" title=\"资源整理\"></a>资源整理</h2><ul>\n<li><a href=\"https://github.com/Wscats/Good-text-Share\" target=\"_blank\" rel=\"external\">前端知识点大百科全书</a></li>\n<li><a href=\"http://www.jianshu.com/p/c3dae0951f74\" target=\"_blank\" rel=\"external\">前端资源汇集</a><br>如此之全的知识整理、资源汇集，都掌握的话你可以神挡杀神佛挡杀佛了。</li>\n</ul>\n<h2 id=\"文章\"><a href=\"#文章\" class=\"headerlink\" title=\"文章\"></a>文章</h2><ul>\n<li><p><a href=\"https://juejin.im/post/58e3a5a0a0bb9f0069fc16bb\" target=\"_blank\" rel=\"external\">一劳永逸的搞定flex布局</a><br>你是否还在使用浮动布局？写各种line-height实现居中？不妨试试flexBox布局，它简单易用的写法可以轻松实现各种布局，让你的布局更快速高效。</p>\n</li>\n<li><p><a href=\"https://segmentfault.com/a/1190000010014281\" target=\"_blank\" rel=\"external\">Vue的数据依赖实现原理简析</a><br>主要从初始化的数据层面上分析了Vue是如何管理依赖来到达数据的动态响应。<br>initState的过程中，将props,computed,data等属性通过Object.defineProperty来改造其getter/setter属性，并为每一个响应式属性实例化一个observer观察者。这个observer内部dep记录了这个响应式属性的所有依赖。<br>当响应式属性调用setter函数时，通过dep.notify()方法去遍历所有的依赖，调用watcher.update()去完成数据的动态响应。</p>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzIyNjE4NjI2Nw==&amp;mid=2652558943&amp;idx=1&amp;sn=1516afcf876b9fb4a17ce048c5ade58d\" target=\"_blank\" rel=\"external\">靠谱程序员必备技能——重构</a><br>当项目变得难以维护，重构便便迫在眉睫，但很多所谓重构仅仅算是重写，随着时间推移，项目再次变得难以维护，周而复始，陷入怪圈。如何避免重构变成重写，本文给了一些很好的建议。</p>\n</li>\n<li><p><a href=\"https://zhuanlan.zhihu.com/p/27659059\" target=\"_blank\" rel=\"external\">我接触过的前端数据结构与算法</a><br>只要是工程师就必须学好计算机基础，只有这样才能适应计算机技术的快速发展，前端工程师更是如此。</p>\n</li>\n<li><p><a href=\"https://yeaseonzhang.github.io/2017/03/16/Vuex-%E9%80%9A%E4%BF%97%E7%89%88/\" target=\"_blank\" rel=\"external\">Vuex 通俗版教程</a><br>Vuex 类似 Redux 的状态管理器，用来管理Vue的所有组件状态。<br>一般在你开发大型单页应用（SPA），会出现多个视图组件依赖同一个状态，来自不同视图的行为需要变更同一个状态。<br>遇到以上情况时候，可以考虑使用Vuex，它能把组件的共享状态抽取出来，当做一个全局单例模式进行管理。这样不管你在何处改变状态，都会通知使用该状态的组件做出相应修改。</p>\n</li>\n<li><p><a href=\"https://stffe.github.io/vue/2017/03/03/%E5%AD%A6%E4%B9%A0Vue%E6%BA%90%E7%A0%81.html\" target=\"_blank\" rel=\"external\">学习Vue.js源码</a><br>文中介绍了vue项目目录结构和数据绑定实现，没有太深入，但可以作为初步了解。</p>\n</li>\n<li><p><a href=\"https://segmentfault.com/a/1190000009985489#articleHeader9\" target=\"_blank\" rel=\"external\">GitHub —— 你不得不上的交友网站</a><br>文章整理了GitHub入门，搭建发布个人博客及个人项目发布，还介绍了一些工具，插件及开源项目；内容比较丰富。</p>\n</li>\n<li><p><a href=\"http://meiminjun.github.io/import%E5%92%8Cexport%E7%AC%94%E8%AE%B0/\" target=\"_blank\" rel=\"external\">彻底搞清楚javascript中的require、import和export</a><br>通过介绍CMD、AMD、ES6的模块规范，来引申出平时业务中经常用到require、import和export的用法以及含义。</p>\n</li>\n<li><p><a href=\"https://github.com/istanbuljs/nyc\" target=\"_blank\" rel=\"external\">工具推荐</a><br>覆盖率工具 istanbul 替换为 nyc，多进程覆盖率的测试速度提升了几倍。都是同一作者的作品，后者目前活跃度高，并支持前端很多新特性。</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm i nyc --save-dev</div><div class=\"line\">$ ./node_modules/.bin/nyc ./node_modules/.bin/mocha</div></pre></td></tr></table></figure>\n<p>执行单元测试命令后，还会直观的给出代码覆盖率报告，以<a href=\"http://flcloverjs.org/\" target=\"_blank\" rel=\"external\">Flclover</a>为例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">------------------------------------|----------|----------|----------|----------|----------------|</div><div class=\"line\">File                                |  % Stmts | % Branch |  % Funcs |  % Lines |Uncovered Lines |</div><div class=\"line\">------------------------------------|----------|----------|----------|----------|----------------|</div><div class=\"line\">All files                           |    79.41 |    66.67 |    61.11 |    81.82 |                |</div><div class=\"line\"> flclover                           |      100 |      100 |      100 |      100 |                |</div><div class=\"line\">  index.js                          |      100 |      100 |      100 |      100 |                |</div><div class=\"line\"> flclover/lib                       |    88.52 |    82.35 |    81.82 |    88.52 |                |</div><div class=\"line\">  application.js                    |      100 |      100 |      100 |      100 |                |</div><div class=\"line\">  flclover.js                       |       30 |        0 |        0 |       30 |... 13,14,17,19 |</div><div class=\"line\"> flclover/lib/middleware/bodyparser |      100 |      100 |      100 |      100 |                |</div><div class=\"line\">  index.js                          |      100 |      100 |      100 |      100 |                |</div><div class=\"line\"> flclover/lib/middleware/logger     |    55.56 |       50 |       50 |    55.56 |                |</div><div class=\"line\">  index.js                          |    55.56 |       50 |       50 |    55.56 |... 39,42,45,48 |</div><div class=\"line\"> flclover/lib/utils                 |    71.43 |    33.33 |        0 |    83.33 |                |</div><div class=\"line\">  index.js                          |    81.25 |    33.33 |        0 |      100 |           7,10 |</div><div class=\"line\">  logger.js                         |       40 |      100 |        0 |       40 |         4,9,13 |</div><div class=\"line\">------------------------------------|----------|----------|----------|----------|----------------|</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><ul>\n<li><p><a href=\"https://juejin.im/post/59278e312f301e006c2e1510\" target=\"_blank\" rel=\"external\">JavaScript系列</a><br>相信作为“前端程序猿(媛)”的你一定了解作用域、原型、原型链、继承、闭包……在前端框架的盛行之下，却让初学者忽略了JS基础的学习，但基础不稳必然限制你的发展空间，当你了解了底层，就能很轻松明白框架的原理。</p>\n</li>\n<li><p><a href=\"https://juejin.im/post/57dcd394a22b9d00610c5ec8\" target=\"_blank\" rel=\"external\">排序算法</a><br>什么？在这个“用数据说话”的时代，你不懂排序算法？那你算什么男人~算什么男人~ 不对不对 算什么猿人~算什么猿人…咳咳，言归正传，平时开发我们常用的快速排序、冒泡排序、选择排序你是否了解其利弊。除此之外还有什么排序算法呢？快来一起学习吧。</p>\n</li>\n<li><p><a href=\"http://es6.ruanyifeng.com/#docs/iterator\" target=\"_blank\" rel=\"external\">Iterator 遍历器</a><br>Iterator为各种不同的数据结构提供了统一的访问机制。它可以提供统一的、简便的接口，使得数据结构的成员按某种次序排列，而es6新增for…of循环，就是由Iterator接口提供消费的。</p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2017/06/tcp-protocol.html\" target=\"_blank\" rel=\"external\">TCP协议简介</a><br>TCP作为互联网核心协议之一，“三次握手”“四次挥手”你是否有所了解？快来完善自己的知识体系吧。<br>ps:详解请参考<a href=\"http://www.jianshu.com/p/ef892323e68f\" target=\"_blank\" rel=\"external\">这里</a></p>\n</li>\n<li><p><a href=\"http://www.jianshu.com/p/e7bb97218946\" target=\"_blank\" rel=\"external\">正则表达式</a><br>业务中有很多复杂的逻辑判断？常常嵌套多个if？快来这里学习下吧，熟练掌握正则表达式会使得你的开发效率得到极大提升。</p>\n</li>\n</ul>\n<h2 id=\"资源整理\"><a href=\"#资源整理\" class=\"headerlink\" title=\"资源整理\"></a>资源整理</h2><ul>\n<li><a href=\"https://github.com/Wscats/Good-text-Share\" target=\"_blank\" rel=\"external\">前端知识点大百科全书</a></li>\n<li><a href=\"http://www.jianshu.com/p/c3dae0951f74\" target=\"_blank\" rel=\"external\">前端资源汇集</a><br>如此之全的知识整理、资源汇集，都掌握的话你可以神挡杀神佛挡杀佛了。</li>\n</ul>\n<h2 id=\"文章\"><a href=\"#文章\" class=\"headerlink\" title=\"文章\"></a>文章</h2><ul>\n<li><p><a href=\"https://juejin.im/post/58e3a5a0a0bb9f0069fc16bb\" target=\"_blank\" rel=\"external\">一劳永逸的搞定flex布局</a><br>你是否还在使用浮动布局？写各种line-height实现居中？不妨试试flexBox布局，它简单易用的写法可以轻松实现各种布局，让你的布局更快速高效。</p>\n</li>\n<li><p><a href=\"https://segmentfault.com/a/1190000010014281\" target=\"_blank\" rel=\"external\">Vue的数据依赖实现原理简析</a><br>主要从初始化的数据层面上分析了Vue是如何管理依赖来到达数据的动态响应。<br>initState的过程中，将props,computed,data等属性通过Object.defineProperty来改造其getter/setter属性，并为每一个响应式属性实例化一个observer观察者。这个observer内部dep记录了这个响应式属性的所有依赖。<br>当响应式属性调用setter函数时，通过dep.notify()方法去遍历所有的依赖，调用watcher.update()去完成数据的动态响应。</p>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzIyNjE4NjI2Nw==&amp;mid=2652558943&amp;idx=1&amp;sn=1516afcf876b9fb4a17ce048c5ade58d\" target=\"_blank\" rel=\"external\">靠谱程序员必备技能——重构</a><br>当项目变得难以维护，重构便便迫在眉睫，但很多所谓重构仅仅算是重写，随着时间推移，项目再次变得难以维护，周而复始，陷入怪圈。如何避免重构变成重写，本文给了一些很好的建议。</p>\n</li>\n<li><p><a href=\"https://zhuanlan.zhihu.com/p/27659059\" target=\"_blank\" rel=\"external\">我接触过的前端数据结构与算法</a><br>只要是工程师就必须学好计算机基础，只有这样才能适应计算机技术的快速发展，前端工程师更是如此。</p>\n</li>\n<li><p><a href=\"https://yeaseonzhang.github.io/2017/03/16/Vuex-%E9%80%9A%E4%BF%97%E7%89%88/\" target=\"_blank\" rel=\"external\">Vuex 通俗版教程</a><br>Vuex 类似 Redux 的状态管理器，用来管理Vue的所有组件状态。<br>一般在你开发大型单页应用（SPA），会出现多个视图组件依赖同一个状态，来自不同视图的行为需要变更同一个状态。<br>遇到以上情况时候，可以考虑使用Vuex，它能把组件的共享状态抽取出来，当做一个全局单例模式进行管理。这样不管你在何处改变状态，都会通知使用该状态的组件做出相应修改。</p>\n</li>\n<li><p><a href=\"https://stffe.github.io/vue/2017/03/03/%E5%AD%A6%E4%B9%A0Vue%E6%BA%90%E7%A0%81.html\" target=\"_blank\" rel=\"external\">学习Vue.js源码</a><br>文中介绍了vue项目目录结构和数据绑定实现，没有太深入，但可以作为初步了解。</p>\n</li>\n<li><p><a href=\"https://segmentfault.com/a/1190000009985489#articleHeader9\" target=\"_blank\" rel=\"external\">GitHub —— 你不得不上的交友网站</a><br>文章整理了GitHub入门，搭建发布个人博客及个人项目发布，还介绍了一些工具，插件及开源项目；内容比较丰富。</p>\n</li>\n<li><p><a href=\"http://meiminjun.github.io/import%E5%92%8Cexport%E7%AC%94%E8%AE%B0/\" target=\"_blank\" rel=\"external\">彻底搞清楚javascript中的require、import和export</a><br>通过介绍CMD、AMD、ES6的模块规范，来引申出平时业务中经常用到require、import和export的用法以及含义。</p>\n</li>\n<li><p><a href=\"https://github.com/istanbuljs/nyc\" target=\"_blank\" rel=\"external\">工具推荐</a><br>覆盖率工具 istanbul 替换为 nyc，多进程覆盖率的测试速度提升了几倍。都是同一作者的作品，后者目前活跃度高，并支持前端很多新特性。</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm i nyc --save-dev</div><div class=\"line\">$ ./node_modules/.bin/nyc ./node_modules/.bin/mocha</div></pre></td></tr></table></figure>\n<p>执行单元测试命令后，还会直观的给出代码覆盖率报告，以<a href=\"http://flcloverjs.org/\" target=\"_blank\" rel=\"external\">Flclover</a>为例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">------------------------------------|----------|----------|----------|----------|----------------|</div><div class=\"line\">File                                |  % Stmts | % Branch |  % Funcs |  % Lines |Uncovered Lines |</div><div class=\"line\">------------------------------------|----------|----------|----------|----------|----------------|</div><div class=\"line\">All files                           |    79.41 |    66.67 |    61.11 |    81.82 |                |</div><div class=\"line\"> flclover                           |      100 |      100 |      100 |      100 |                |</div><div class=\"line\">  index.js                          |      100 |      100 |      100 |      100 |                |</div><div class=\"line\"> flclover/lib                       |    88.52 |    82.35 |    81.82 |    88.52 |                |</div><div class=\"line\">  application.js                    |      100 |      100 |      100 |      100 |                |</div><div class=\"line\">  flclover.js                       |       30 |        0 |        0 |       30 |... 13,14,17,19 |</div><div class=\"line\"> flclover/lib/middleware/bodyparser |      100 |      100 |      100 |      100 |                |</div><div class=\"line\">  index.js                          |      100 |      100 |      100 |      100 |                |</div><div class=\"line\"> flclover/lib/middleware/logger     |    55.56 |       50 |       50 |    55.56 |                |</div><div class=\"line\">  index.js                          |    55.56 |       50 |       50 |    55.56 |... 39,42,45,48 |</div><div class=\"line\"> flclover/lib/utils                 |    71.43 |    33.33 |        0 |    83.33 |                |</div><div class=\"line\">  index.js                          |    81.25 |    33.33 |        0 |      100 |           7,10 |</div><div class=\"line\">  logger.js                         |       40 |      100 |        0 |       40 |         4,9,13 |</div><div class=\"line\">------------------------------------|----------|----------|----------|----------|----------------|</div></pre></td></tr></table></figure></p>\n"},{"title":"大前端周刊 第二期 （本期小编：胡国伟）","date":"2017-06-30T03:18:25.000Z","_content":"\n## 基础\n* [Class 的基本语法](http://es6.ruanyifeng.com/#docs/class)\n尽管基本上，`ES6`的`class`可以看作只是一个语法糖，但使得`JavaScript`对象原型的写法更加清晰、更像面向对象编程的语法，更接近传统语言的写法。\n\n* [Module 的语法](http://es6.ruanyifeng.com/#docs/module)\n相交于社区提供了各种模块化解决方案，`ES6`语言标准的层面上实现了模块功能，成为浏览器和服务器通用的模块解决方案。\n\n* [数组的扩展](http://es6.ruanyifeng.com/#docs/array)\n`ES6`内置新数组方法，无需再自己再实现相应的`polyfill`了，赶紧学习充能，搭配[该文（*【深度长文】JavaScript数组所有API全解密*）](http://louiszhai.github.io/2017/04/28/array/)食用，更易消化。\n\n* [webpack 中文](https://webpack-china.org/)\n旧版的`webpack`官方文档有些糟糕，幸好后来有了新版，并且还有志愿者维护了相对应的中文版本，这下查阅学习就更轻松了。近日`webpack 3.0` 已经释出，大家赶快跟进。\n\n* [EditorConfig使用介绍](https://segmentfault.com/a/1190000007599845)\n团队合作，统一编辑器行为非常必要，本文对`EditorConfig`中的配置进行了讲解。\nps：[EditorConfig](http://editorconfig.org/)规范在这里。\n\n## 文章\n\n*   1. [Server-Sent Events 教程](http://www.ruanyifeng.com/blog/2017/05/server-sent_events.html)\n    2. [WebSocket 教程](http://www.ruanyifeng.com/blog/2017/05/websocket.html) <br/>\n这两篇文章一起读，就可以很全面的了解现代浏览器和服务器通信技术。\n\n* [深入理解 JavaScript 异步](https://github.com/wangfupeng1988/js-async-tutorial)\n这个系列文章把异步方面的知识以及原理讲解的比较清楚，从传统的方式到`promise`到`generator`到`async`，值得一读。\n\n* [koa2从起步到填坑](http://www.jianshu.com/p/6b816c609669)\n比较系统简介`koa2`使用，包含一些例子，可以让人更快上手。\n\n* [现代前端科技解析 —— 数据响应式系统](https://www.404forest.com/2017/06/28/modern-web-development-tech-analysis-data-reactivity-system/)\n文章讲解数据响应式系统及其构建，分步骤实现了`vue2.0`的响应式，还有详细的代码示例及注释。\n\n* [关于前端开发谈谈单元测试](https://segmentfault.com/a/1190000000317146)\n阐述了做单元测试的必要性，\n着重介绍了`Jasmine`的常用语法，\n并对其他流行测试框架和工具做了介绍。\n\n* [Three.js入门指南](http://www.ituring.com.cn/book/1272)\n关于`Three.js`中文文章资料还是不够丰富，以至于这本免费小书时至今日还是`Three.js`入门的最佳选择之一。\n\n*   1. [测试你的前端代码 – part1（介绍篇）](https://mp.weixin.qq.com/s/jUJXmis0_u6BzQDT2mCltA)\n    2. [测试你的前端代码 – part2（单元测试）](https://mp.weixin.qq.com/s/pYUePHOsZegMf4MmJCoJeA)\n    3. [测试你的前端代码 – part3（端到端测试）](https://mp.weixin.qq.com/s/8UfR8bsPd2bkmPg_xkAKKg)\n    4. [测试你的前端代码 – part4（集成测试）](https://mp.weixin.qq.com/s/CpNUn5AWbP4aH0yirwuizQ)\n<br>\n文章由浅入深的介绍前端工程的测试，覆盖单元测试、端到端测试、集成测试，较为简单的事例介绍有利于你快速掌握这些知识。\n\n* [学用 JavaScript 设计模式](http://www.oschina.net/translate/learning-javascript-design-patterns?cmp)\n文章讲解数据响应式系统及其构建，分步骤实现了 vue2.0的响应式，还有详细的代码示例及注释。\n\n","source":"_posts/weekly-2.md","raw":"---\ntitle: 大前端周刊 第二期 （本期小编：胡国伟）\ndate: 2017-06-30 11:18:25\ntags: [weekly,框架,测试,设计模式,three.js]\n---\n\n## 基础\n* [Class 的基本语法](http://es6.ruanyifeng.com/#docs/class)\n尽管基本上，`ES6`的`class`可以看作只是一个语法糖，但使得`JavaScript`对象原型的写法更加清晰、更像面向对象编程的语法，更接近传统语言的写法。\n\n* [Module 的语法](http://es6.ruanyifeng.com/#docs/module)\n相交于社区提供了各种模块化解决方案，`ES6`语言标准的层面上实现了模块功能，成为浏览器和服务器通用的模块解决方案。\n\n* [数组的扩展](http://es6.ruanyifeng.com/#docs/array)\n`ES6`内置新数组方法，无需再自己再实现相应的`polyfill`了，赶紧学习充能，搭配[该文（*【深度长文】JavaScript数组所有API全解密*）](http://louiszhai.github.io/2017/04/28/array/)食用，更易消化。\n\n* [webpack 中文](https://webpack-china.org/)\n旧版的`webpack`官方文档有些糟糕，幸好后来有了新版，并且还有志愿者维护了相对应的中文版本，这下查阅学习就更轻松了。近日`webpack 3.0` 已经释出，大家赶快跟进。\n\n* [EditorConfig使用介绍](https://segmentfault.com/a/1190000007599845)\n团队合作，统一编辑器行为非常必要，本文对`EditorConfig`中的配置进行了讲解。\nps：[EditorConfig](http://editorconfig.org/)规范在这里。\n\n## 文章\n\n*   1. [Server-Sent Events 教程](http://www.ruanyifeng.com/blog/2017/05/server-sent_events.html)\n    2. [WebSocket 教程](http://www.ruanyifeng.com/blog/2017/05/websocket.html) <br/>\n这两篇文章一起读，就可以很全面的了解现代浏览器和服务器通信技术。\n\n* [深入理解 JavaScript 异步](https://github.com/wangfupeng1988/js-async-tutorial)\n这个系列文章把异步方面的知识以及原理讲解的比较清楚，从传统的方式到`promise`到`generator`到`async`，值得一读。\n\n* [koa2从起步到填坑](http://www.jianshu.com/p/6b816c609669)\n比较系统简介`koa2`使用，包含一些例子，可以让人更快上手。\n\n* [现代前端科技解析 —— 数据响应式系统](https://www.404forest.com/2017/06/28/modern-web-development-tech-analysis-data-reactivity-system/)\n文章讲解数据响应式系统及其构建，分步骤实现了`vue2.0`的响应式，还有详细的代码示例及注释。\n\n* [关于前端开发谈谈单元测试](https://segmentfault.com/a/1190000000317146)\n阐述了做单元测试的必要性，\n着重介绍了`Jasmine`的常用语法，\n并对其他流行测试框架和工具做了介绍。\n\n* [Three.js入门指南](http://www.ituring.com.cn/book/1272)\n关于`Three.js`中文文章资料还是不够丰富，以至于这本免费小书时至今日还是`Three.js`入门的最佳选择之一。\n\n*   1. [测试你的前端代码 – part1（介绍篇）](https://mp.weixin.qq.com/s/jUJXmis0_u6BzQDT2mCltA)\n    2. [测试你的前端代码 – part2（单元测试）](https://mp.weixin.qq.com/s/pYUePHOsZegMf4MmJCoJeA)\n    3. [测试你的前端代码 – part3（端到端测试）](https://mp.weixin.qq.com/s/8UfR8bsPd2bkmPg_xkAKKg)\n    4. [测试你的前端代码 – part4（集成测试）](https://mp.weixin.qq.com/s/CpNUn5AWbP4aH0yirwuizQ)\n<br>\n文章由浅入深的介绍前端工程的测试，覆盖单元测试、端到端测试、集成测试，较为简单的事例介绍有利于你快速掌握这些知识。\n\n* [学用 JavaScript 设计模式](http://www.oschina.net/translate/learning-javascript-design-patterns?cmp)\n文章讲解数据响应式系统及其构建，分步骤实现了 vue2.0的响应式，还有详细的代码示例及注释。\n\n","slug":"weekly-2","published":1,"updated":"2017-07-04T03:52:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6i92auj0001e1txd0yb60zr","content":"<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><ul>\n<li><p><a href=\"http://es6.ruanyifeng.com/#docs/class\" target=\"_blank\" rel=\"external\">Class 的基本语法</a><br>尽管基本上，<code>ES6</code>的<code>class</code>可以看作只是一个语法糖，但使得<code>JavaScript</code>对象原型的写法更加清晰、更像面向对象编程的语法，更接近传统语言的写法。</p>\n</li>\n<li><p><a href=\"http://es6.ruanyifeng.com/#docs/module\" target=\"_blank\" rel=\"external\">Module 的语法</a><br>相交于社区提供了各种模块化解决方案，<code>ES6</code>语言标准的层面上实现了模块功能，成为浏览器和服务器通用的模块解决方案。</p>\n</li>\n<li><p><a href=\"http://es6.ruanyifeng.com/#docs/array\" target=\"_blank\" rel=\"external\">数组的扩展</a><br><code>ES6</code>内置新数组方法，无需再自己再实现相应的<code>polyfill</code>了，赶紧学习充能，搭配<a href=\"http://louiszhai.github.io/2017/04/28/array/\" target=\"_blank\" rel=\"external\">该文（<em>【深度长文】JavaScript数组所有API全解密</em>）</a>食用，更易消化。</p>\n</li>\n<li><p><a href=\"https://webpack-china.org/\" target=\"_blank\" rel=\"external\">webpack 中文</a><br>旧版的<code>webpack</code>官方文档有些糟糕，幸好后来有了新版，并且还有志愿者维护了相对应的中文版本，这下查阅学习就更轻松了。近日<code>webpack 3.0</code> 已经释出，大家赶快跟进。</p>\n</li>\n<li><p><a href=\"https://segmentfault.com/a/1190000007599845\" target=\"_blank\" rel=\"external\">EditorConfig使用介绍</a><br>团队合作，统一编辑器行为非常必要，本文对<code>EditorConfig</code>中的配置进行了讲解。<br>ps：<a href=\"http://editorconfig.org/\" target=\"_blank\" rel=\"external\">EditorConfig</a>规范在这里。</p>\n</li>\n</ul>\n<h2 id=\"文章\"><a href=\"#文章\" class=\"headerlink\" title=\"文章\"></a>文章</h2><ul>\n<li><ol>\n<li><a href=\"http://www.ruanyifeng.com/blog/2017/05/server-sent_events.html\" target=\"_blank\" rel=\"external\">Server-Sent Events 教程</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2017/05/websocket.html\" target=\"_blank\" rel=\"external\">WebSocket 教程</a> <br><br>这两篇文章一起读，就可以很全面的了解现代浏览器和服务器通信技术。</li>\n</ol>\n</li>\n<li><p><a href=\"https://github.com/wangfupeng1988/js-async-tutorial\" target=\"_blank\" rel=\"external\">深入理解 JavaScript 异步</a><br>这个系列文章把异步方面的知识以及原理讲解的比较清楚，从传统的方式到<code>promise</code>到<code>generator</code>到<code>async</code>，值得一读。</p>\n</li>\n<li><p><a href=\"http://www.jianshu.com/p/6b816c609669\" target=\"_blank\" rel=\"external\">koa2从起步到填坑</a><br>比较系统简介<code>koa2</code>使用，包含一些例子，可以让人更快上手。</p>\n</li>\n<li><p><a href=\"https://www.404forest.com/2017/06/28/modern-web-development-tech-analysis-data-reactivity-system/\" target=\"_blank\" rel=\"external\">现代前端科技解析 —— 数据响应式系统</a><br>文章讲解数据响应式系统及其构建，分步骤实现了<code>vue2.0</code>的响应式，还有详细的代码示例及注释。</p>\n</li>\n<li><p><a href=\"https://segmentfault.com/a/1190000000317146\" target=\"_blank\" rel=\"external\">关于前端开发谈谈单元测试</a><br>阐述了做单元测试的必要性，<br>着重介绍了<code>Jasmine</code>的常用语法，<br>并对其他流行测试框架和工具做了介绍。</p>\n</li>\n<li><p><a href=\"http://www.ituring.com.cn/book/1272\" target=\"_blank\" rel=\"external\">Three.js入门指南</a><br>关于<code>Three.js</code>中文文章资料还是不够丰富，以至于这本免费小书时至今日还是<code>Three.js</code>入门的最佳选择之一。</p>\n</li>\n<li><ol>\n<li><a href=\"https://mp.weixin.qq.com/s/jUJXmis0_u6BzQDT2mCltA\" target=\"_blank\" rel=\"external\">测试你的前端代码 – part1（介绍篇）</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/pYUePHOsZegMf4MmJCoJeA\" target=\"_blank\" rel=\"external\">测试你的前端代码 – part2（单元测试）</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/8UfR8bsPd2bkmPg_xkAKKg\" target=\"_blank\" rel=\"external\">测试你的前端代码 – part3（端到端测试）</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/CpNUn5AWbP4aH0yirwuizQ\" target=\"_blank\" rel=\"external\">测试你的前端代码 – part4（集成测试）</a><br><br><br>文章由浅入深的介绍前端工程的测试，覆盖单元测试、端到端测试、集成测试，较为简单的事例介绍有利于你快速掌握这些知识。</li>\n</ol>\n</li>\n<li><p><a href=\"http://www.oschina.net/translate/learning-javascript-design-patterns?cmp\" target=\"_blank\" rel=\"external\">学用 JavaScript 设计模式</a><br>文章讲解数据响应式系统及其构建，分步骤实现了 vue2.0的响应式，还有详细的代码示例及注释。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><ul>\n<li><p><a href=\"http://es6.ruanyifeng.com/#docs/class\" target=\"_blank\" rel=\"external\">Class 的基本语法</a><br>尽管基本上，<code>ES6</code>的<code>class</code>可以看作只是一个语法糖，但使得<code>JavaScript</code>对象原型的写法更加清晰、更像面向对象编程的语法，更接近传统语言的写法。</p>\n</li>\n<li><p><a href=\"http://es6.ruanyifeng.com/#docs/module\" target=\"_blank\" rel=\"external\">Module 的语法</a><br>相交于社区提供了各种模块化解决方案，<code>ES6</code>语言标准的层面上实现了模块功能，成为浏览器和服务器通用的模块解决方案。</p>\n</li>\n<li><p><a href=\"http://es6.ruanyifeng.com/#docs/array\" target=\"_blank\" rel=\"external\">数组的扩展</a><br><code>ES6</code>内置新数组方法，无需再自己再实现相应的<code>polyfill</code>了，赶紧学习充能，搭配<a href=\"http://louiszhai.github.io/2017/04/28/array/\" target=\"_blank\" rel=\"external\">该文（<em>【深度长文】JavaScript数组所有API全解密</em>）</a>食用，更易消化。</p>\n</li>\n<li><p><a href=\"https://webpack-china.org/\" target=\"_blank\" rel=\"external\">webpack 中文</a><br>旧版的<code>webpack</code>官方文档有些糟糕，幸好后来有了新版，并且还有志愿者维护了相对应的中文版本，这下查阅学习就更轻松了。近日<code>webpack 3.0</code> 已经释出，大家赶快跟进。</p>\n</li>\n<li><p><a href=\"https://segmentfault.com/a/1190000007599845\" target=\"_blank\" rel=\"external\">EditorConfig使用介绍</a><br>团队合作，统一编辑器行为非常必要，本文对<code>EditorConfig</code>中的配置进行了讲解。<br>ps：<a href=\"http://editorconfig.org/\" target=\"_blank\" rel=\"external\">EditorConfig</a>规范在这里。</p>\n</li>\n</ul>\n<h2 id=\"文章\"><a href=\"#文章\" class=\"headerlink\" title=\"文章\"></a>文章</h2><ul>\n<li><ol>\n<li><a href=\"http://www.ruanyifeng.com/blog/2017/05/server-sent_events.html\" target=\"_blank\" rel=\"external\">Server-Sent Events 教程</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2017/05/websocket.html\" target=\"_blank\" rel=\"external\">WebSocket 教程</a> <br><br>这两篇文章一起读，就可以很全面的了解现代浏览器和服务器通信技术。</li>\n</ol>\n</li>\n<li><p><a href=\"https://github.com/wangfupeng1988/js-async-tutorial\" target=\"_blank\" rel=\"external\">深入理解 JavaScript 异步</a><br>这个系列文章把异步方面的知识以及原理讲解的比较清楚，从传统的方式到<code>promise</code>到<code>generator</code>到<code>async</code>，值得一读。</p>\n</li>\n<li><p><a href=\"http://www.jianshu.com/p/6b816c609669\" target=\"_blank\" rel=\"external\">koa2从起步到填坑</a><br>比较系统简介<code>koa2</code>使用，包含一些例子，可以让人更快上手。</p>\n</li>\n<li><p><a href=\"https://www.404forest.com/2017/06/28/modern-web-development-tech-analysis-data-reactivity-system/\" target=\"_blank\" rel=\"external\">现代前端科技解析 —— 数据响应式系统</a><br>文章讲解数据响应式系统及其构建，分步骤实现了<code>vue2.0</code>的响应式，还有详细的代码示例及注释。</p>\n</li>\n<li><p><a href=\"https://segmentfault.com/a/1190000000317146\" target=\"_blank\" rel=\"external\">关于前端开发谈谈单元测试</a><br>阐述了做单元测试的必要性，<br>着重介绍了<code>Jasmine</code>的常用语法，<br>并对其他流行测试框架和工具做了介绍。</p>\n</li>\n<li><p><a href=\"http://www.ituring.com.cn/book/1272\" target=\"_blank\" rel=\"external\">Three.js入门指南</a><br>关于<code>Three.js</code>中文文章资料还是不够丰富，以至于这本免费小书时至今日还是<code>Three.js</code>入门的最佳选择之一。</p>\n</li>\n<li><ol>\n<li><a href=\"https://mp.weixin.qq.com/s/jUJXmis0_u6BzQDT2mCltA\" target=\"_blank\" rel=\"external\">测试你的前端代码 – part1（介绍篇）</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/pYUePHOsZegMf4MmJCoJeA\" target=\"_blank\" rel=\"external\">测试你的前端代码 – part2（单元测试）</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/8UfR8bsPd2bkmPg_xkAKKg\" target=\"_blank\" rel=\"external\">测试你的前端代码 – part3（端到端测试）</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/CpNUn5AWbP4aH0yirwuizQ\" target=\"_blank\" rel=\"external\">测试你的前端代码 – part4（集成测试）</a><br><br><br>文章由浅入深的介绍前端工程的测试，覆盖单元测试、端到端测试、集成测试，较为简单的事例介绍有利于你快速掌握这些知识。</li>\n</ol>\n</li>\n<li><p><a href=\"http://www.oschina.net/translate/learning-javascript-design-patterns?cmp\" target=\"_blank\" rel=\"external\">学用 JavaScript 设计模式</a><br>文章讲解数据响应式系统及其构建，分步骤实现了 vue2.0的响应式，还有详细的代码示例及注释。</p>\n</li>\n</ul>\n"},{"title":"大前端周刊 第一期 （本期小编：王祥）","date":"2017-06-23T03:18:25.000Z","_content":"\n## 基础\n\n* [Promise](http://es6.ruanyifeng.com/#docs/promise)\n在Javascript的单线程异步架构下，Promise会是很多异步服务的核心知识点，Node 8.X已经可以方便的将回调方式转换为Promise。\n\n* [异步函数async](http://es6.ruanyifeng.com/#docs/async)\n使用异步函数可以实现“用同步的写法，完成异步的事情”，Node 8.X已经在编译器层面对async做了优化。\n* [语义化版本 2.0.0](http://semver.org/lang/zh-CN/)\n玩开源项目的基础，组件发布的约定。\n* [package.json规则](https://docs.npmjs.com/files/package.json)\n项目的依赖列表，区别开发环境、生产环境、面向的平台和组件的规范（CMD、AMD和UMD）等。\n\n## 单元测试工具\nWeb 应用中的单元测试更加重要，在 Web 产品快速迭代的时期，每个测试用例都给应用的稳定性提供了一层保障。 API 升级，测试用例可以很好地检查代码是否向下兼容。 对于各种可能的输入，一旦测试覆盖，都能明确它的输出。 代码改动后，可以通过测试结果判断代码的改动是否影响已确定的结果。\n\n* [mocha单元测试](https://mochajs.org/)\nNPM里每天有25W的下载量，同时支持Node、浏览器多平台的测试用例的执行。\n\n* [power-assert断言库](https://www.npmjs.com/package/power-assert)\npower-assert可以零学习成本，直观的展示出判断条件和结果。\n\n```\n1) Array #indexOf() should return index when the value is present:\n     AssertionError: # path/to/test/mocha_node.js:10\n\n  assert(ary.indexOf(zero) === two)\n         |   |       |     |   |\n         |   |       |     |   2\n         |   -1      0     false\n         [1,2,3]\n\n  [number] two\n  => 2\n  [number] ary.indexOf(zero)\n  => -1\n```\n\n## 文章\n\n* [JavaScript专题之跟着underscore学防抖](https://github.com/mqyqingfeng/Blog/issues/22)\n对防抖的原理介绍的很清晰，从最简单的实现版本一步一步讲解到实现复杂的版本。\n让我对防抖有了重新的认识。\n\n* [从前端开发看面向未来的敏捷学习法](http://www.jianshu.com/p/fd7055705c62)\n授人以鱼不如授人以渔\n前端技术更新速度很快，快速学习已经成了每个工程师必备技能。\n除了掌握技术知识，解决问题的能力在实际项目中也很重要，文中以实际案例给出分解思路和系统敏捷学习新知识思路。\n\n* [前端工程师做事的三重境界：我的进阶之路](https://zhuanlan.zhihu.com/p/26660510)\n从程序员到工程师的进阶之路，精益求精才能称得上是工程师。作者认为这三个单词（Programmer、Developer、Enginner）对应不用的境界。\n\n* [浏览器缓存机制剖析](http://louiszhai.github.io/2017/04/07/http-cache/)\n正如文中所述“缓存一直是前端优化的主战场, 利用好缓存就成功了一半”，利用好缓存在前端优化地位中举足轻重，本文能够带领大家对浏览器缓存机制有一个初步了解。\n\n* [vue-mixins使用注意事项和高级用法](https://www.deboy.cn/Vue-mixins-advance-tips.html)\n在项目开发中经常会碰到两个组件的业务逻辑有所相似，可能共享相同的底层业务逻辑；此时需要考虑如何来合理地划分代码，即避免冗余代码，也不能过度抽象。\n\n* [也谈JavaScript数组去重](https://www.toobug.net/article/array_unique_in_javascript.html)\n去重，首先要思考什么是相等，从最初的循环，到Set集合。\n\n* [大前端公共知识梳理：这些知识你都掌握了吗？](https://mp.weixin.qq.com/s?__biz=MzIwNjQwMzUwMQ==&mid=2247485277&idx=1&sn=82703e13febb1e7947cc18d1f57fc375&key=6b0fbfcb936d93fa91a745202d0f37bffff65fd2cba5ff2cfa25618c8d03951944ae6eb2f4db18aaf1c8893ddaeffb404684dbd7f6159925dbab9411094f960daba3c6f46c1f93d34f9a6d476104fc63&ascene=0&uin=MTQwNzQzODYwMA%3D%3D&version=12020810&nettype=WIFI&fontScale=100&pass_ticket=xJ0pJsFuIsM3Ce35cuVqghSLUWaqU91w%2FEgBgn2%2BhouemlzbFvOIXP3KmJlioe0D)\n文章覆盖非常全面，所介绍基础知识、技术栈、能力、领域有很多都是目前我所欠缺的，介于此推荐给大家。。。看完最直观的感受就是自己是个假前端\n\n* [重温ES6核心概念和基本用法](https://segmentfault.com/a/1190000009885614)\n文章梳理了ES6核心概念及基础用法，推荐给大家。\n","source":"_posts/weekly-1.md","raw":"---\ntitle: 大前端周刊 第一期 （本期小编：王祥）\ndate: 2017-06-23 11:18:25\ntags: [weekly,全栈,Node]\n---\n\n## 基础\n\n* [Promise](http://es6.ruanyifeng.com/#docs/promise)\n在Javascript的单线程异步架构下，Promise会是很多异步服务的核心知识点，Node 8.X已经可以方便的将回调方式转换为Promise。\n\n* [异步函数async](http://es6.ruanyifeng.com/#docs/async)\n使用异步函数可以实现“用同步的写法，完成异步的事情”，Node 8.X已经在编译器层面对async做了优化。\n* [语义化版本 2.0.0](http://semver.org/lang/zh-CN/)\n玩开源项目的基础，组件发布的约定。\n* [package.json规则](https://docs.npmjs.com/files/package.json)\n项目的依赖列表，区别开发环境、生产环境、面向的平台和组件的规范（CMD、AMD和UMD）等。\n\n## 单元测试工具\nWeb 应用中的单元测试更加重要，在 Web 产品快速迭代的时期，每个测试用例都给应用的稳定性提供了一层保障。 API 升级，测试用例可以很好地检查代码是否向下兼容。 对于各种可能的输入，一旦测试覆盖，都能明确它的输出。 代码改动后，可以通过测试结果判断代码的改动是否影响已确定的结果。\n\n* [mocha单元测试](https://mochajs.org/)\nNPM里每天有25W的下载量，同时支持Node、浏览器多平台的测试用例的执行。\n\n* [power-assert断言库](https://www.npmjs.com/package/power-assert)\npower-assert可以零学习成本，直观的展示出判断条件和结果。\n\n```\n1) Array #indexOf() should return index when the value is present:\n     AssertionError: # path/to/test/mocha_node.js:10\n\n  assert(ary.indexOf(zero) === two)\n         |   |       |     |   |\n         |   |       |     |   2\n         |   -1      0     false\n         [1,2,3]\n\n  [number] two\n  => 2\n  [number] ary.indexOf(zero)\n  => -1\n```\n\n## 文章\n\n* [JavaScript专题之跟着underscore学防抖](https://github.com/mqyqingfeng/Blog/issues/22)\n对防抖的原理介绍的很清晰，从最简单的实现版本一步一步讲解到实现复杂的版本。\n让我对防抖有了重新的认识。\n\n* [从前端开发看面向未来的敏捷学习法](http://www.jianshu.com/p/fd7055705c62)\n授人以鱼不如授人以渔\n前端技术更新速度很快，快速学习已经成了每个工程师必备技能。\n除了掌握技术知识，解决问题的能力在实际项目中也很重要，文中以实际案例给出分解思路和系统敏捷学习新知识思路。\n\n* [前端工程师做事的三重境界：我的进阶之路](https://zhuanlan.zhihu.com/p/26660510)\n从程序员到工程师的进阶之路，精益求精才能称得上是工程师。作者认为这三个单词（Programmer、Developer、Enginner）对应不用的境界。\n\n* [浏览器缓存机制剖析](http://louiszhai.github.io/2017/04/07/http-cache/)\n正如文中所述“缓存一直是前端优化的主战场, 利用好缓存就成功了一半”，利用好缓存在前端优化地位中举足轻重，本文能够带领大家对浏览器缓存机制有一个初步了解。\n\n* [vue-mixins使用注意事项和高级用法](https://www.deboy.cn/Vue-mixins-advance-tips.html)\n在项目开发中经常会碰到两个组件的业务逻辑有所相似，可能共享相同的底层业务逻辑；此时需要考虑如何来合理地划分代码，即避免冗余代码，也不能过度抽象。\n\n* [也谈JavaScript数组去重](https://www.toobug.net/article/array_unique_in_javascript.html)\n去重，首先要思考什么是相等，从最初的循环，到Set集合。\n\n* [大前端公共知识梳理：这些知识你都掌握了吗？](https://mp.weixin.qq.com/s?__biz=MzIwNjQwMzUwMQ==&mid=2247485277&idx=1&sn=82703e13febb1e7947cc18d1f57fc375&key=6b0fbfcb936d93fa91a745202d0f37bffff65fd2cba5ff2cfa25618c8d03951944ae6eb2f4db18aaf1c8893ddaeffb404684dbd7f6159925dbab9411094f960daba3c6f46c1f93d34f9a6d476104fc63&ascene=0&uin=MTQwNzQzODYwMA%3D%3D&version=12020810&nettype=WIFI&fontScale=100&pass_ticket=xJ0pJsFuIsM3Ce35cuVqghSLUWaqU91w%2FEgBgn2%2BhouemlzbFvOIXP3KmJlioe0D)\n文章覆盖非常全面，所介绍基础知识、技术栈、能力、领域有很多都是目前我所欠缺的，介于此推荐给大家。。。看完最直观的感受就是自己是个假前端\n\n* [重温ES6核心概念和基本用法](https://segmentfault.com/a/1190000009885614)\n文章梳理了ES6核心概念及基础用法，推荐给大家。\n","slug":"weekly-1","published":1,"updated":"2017-06-23T09:01:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6i92aup0003e1txp8kbumsh","content":"<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><ul>\n<li><p><a href=\"http://es6.ruanyifeng.com/#docs/promise\" target=\"_blank\" rel=\"external\">Promise</a><br>在Javascript的单线程异步架构下，Promise会是很多异步服务的核心知识点，Node 8.X已经可以方便的将回调方式转换为Promise。</p>\n</li>\n<li><p><a href=\"http://es6.ruanyifeng.com/#docs/async\" target=\"_blank\" rel=\"external\">异步函数async</a><br>使用异步函数可以实现“用同步的写法，完成异步的事情”，Node 8.X已经在编译器层面对async做了优化。</p>\n</li>\n<li><a href=\"http://semver.org/lang/zh-CN/\" target=\"_blank\" rel=\"external\">语义化版本 2.0.0</a><br>玩开源项目的基础，组件发布的约定。</li>\n<li><a href=\"https://docs.npmjs.com/files/package.json\" target=\"_blank\" rel=\"external\">package.json规则</a><br>项目的依赖列表，区别开发环境、生产环境、面向的平台和组件的规范（CMD、AMD和UMD）等。</li>\n</ul>\n<h2 id=\"单元测试工具\"><a href=\"#单元测试工具\" class=\"headerlink\" title=\"单元测试工具\"></a>单元测试工具</h2><p>Web 应用中的单元测试更加重要，在 Web 产品快速迭代的时期，每个测试用例都给应用的稳定性提供了一层保障。 API 升级，测试用例可以很好地检查代码是否向下兼容。 对于各种可能的输入，一旦测试覆盖，都能明确它的输出。 代码改动后，可以通过测试结果判断代码的改动是否影响已确定的结果。</p>\n<ul>\n<li><p><a href=\"https://mochajs.org/\" target=\"_blank\" rel=\"external\">mocha单元测试</a><br>NPM里每天有25W的下载量，同时支持Node、浏览器多平台的测试用例的执行。</p>\n</li>\n<li><p><a href=\"https://www.npmjs.com/package/power-assert\" target=\"_blank\" rel=\"external\">power-assert断言库</a><br>power-assert可以零学习成本，直观的展示出判断条件和结果。</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">1) Array #indexOf() should return index when the value is present:</div><div class=\"line\">     AssertionError: # path/to/test/mocha_node.js:10</div><div class=\"line\"></div><div class=\"line\">  assert(ary.indexOf(zero) === two)</div><div class=\"line\">         |   |       |     |   |</div><div class=\"line\">         |   |       |     |   2</div><div class=\"line\">         |   -1      0     false</div><div class=\"line\">         [1,2,3]</div><div class=\"line\"></div><div class=\"line\">  [number] two</div><div class=\"line\">  =&gt; 2</div><div class=\"line\">  [number] ary.indexOf(zero)</div><div class=\"line\">  =&gt; -1</div></pre></td></tr></table></figure>\n<h2 id=\"文章\"><a href=\"#文章\" class=\"headerlink\" title=\"文章\"></a>文章</h2><ul>\n<li><p><a href=\"https://github.com/mqyqingfeng/Blog/issues/22\" target=\"_blank\" rel=\"external\">JavaScript专题之跟着underscore学防抖</a><br>对防抖的原理介绍的很清晰，从最简单的实现版本一步一步讲解到实现复杂的版本。<br>让我对防抖有了重新的认识。</p>\n</li>\n<li><p><a href=\"http://www.jianshu.com/p/fd7055705c62\" target=\"_blank\" rel=\"external\">从前端开发看面向未来的敏捷学习法</a><br>授人以鱼不如授人以渔<br>前端技术更新速度很快，快速学习已经成了每个工程师必备技能。<br>除了掌握技术知识，解决问题的能力在实际项目中也很重要，文中以实际案例给出分解思路和系统敏捷学习新知识思路。</p>\n</li>\n<li><p><a href=\"https://zhuanlan.zhihu.com/p/26660510\" target=\"_blank\" rel=\"external\">前端工程师做事的三重境界：我的进阶之路</a><br>从程序员到工程师的进阶之路，精益求精才能称得上是工程师。作者认为这三个单词（Programmer、Developer、Enginner）对应不用的境界。</p>\n</li>\n<li><p><a href=\"http://louiszhai.github.io/2017/04/07/http-cache/\" target=\"_blank\" rel=\"external\">浏览器缓存机制剖析</a><br>正如文中所述“缓存一直是前端优化的主战场, 利用好缓存就成功了一半”，利用好缓存在前端优化地位中举足轻重，本文能够带领大家对浏览器缓存机制有一个初步了解。</p>\n</li>\n<li><p><a href=\"https://www.deboy.cn/Vue-mixins-advance-tips.html\" target=\"_blank\" rel=\"external\">vue-mixins使用注意事项和高级用法</a><br>在项目开发中经常会碰到两个组件的业务逻辑有所相似，可能共享相同的底层业务逻辑；此时需要考虑如何来合理地划分代码，即避免冗余代码，也不能过度抽象。</p>\n</li>\n<li><p><a href=\"https://www.toobug.net/article/array_unique_in_javascript.html\" target=\"_blank\" rel=\"external\">也谈JavaScript数组去重</a><br>去重，首先要思考什么是相等，从最初的循环，到Set集合。</p>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzIwNjQwMzUwMQ==&amp;mid=2247485277&amp;idx=1&amp;sn=82703e13febb1e7947cc18d1f57fc375&amp;key=6b0fbfcb936d93fa91a745202d0f37bffff65fd2cba5ff2cfa25618c8d03951944ae6eb2f4db18aaf1c8893ddaeffb404684dbd7f6159925dbab9411094f960daba3c6f46c1f93d34f9a6d476104fc63&amp;ascene=0&amp;uin=MTQwNzQzODYwMA%3D%3D&amp;version=12020810&amp;nettype=WIFI&amp;fontScale=100&amp;pass_ticket=xJ0pJsFuIsM3Ce35cuVqghSLUWaqU91w%2FEgBgn2%2BhouemlzbFvOIXP3KmJlioe0D\" target=\"_blank\" rel=\"external\">大前端公共知识梳理：这些知识你都掌握了吗？</a><br>文章覆盖非常全面，所介绍基础知识、技术栈、能力、领域有很多都是目前我所欠缺的，介于此推荐给大家。。。看完最直观的感受就是自己是个假前端</p>\n</li>\n<li><p><a href=\"https://segmentfault.com/a/1190000009885614\" target=\"_blank\" rel=\"external\">重温ES6核心概念和基本用法</a><br>文章梳理了ES6核心概念及基础用法，推荐给大家。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><ul>\n<li><p><a href=\"http://es6.ruanyifeng.com/#docs/promise\" target=\"_blank\" rel=\"external\">Promise</a><br>在Javascript的单线程异步架构下，Promise会是很多异步服务的核心知识点，Node 8.X已经可以方便的将回调方式转换为Promise。</p>\n</li>\n<li><p><a href=\"http://es6.ruanyifeng.com/#docs/async\" target=\"_blank\" rel=\"external\">异步函数async</a><br>使用异步函数可以实现“用同步的写法，完成异步的事情”，Node 8.X已经在编译器层面对async做了优化。</p>\n</li>\n<li><a href=\"http://semver.org/lang/zh-CN/\" target=\"_blank\" rel=\"external\">语义化版本 2.0.0</a><br>玩开源项目的基础，组件发布的约定。</li>\n<li><a href=\"https://docs.npmjs.com/files/package.json\" target=\"_blank\" rel=\"external\">package.json规则</a><br>项目的依赖列表，区别开发环境、生产环境、面向的平台和组件的规范（CMD、AMD和UMD）等。</li>\n</ul>\n<h2 id=\"单元测试工具\"><a href=\"#单元测试工具\" class=\"headerlink\" title=\"单元测试工具\"></a>单元测试工具</h2><p>Web 应用中的单元测试更加重要，在 Web 产品快速迭代的时期，每个测试用例都给应用的稳定性提供了一层保障。 API 升级，测试用例可以很好地检查代码是否向下兼容。 对于各种可能的输入，一旦测试覆盖，都能明确它的输出。 代码改动后，可以通过测试结果判断代码的改动是否影响已确定的结果。</p>\n<ul>\n<li><p><a href=\"https://mochajs.org/\" target=\"_blank\" rel=\"external\">mocha单元测试</a><br>NPM里每天有25W的下载量，同时支持Node、浏览器多平台的测试用例的执行。</p>\n</li>\n<li><p><a href=\"https://www.npmjs.com/package/power-assert\" target=\"_blank\" rel=\"external\">power-assert断言库</a><br>power-assert可以零学习成本，直观的展示出判断条件和结果。</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">1) Array #indexOf() should return index when the value is present:</div><div class=\"line\">     AssertionError: # path/to/test/mocha_node.js:10</div><div class=\"line\"></div><div class=\"line\">  assert(ary.indexOf(zero) === two)</div><div class=\"line\">         |   |       |     |   |</div><div class=\"line\">         |   |       |     |   2</div><div class=\"line\">         |   -1      0     false</div><div class=\"line\">         [1,2,3]</div><div class=\"line\"></div><div class=\"line\">  [number] two</div><div class=\"line\">  =&gt; 2</div><div class=\"line\">  [number] ary.indexOf(zero)</div><div class=\"line\">  =&gt; -1</div></pre></td></tr></table></figure>\n<h2 id=\"文章\"><a href=\"#文章\" class=\"headerlink\" title=\"文章\"></a>文章</h2><ul>\n<li><p><a href=\"https://github.com/mqyqingfeng/Blog/issues/22\" target=\"_blank\" rel=\"external\">JavaScript专题之跟着underscore学防抖</a><br>对防抖的原理介绍的很清晰，从最简单的实现版本一步一步讲解到实现复杂的版本。<br>让我对防抖有了重新的认识。</p>\n</li>\n<li><p><a href=\"http://www.jianshu.com/p/fd7055705c62\" target=\"_blank\" rel=\"external\">从前端开发看面向未来的敏捷学习法</a><br>授人以鱼不如授人以渔<br>前端技术更新速度很快，快速学习已经成了每个工程师必备技能。<br>除了掌握技术知识，解决问题的能力在实际项目中也很重要，文中以实际案例给出分解思路和系统敏捷学习新知识思路。</p>\n</li>\n<li><p><a href=\"https://zhuanlan.zhihu.com/p/26660510\" target=\"_blank\" rel=\"external\">前端工程师做事的三重境界：我的进阶之路</a><br>从程序员到工程师的进阶之路，精益求精才能称得上是工程师。作者认为这三个单词（Programmer、Developer、Enginner）对应不用的境界。</p>\n</li>\n<li><p><a href=\"http://louiszhai.github.io/2017/04/07/http-cache/\" target=\"_blank\" rel=\"external\">浏览器缓存机制剖析</a><br>正如文中所述“缓存一直是前端优化的主战场, 利用好缓存就成功了一半”，利用好缓存在前端优化地位中举足轻重，本文能够带领大家对浏览器缓存机制有一个初步了解。</p>\n</li>\n<li><p><a href=\"https://www.deboy.cn/Vue-mixins-advance-tips.html\" target=\"_blank\" rel=\"external\">vue-mixins使用注意事项和高级用法</a><br>在项目开发中经常会碰到两个组件的业务逻辑有所相似，可能共享相同的底层业务逻辑；此时需要考虑如何来合理地划分代码，即避免冗余代码，也不能过度抽象。</p>\n</li>\n<li><p><a href=\"https://www.toobug.net/article/array_unique_in_javascript.html\" target=\"_blank\" rel=\"external\">也谈JavaScript数组去重</a><br>去重，首先要思考什么是相等，从最初的循环，到Set集合。</p>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzIwNjQwMzUwMQ==&amp;mid=2247485277&amp;idx=1&amp;sn=82703e13febb1e7947cc18d1f57fc375&amp;key=6b0fbfcb936d93fa91a745202d0f37bffff65fd2cba5ff2cfa25618c8d03951944ae6eb2f4db18aaf1c8893ddaeffb404684dbd7f6159925dbab9411094f960daba3c6f46c1f93d34f9a6d476104fc63&amp;ascene=0&amp;uin=MTQwNzQzODYwMA%3D%3D&amp;version=12020810&amp;nettype=WIFI&amp;fontScale=100&amp;pass_ticket=xJ0pJsFuIsM3Ce35cuVqghSLUWaqU91w%2FEgBgn2%2BhouemlzbFvOIXP3KmJlioe0D\" target=\"_blank\" rel=\"external\">大前端公共知识梳理：这些知识你都掌握了吗？</a><br>文章覆盖非常全面，所介绍基础知识、技术栈、能力、领域有很多都是目前我所欠缺的，介于此推荐给大家。。。看完最直观的感受就是自己是个假前端</p>\n</li>\n<li><p><a href=\"https://segmentfault.com/a/1190000009885614\" target=\"_blank\" rel=\"external\">重温ES6核心概念和基本用法</a><br>文章梳理了ES6核心概念及基础用法，推荐给大家。</p>\n</li>\n</ul>\n"},{"title":"大前端周刊 第四期 （本期小编：李丽娇）","date":"2017-07-12T07:16:43.000Z","_content":"\n## 基础\n* [SVG的用法](http://www.webhek.com/post/svg.html)\n**SVG基础和使用介绍**\n\n* [浏览器的渲染原理简介](http://coolshell.cn/articles/9666.html)\n**由浅到深、简单易懂的浏览器渲染原理介绍**\n\n* [Mongoose学习参考文档——基础篇](http://ourjs.com/detail/53ad24edb984bb4659000013)\n**Nodejs使用MongoDB的详细介绍**\n\n\n## 文章\n* [ECMAScript 6 入门-Symbol](http://es6.ruanyifeng.com/#docs/symbol)\n  [symbols类型](http://www.infoq.com/cn/articles/es6-in-depth-symbols)\n<small>*推荐人：王祥*</small>\n继六种数据类型（Undefined、Null、Boolean、Number、String、Object）后，ES6又新增了Symbols类型。Symbols类型比较抽象，要了解相关的适应场景，可以看这两篇文章。\n\n* [Vue 与 iOS 的组件化](https://juejin.im/post/59626ca0f265da6c2442fbdf)\n<small>*推荐人：张成斌*</small>\n对Vue的组件化有一个非常清晰的讲解。组件化原理，组件化分，组件间传递都有涉及。另外笔者是一名普通的全职 iOS 开发者，还介绍iOS的组件化的东西，对前端和移动端进行了一些对比。\n\n* [SVG Sprite技术介绍](http://www.zhangxinxu.com/wordpress/2014/07/introduce-svg-sprite-technology/)\n<small>*推荐人：李丽娇*</small>\n使用svg文件显示小图标已经成为趋势，随之而来地，svg文件合并也成为必然需求。文中介绍了svg sprite的使用原理，并介绍了多种生成svg sprite的方式来满足偏前端、偏命令、偏设计各类coder的需求。\n\n* [ECharts 统计扩展教程](http://efe.baidu.com/blog/echarts-statistical-extension-tutorial/)\n<small>*推荐人：胡国伟*</small>\nECharts 统计扩展，包含的功能有直方图、聚类、回归、以及常用的汇总统计。通过统计扩展和 ECharts 的结合，可以使大家方便地实现可视分析，也就是将数据分析的结果，通过可视化直观地呈现出来。\n\n* [前端性能优化相关](https://github.com/wy-ei/notebook/issues/34#issuecomment-266946255)\n<small>*推荐人：陶明*</small>\n从多角度进行性能问题剖析，对JavaScript，DOM，CSS都介绍了性能优化方面的问题因素及解决方案；内容介绍不是很详细，例如对于debounce 进行消抖只是简单说明，这方面在第一期成斌有推荐详细的[文章](https://github.com/mqyqingfeng/Blog/issues/22)。\n\n* [JavaScript问题集锦](https://github.com/creeperyang/blog/issues/2)\n<small>*推荐人：李志伟*</small>\n文章整理了一些比较有价值且常见的JS问题，看似简单，但深究其原理还是很有必要的，相信对你的JS基础功底是个考验。\n\n* [浅谈 JS 对象之扩展、密封及冻结三大特性](https://segmentfault.com/a/1190000003894119)\n<small>*推荐人：耿少真*</small>\n由浅入深讨论JS中对象的扩展、密封及冻结特性，从三种不同的冻结程度介绍了 js 冻结对象的方法。\n##### 扩展特性:\n  - Object.isExtensible 方法\n  - Object.preventExtensions 方法\n##### 密封特性:\n  - Object.isSealed 方法\n  - Object.seal 方法\n##### 冻结特性\n  - Object.isFrozen 方法\n  - Object.freeze 方法\n\n* [十大经典排序算法](https://github.com/hustcc/JS-Sorting-Algorithm)\n<small>*推荐人：郭俊兵*</small>\n排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。\n\n* [Javascript模块化编程（一）：模块的写法](http://www.ruanyifeng.com/blog/2012/10/javascript_module.html)\n  [Javascript模块化编程（二）：AMD规范](http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html)\n  [Javascript模块化编程（三）：require.js的用法](http://www.ruanyifeng.com/blog/2012/11/require_js.html)\n<small>*推荐人：包京京*</small>\n阮一峰的文章最大的好处就是解释的清楚，很多大牛工程师不善表达，自己会但不一定能教得会。\n三篇系列文章介绍了：js模块花的基本概念，AMD规范以及require.js的实践。\n","source":"_posts/weekly-4.md","raw":"---\ntitle: 大前端周刊 第四期 （本期小编：李丽娇）\ndate: 2017-07-12 15:16:43\ntags: [weekly,Echarts,ES6,Vue,SVG,算法,模块化,性能优化]\n\n---\n\n## 基础\n* [SVG的用法](http://www.webhek.com/post/svg.html)\n**SVG基础和使用介绍**\n\n* [浏览器的渲染原理简介](http://coolshell.cn/articles/9666.html)\n**由浅到深、简单易懂的浏览器渲染原理介绍**\n\n* [Mongoose学习参考文档——基础篇](http://ourjs.com/detail/53ad24edb984bb4659000013)\n**Nodejs使用MongoDB的详细介绍**\n\n\n## 文章\n* [ECMAScript 6 入门-Symbol](http://es6.ruanyifeng.com/#docs/symbol)\n  [symbols类型](http://www.infoq.com/cn/articles/es6-in-depth-symbols)\n<small>*推荐人：王祥*</small>\n继六种数据类型（Undefined、Null、Boolean、Number、String、Object）后，ES6又新增了Symbols类型。Symbols类型比较抽象，要了解相关的适应场景，可以看这两篇文章。\n\n* [Vue 与 iOS 的组件化](https://juejin.im/post/59626ca0f265da6c2442fbdf)\n<small>*推荐人：张成斌*</small>\n对Vue的组件化有一个非常清晰的讲解。组件化原理，组件化分，组件间传递都有涉及。另外笔者是一名普通的全职 iOS 开发者，还介绍iOS的组件化的东西，对前端和移动端进行了一些对比。\n\n* [SVG Sprite技术介绍](http://www.zhangxinxu.com/wordpress/2014/07/introduce-svg-sprite-technology/)\n<small>*推荐人：李丽娇*</small>\n使用svg文件显示小图标已经成为趋势，随之而来地，svg文件合并也成为必然需求。文中介绍了svg sprite的使用原理，并介绍了多种生成svg sprite的方式来满足偏前端、偏命令、偏设计各类coder的需求。\n\n* [ECharts 统计扩展教程](http://efe.baidu.com/blog/echarts-statistical-extension-tutorial/)\n<small>*推荐人：胡国伟*</small>\nECharts 统计扩展，包含的功能有直方图、聚类、回归、以及常用的汇总统计。通过统计扩展和 ECharts 的结合，可以使大家方便地实现可视分析，也就是将数据分析的结果，通过可视化直观地呈现出来。\n\n* [前端性能优化相关](https://github.com/wy-ei/notebook/issues/34#issuecomment-266946255)\n<small>*推荐人：陶明*</small>\n从多角度进行性能问题剖析，对JavaScript，DOM，CSS都介绍了性能优化方面的问题因素及解决方案；内容介绍不是很详细，例如对于debounce 进行消抖只是简单说明，这方面在第一期成斌有推荐详细的[文章](https://github.com/mqyqingfeng/Blog/issues/22)。\n\n* [JavaScript问题集锦](https://github.com/creeperyang/blog/issues/2)\n<small>*推荐人：李志伟*</small>\n文章整理了一些比较有价值且常见的JS问题，看似简单，但深究其原理还是很有必要的，相信对你的JS基础功底是个考验。\n\n* [浅谈 JS 对象之扩展、密封及冻结三大特性](https://segmentfault.com/a/1190000003894119)\n<small>*推荐人：耿少真*</small>\n由浅入深讨论JS中对象的扩展、密封及冻结特性，从三种不同的冻结程度介绍了 js 冻结对象的方法。\n##### 扩展特性:\n  - Object.isExtensible 方法\n  - Object.preventExtensions 方法\n##### 密封特性:\n  - Object.isSealed 方法\n  - Object.seal 方法\n##### 冻结特性\n  - Object.isFrozen 方法\n  - Object.freeze 方法\n\n* [十大经典排序算法](https://github.com/hustcc/JS-Sorting-Algorithm)\n<small>*推荐人：郭俊兵*</small>\n排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。\n\n* [Javascript模块化编程（一）：模块的写法](http://www.ruanyifeng.com/blog/2012/10/javascript_module.html)\n  [Javascript模块化编程（二）：AMD规范](http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html)\n  [Javascript模块化编程（三）：require.js的用法](http://www.ruanyifeng.com/blog/2012/11/require_js.html)\n<small>*推荐人：包京京*</small>\n阮一峰的文章最大的好处就是解释的清楚，很多大牛工程师不善表达，自己会但不一定能教得会。\n三篇系列文章介绍了：js模块花的基本概念，AMD规范以及require.js的实践。\n","slug":"weekly-4","published":1,"updated":"2017-08-09T02:50:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6i92aur0004e1txbfmr1c3a","content":"<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><ul>\n<li><p><a href=\"http://www.webhek.com/post/svg.html\" target=\"_blank\" rel=\"external\">SVG的用法</a><br><strong>SVG基础和使用介绍</strong></p>\n</li>\n<li><p><a href=\"http://coolshell.cn/articles/9666.html\" target=\"_blank\" rel=\"external\">浏览器的渲染原理简介</a><br><strong>由浅到深、简单易懂的浏览器渲染原理介绍</strong></p>\n</li>\n<li><p><a href=\"http://ourjs.com/detail/53ad24edb984bb4659000013\" target=\"_blank\" rel=\"external\">Mongoose学习参考文档——基础篇</a><br><strong>Nodejs使用MongoDB的详细介绍</strong></p>\n</li>\n</ul>\n<h2 id=\"文章\"><a href=\"#文章\" class=\"headerlink\" title=\"文章\"></a>文章</h2><ul>\n<li><p><a href=\"http://es6.ruanyifeng.com/#docs/symbol\" target=\"_blank\" rel=\"external\">ECMAScript 6 入门-Symbol</a><br><a href=\"http://www.infoq.com/cn/articles/es6-in-depth-symbols\" target=\"_blank\" rel=\"external\">symbols类型</a><br><small><em>推荐人：王祥</em></small><br>继六种数据类型（Undefined、Null、Boolean、Number、String、Object）后，ES6又新增了Symbols类型。Symbols类型比较抽象，要了解相关的适应场景，可以看这两篇文章。</p>\n</li>\n<li><p><a href=\"https://juejin.im/post/59626ca0f265da6c2442fbdf\" target=\"_blank\" rel=\"external\">Vue 与 iOS 的组件化</a><br><small><em>推荐人：张成斌</em></small><br>对Vue的组件化有一个非常清晰的讲解。组件化原理，组件化分，组件间传递都有涉及。另外笔者是一名普通的全职 iOS 开发者，还介绍iOS的组件化的东西，对前端和移动端进行了一些对比。</p>\n</li>\n<li><p><a href=\"http://www.zhangxinxu.com/wordpress/2014/07/introduce-svg-sprite-technology/\" target=\"_blank\" rel=\"external\">SVG Sprite技术介绍</a><br><small><em>推荐人：李丽娇</em></small><br>使用svg文件显示小图标已经成为趋势，随之而来地，svg文件合并也成为必然需求。文中介绍了svg sprite的使用原理，并介绍了多种生成svg sprite的方式来满足偏前端、偏命令、偏设计各类coder的需求。</p>\n</li>\n<li><p><a href=\"http://efe.baidu.com/blog/echarts-statistical-extension-tutorial/\" target=\"_blank\" rel=\"external\">ECharts 统计扩展教程</a><br><small><em>推荐人：胡国伟</em></small><br>ECharts 统计扩展，包含的功能有直方图、聚类、回归、以及常用的汇总统计。通过统计扩展和 ECharts 的结合，可以使大家方便地实现可视分析，也就是将数据分析的结果，通过可视化直观地呈现出来。</p>\n</li>\n<li><p><a href=\"https://github.com/wy-ei/notebook/issues/34#issuecomment-266946255\" target=\"_blank\" rel=\"external\">前端性能优化相关</a><br><small><em>推荐人：陶明</em></small><br>从多角度进行性能问题剖析，对JavaScript，DOM，CSS都介绍了性能优化方面的问题因素及解决方案；内容介绍不是很详细，例如对于debounce 进行消抖只是简单说明，这方面在第一期成斌有推荐详细的<a href=\"https://github.com/mqyqingfeng/Blog/issues/22\" target=\"_blank\" rel=\"external\">文章</a>。</p>\n</li>\n<li><p><a href=\"https://github.com/creeperyang/blog/issues/2\" target=\"_blank\" rel=\"external\">JavaScript问题集锦</a><br><small><em>推荐人：李志伟</em></small><br>文章整理了一些比较有价值且常见的JS问题，看似简单，但深究其原理还是很有必要的，相信对你的JS基础功底是个考验。</p>\n</li>\n<li><p><a href=\"https://segmentfault.com/a/1190000003894119\" target=\"_blank\" rel=\"external\">浅谈 JS 对象之扩展、密封及冻结三大特性</a><br><small><em>推荐人：耿少真</em></small><br>由浅入深讨论JS中对象的扩展、密封及冻结特性，从三种不同的冻结程度介绍了 js 冻结对象的方法。</p>\n<h5 id=\"扩展特性\"><a href=\"#扩展特性\" class=\"headerlink\" title=\"扩展特性:\"></a>扩展特性:</h5><ul>\n<li>Object.isExtensible 方法</li>\n<li>Object.preventExtensions 方法<h5 id=\"密封特性\"><a href=\"#密封特性\" class=\"headerlink\" title=\"密封特性:\"></a>密封特性:</h5></li>\n<li>Object.isSealed 方法</li>\n<li>Object.seal 方法<h5 id=\"冻结特性\"><a href=\"#冻结特性\" class=\"headerlink\" title=\"冻结特性\"></a>冻结特性</h5></li>\n<li>Object.isFrozen 方法</li>\n<li>Object.freeze 方法</li>\n</ul>\n</li>\n<li><p><a href=\"https://github.com/hustcc/JS-Sorting-Algorithm\" target=\"_blank\" rel=\"external\">十大经典排序算法</a><br><small><em>推荐人：郭俊兵</em></small><br>排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。</p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2012/10/javascript_module.html\" target=\"_blank\" rel=\"external\">Javascript模块化编程（一）：模块的写法</a><br><a href=\"http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html\" target=\"_blank\" rel=\"external\">Javascript模块化编程（二）：AMD规范</a><br><a href=\"http://www.ruanyifeng.com/blog/2012/11/require_js.html\" target=\"_blank\" rel=\"external\">Javascript模块化编程（三）：require.js的用法</a><br><small><em>推荐人：包京京</em></small><br>阮一峰的文章最大的好处就是解释的清楚，很多大牛工程师不善表达，自己会但不一定能教得会。<br>三篇系列文章介绍了：js模块花的基本概念，AMD规范以及require.js的实践。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><ul>\n<li><p><a href=\"http://www.webhek.com/post/svg.html\" target=\"_blank\" rel=\"external\">SVG的用法</a><br><strong>SVG基础和使用介绍</strong></p>\n</li>\n<li><p><a href=\"http://coolshell.cn/articles/9666.html\" target=\"_blank\" rel=\"external\">浏览器的渲染原理简介</a><br><strong>由浅到深、简单易懂的浏览器渲染原理介绍</strong></p>\n</li>\n<li><p><a href=\"http://ourjs.com/detail/53ad24edb984bb4659000013\" target=\"_blank\" rel=\"external\">Mongoose学习参考文档——基础篇</a><br><strong>Nodejs使用MongoDB的详细介绍</strong></p>\n</li>\n</ul>\n<h2 id=\"文章\"><a href=\"#文章\" class=\"headerlink\" title=\"文章\"></a>文章</h2><ul>\n<li><p><a href=\"http://es6.ruanyifeng.com/#docs/symbol\" target=\"_blank\" rel=\"external\">ECMAScript 6 入门-Symbol</a><br><a href=\"http://www.infoq.com/cn/articles/es6-in-depth-symbols\" target=\"_blank\" rel=\"external\">symbols类型</a><br><small><em>推荐人：王祥</em></small><br>继六种数据类型（Undefined、Null、Boolean、Number、String、Object）后，ES6又新增了Symbols类型。Symbols类型比较抽象，要了解相关的适应场景，可以看这两篇文章。</p>\n</li>\n<li><p><a href=\"https://juejin.im/post/59626ca0f265da6c2442fbdf\" target=\"_blank\" rel=\"external\">Vue 与 iOS 的组件化</a><br><small><em>推荐人：张成斌</em></small><br>对Vue的组件化有一个非常清晰的讲解。组件化原理，组件化分，组件间传递都有涉及。另外笔者是一名普通的全职 iOS 开发者，还介绍iOS的组件化的东西，对前端和移动端进行了一些对比。</p>\n</li>\n<li><p><a href=\"http://www.zhangxinxu.com/wordpress/2014/07/introduce-svg-sprite-technology/\" target=\"_blank\" rel=\"external\">SVG Sprite技术介绍</a><br><small><em>推荐人：李丽娇</em></small><br>使用svg文件显示小图标已经成为趋势，随之而来地，svg文件合并也成为必然需求。文中介绍了svg sprite的使用原理，并介绍了多种生成svg sprite的方式来满足偏前端、偏命令、偏设计各类coder的需求。</p>\n</li>\n<li><p><a href=\"http://efe.baidu.com/blog/echarts-statistical-extension-tutorial/\" target=\"_blank\" rel=\"external\">ECharts 统计扩展教程</a><br><small><em>推荐人：胡国伟</em></small><br>ECharts 统计扩展，包含的功能有直方图、聚类、回归、以及常用的汇总统计。通过统计扩展和 ECharts 的结合，可以使大家方便地实现可视分析，也就是将数据分析的结果，通过可视化直观地呈现出来。</p>\n</li>\n<li><p><a href=\"https://github.com/wy-ei/notebook/issues/34#issuecomment-266946255\" target=\"_blank\" rel=\"external\">前端性能优化相关</a><br><small><em>推荐人：陶明</em></small><br>从多角度进行性能问题剖析，对JavaScript，DOM，CSS都介绍了性能优化方面的问题因素及解决方案；内容介绍不是很详细，例如对于debounce 进行消抖只是简单说明，这方面在第一期成斌有推荐详细的<a href=\"https://github.com/mqyqingfeng/Blog/issues/22\" target=\"_blank\" rel=\"external\">文章</a>。</p>\n</li>\n<li><p><a href=\"https://github.com/creeperyang/blog/issues/2\" target=\"_blank\" rel=\"external\">JavaScript问题集锦</a><br><small><em>推荐人：李志伟</em></small><br>文章整理了一些比较有价值且常见的JS问题，看似简单，但深究其原理还是很有必要的，相信对你的JS基础功底是个考验。</p>\n</li>\n<li><p><a href=\"https://segmentfault.com/a/1190000003894119\" target=\"_blank\" rel=\"external\">浅谈 JS 对象之扩展、密封及冻结三大特性</a><br><small><em>推荐人：耿少真</em></small><br>由浅入深讨论JS中对象的扩展、密封及冻结特性，从三种不同的冻结程度介绍了 js 冻结对象的方法。</p>\n<h5 id=\"扩展特性\"><a href=\"#扩展特性\" class=\"headerlink\" title=\"扩展特性:\"></a>扩展特性:</h5><ul>\n<li>Object.isExtensible 方法</li>\n<li>Object.preventExtensions 方法<h5 id=\"密封特性\"><a href=\"#密封特性\" class=\"headerlink\" title=\"密封特性:\"></a>密封特性:</h5></li>\n<li>Object.isSealed 方法</li>\n<li>Object.seal 方法<h5 id=\"冻结特性\"><a href=\"#冻结特性\" class=\"headerlink\" title=\"冻结特性\"></a>冻结特性</h5></li>\n<li>Object.isFrozen 方法</li>\n<li>Object.freeze 方法</li>\n</ul>\n</li>\n<li><p><a href=\"https://github.com/hustcc/JS-Sorting-Algorithm\" target=\"_blank\" rel=\"external\">十大经典排序算法</a><br><small><em>推荐人：郭俊兵</em></small><br>排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。</p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2012/10/javascript_module.html\" target=\"_blank\" rel=\"external\">Javascript模块化编程（一）：模块的写法</a><br><a href=\"http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html\" target=\"_blank\" rel=\"external\">Javascript模块化编程（二）：AMD规范</a><br><a href=\"http://www.ruanyifeng.com/blog/2012/11/require_js.html\" target=\"_blank\" rel=\"external\">Javascript模块化编程（三）：require.js的用法</a><br><small><em>推荐人：包京京</em></small><br>阮一峰的文章最大的好处就是解释的清楚，很多大牛工程师不善表达，自己会但不一定能教得会。<br>三篇系列文章介绍了：js模块花的基本概念，AMD规范以及require.js的实践。</p>\n</li>\n</ul>\n"},{"title":"5 Protocols For Event-Driven API Architectures","date":"2017-07-21T04:00:00.000Z","_content":"\n原文：[5 Protocols For Event-Driven API Architectures](http://nordicapis.com/5-protocols-for-event-driven-api-architectures/)\n\nThe internet is a system of communication, and as such, the relationship between client and server, as well as server to server, is one of the most oft-discussed and hotly contested concepts. **event-driven architecture** is a methodology of defining these relationships, and creating systems within a specific set of relationships that allow for extensive functionality.\n\nIn this piece, we’re going to discuss 5 common event-driven methods — **WebSockets**, **WebHooks**, **REST Hooks**, **Pub-Sub**, and **Server Sent Events**. We’ll define what they fundamentally are and do, and how API providers go about using them. Additionally, we’ll provide some pros and cons on each to make choosing a solution for your platform easy and intuitive.\n\n## What is an Event-Driven Architecture?\n\nEvent-driven architectures establish an event that can be consumed and reacted to. But what is an event?\n\nAn event is essentially any significant **change** from one state to another, such as the change from having no messages in your inbox to have a new message in your inbox. This state can be reacted to **internally** (such as when the email program in question realizes a new message has been received), **externally** (when a user sees a notification for a new message), or used to **generate another event** (for instance, the message tally increases by one).\n\nEvent-driven architectures are appealing to API developers because they function very well in **asynchronous** environments. By crafting APIs that **trigger** certain functions on new event delivery, API systems don’t have to inherently wait for synchronous delivery or real time communication. This is hugely beneficial, as eliminating the need to constantly poll endpoints frees resources from otherwise wasteful purposes, reducing both general hardware requirements and call-specific overhead.\n\nFor this reason, event-driven architectures are very, very popular, and lead to improved power, bandwidth, and co-processing than other solutions and architectures such as polling and other poll-centric derivatives.\n\n## 5 Types of Event-Driven Protocols for APIs\n\n### 1: WebSockets\n\n**WebSockets** are an interesting event-driven solution, because, for most browsers, they’re actually baked into the application itself. Essentially, WebSocket is a protocol that provides full-duplex communication on a single TCP connection. It was standardized by the Internet Engineering Task Force as [RFC 6455](https://tools.ietf.org/html/rfc6455), and the WebSocket API in Web IDL was later standardized under the W3C banner.\n\nWhile the protocol itself is meant to be used between **web browsers** and **servers**, the protocol can be used in any case where there is a client-server relationship. The protocol itself is based upon TCP, with the additional HTTP interpretation statement that is considered an “Upgrade request” to allow for interoperability.\n\n#### Pros\nBecause WebSocket is expressly designed for browser operation, it boasts extremely **low overhead** for what it actually does. By establishing a **full-duplex** conversation using a standardized methodology, connection both to and from the two entities can take place simultaneously, resulting in lower overhead and better throughput.\n\nAdditionally, the fact that these communications take place over TCP 80/443 means that environments that traditionally block non-web based applications for security reasons can still handle this protocol, as firewalls allow communication to and from this port.\n\nPerhaps the strongest argument for the use of WebSockets are the fact that they are standardized and **natively supported** by all major browsers, ranging from Microsft Edge to Opera, from Firefox to Chrome. This means that any web application that ties into it will be interactable within the vast majority of both browser-based and browser-independent gateways and applications.\n\n#### Cons\nWebSockets have one distinct major failing — while it might have support for HTTP-like functionality, **it is not HTTP** whatsoever. This has implications, especially when considering optimizing in HTTP such as caching, proxying, etc., that haven’t quite become apparent.\n\nBecause WebSockets are relatively new, having been only officially standardized in 2011, the industry is still understanding what the side effects mean. Most applications that use WebSockets are designed specifically for everything that a WebSocket is — what has yet to be seen, however, is whether or not this solution is better in the long-run than any stateless solution currently available.\n\nThere is of course the fact that, as with other architectures on this list, WebSockets create an “always on” connection during the duration of data transfer. While this is fine for many uses such as media streaming and live stream calculations, it also essentially means that, for WebSockets, there is no scalability. Ports have hardcoded limitations and bandwidth, and thus in order to “scale”, you must add additional ports to match the maximum load. In stateless systems, this is less of an issue, as requests can wait and be made in such a way as to be independent on the state of the server itself.\n\n### 2: WebHooks\n**WebHooks** are a similar concept to the WebSocket. They primarily function using **custom callbacks**, or code that is passed as an argument to another chunk of code and executed at a specified point in time. Essentially, a WebHook is a glorified system of “if this, then do”, allowing for users independent of the event firing to craft a custom response to that event within their own system.\n\nThe term was coined by [Jeff Lindsay](https://twitter.com/progrium) in 2007, and quickly became popular amongst users who wished to create automated responses to exterior behaviors. A great example of this would be a developer pushing a new item to GitHub, which causes an event. A user has a system tied into the URI of a WebHook. When the push is published, the user’s system utilizes the URI of the WebHook to integrate the push into a larger build, thereby creating a compiled component.\n\n#### Pros\nWebHooks function a lot like WebSockets, but they’re different in some key areas. First and foremost, WebSockets are primarily designed for browser-based communications, and while they can be used regardless in any client-server communication, they do not behave well in a **server-to-server** setup.\n\nWebHooks, on the other hand, work very well in server-to-server systems due to how they operate. Because the system essentially functions as the aforementioned “if this then do”, servers can be configured to tie into pre-formed URIs at any time and execute a given function whenever that event is triggered.\n\nAdditionally, WebHooks have the unique benefit of being **based upon HTTP**, unlike WebSockets. This means that the system can be integrated without utilizing any new infrastructure, allowing speedy adoption and relatively simple setup.\n\n#### Cons\nThe problem with WebHooks is that a lot of their functionality can already be placed on the arguably more powerful REST architectural approach. While adopting event-driven architecture is often a requirement of the service being built, it’s a hard sell when it can be mirrored in REST while also giving the wealth of options that REST gives to the user.\n\nThese RESTful solutions such as [RestMS](http://www.restms.org/) are essentially simply message querying services, though, and do require additional infrastructure, which may or may not be doable considering the purpose of the application.\n\nAdditionally, WebHooks can be **resource intensive** to both the client and the server. If the client needs to notify many servers that an event has occurred, and a server needs to listen to a great deal of clients notifying of this change, you can very quickly run into a situation where your network grows uncontrollably. While HTTP does scale quite well, this is a definite negative to consider.\n\nHowever, there are also ways to build a [message queuing service](https://en.wikipedia.org/wiki/Message_queuing_service) on top of HTTP—some RESTful examples include [IronMQ](https://www.iron.io/platform/ironmq/) and RestMS.\n\n### 3: REST Hooks\nSpeaking of RESTful examples, **REST Hooks** is essentially “hooking” baked into REST itself. Defined as an initiative from [Zapier](http://resthooks.org/docs/), this is a subject [we’ve covered before](http://nordicapis.com/stop-polling-and-consider-using-rest-hooks/) — hooks are collated to a single target URL as a subscription, which pings the resource requester when a change is noted.\n\nThis approach is a response to the practice of **polling**, in which a client constantly checks for changes to a resource. Under the REST Hooks paradigm, the client instead waits for a change, and reacts to it. To put it simply, this is a WebHook in REST.\n\n#### Pros\nREST Hooks are obviously super powerful in the correct context — being able to passively receive a resource rather than dedicating processing power to constant polling frees up a lot of the client-side cost.\n\nPerhaps the strongest argument for REST Hooks though, is the fact that it’s **so easy** and **intuitive** to use. While WebHooks utilize HTTP and thus do not need new architecture to set up, they are also limited by the fact that they are built upon HTTP, and can thus be somewhat complex to set up properly and use effectively.\n\nREST Hooks, though, are **subscription based**, and as such, are simply usable by subscribing. This makes it a very easy to use solution while providing a lot of the usability and effectiveness of more complex systems.\n\n#### Cons\nOf course, every solution has its negatives, and REST Hooks are no different. It could be viewed that REST Hooks actually fly in the face of what REST is — [session free and stateless](http://nordicapis.com/defining-stateful-vs-stateless-web-services/). REST Hooks essentially create consistent polling, it’s just moved the polling from one side to another.\n\nThen, there’s the arguable problem that REST Hooks might be doing something that has already been solved. Some would argue that TCP already does most of what REST Hooks is trying to do, and simply layering more solutions on top of HTTP to get what TCP already does is a poor approach.\n\n### 4: Pub-Sub\n**Pub-Sub** is a slightly different approach. Referred to by its full name as **publish-subscribe**, the concept is where events are published to a class without knowledge of the client subscribing to the class. Basically, a user will join one or more classes, and then will receive event updates without regard or knowledge to the event publisher.\n\nThe main difference here is one of conscious choice of provider — in the other solutions noted herein, a user consciously communicates with a given server or provider and receives events as pre-determined. Under the Pub-Sub scheme, the user only specifies which class they wish to be part of and what events they are interested in receiving. From there, they receive these events when one is pushed out.\n\nA way this is often framed in internet discussions is in the frame of a **radio channel**. Record companies, or publishers, issue audio to the station, which then broadcasts this audio to listeners, or subscribers. Pub-sub is the middleman radio station here — listeners don’t know who gave the station the music, nor do the companies know who the listeners are. It is this segmentation that is baked into the pattern.\n\nWhen we talk about Pub-Sub, we need to keep in mind that we’re actually talking about two different things. Pub-Sub can mean the methodology and general concept in programming terms, but it can also mean specific provider solutions based upon that methodology. For instance, Google’s [Cloud Pub/Sub](https://cloud.google.com/pubsub/docs/overview) is an implementation of the general methodology within their cloud service, and allows for asynchronous many-to-many pub-sub relationships as stated above.\n\n#### Pros\nA huge benefit of Pub-Sub is the fact that it’s **loosely coupled**, and thus is extremely scalable and flexible. The only thing the event-provider is doing is generating the content — each other step is done through a separated middleman, and so the content is easily scaled and modulated to the architecture and design of the solution.\n\nAdditionally, Pub-Sub lends itself very well to **testing**. A subscriber is narrowly limited to a set of events that they have requested under a class, so if a failure occurs, this natural segmentation informs the provider as to where the fault is, and which class of users is experiencing the fault.\n\n#### Cons\nUnfortunately, decoupling is also a huge disadvantage for this pattern. By being a **middleman**, Pub-Sub cannot effectively notify the provider that a message has been sent, and the listener is separated from the event and thus may not know if a message wasn’t sent that should have been. Harkening back to the radio explanation, a listener will never know if a song was meant to play on a channel or if the channel is out of range, and once the record executives hand off the music, they’ve got no idea if the user received the songs without direct feedback from them.\n\nAdditionally, while the system is extensible and flexible, instability does occur with high traffic load as subclass after subclass might be constructed to handle further segmentation. This of course leads to the aforementioned instability in addition to increased complexity.\n\nYou must keep in mind that while the relationship between the publisher and subscriber in this model may be beneficial, it also comes with its own difficulties when these relationships need to be modulated. While you can certainly work around this, at this point, you’re fighting the very basis of the pattern, rather than any secondary natures — you’re trying to make dehydrated water, and fighting against the nature of a pattern suggests the pattern to be inherently poor.\n\n> Also read: [Building a Backend for Frontend (BFF) For Your Microservices](http://nordicapis.com/building-a-backend-for-frontend-shim-for-your-microservices/)\n\n### 5: Server Sent Events\n**Server Sent Events**, or SSE, is a communication protocol much like WebSockets, but with the implication of **unidirectional data**. In this architecture, the server is consistently sending updates to the client as an automatic process. This was standardized under HTML5 by the [W3C](https://www.w3.org/TR/2009/WD-eventsource-20091029/), and is thus compatible with any solution that is likewise compatible with HTML5.\n\n> Of note is that there is a competing standardization from the [Web Hypertext Application Technology Working Group](https://whatwg.org/) – this is a relic from movement away from “HTML5” and into what WHATWG is calling “HTML Living Standard”. The general working consensus is that, WHATWG’s standardization is prioritized in the rare cases of divergent standards. This could become more of an issue as time marches forward, given that WHATWG was created due to a perceived lack of interest from W3C towards evolving HTML, but for the time being, either standard is generally acceptable.\nWhile simple in theory, Server Sent Events are anything but simple when considering benefits and drawbacks.\n\n#### Pros\nSSE is **not bidirectional** in its communications — the server is issuing the events in a steady, predictable method. This is hugely beneficial to applications which do not need the two-way communications baked into WebSockets or other such solutions, as this means **lower bandwidth**, and an allowance for the connection to be temporary rather than always-on during the duration of data transfer. By its nature, the data is being transferred one way, and thus there is no need to wait for data to be returned.\n\nAdditionally, at least in theory, SSE is easier to set up in complex situations. You only have to worry about data traveling one direction via one system, thus reducing complexity dramatically. There is no need to define a message exchange protocol, no need to specify data duration or wait times, no need to support bilateral messaging — the single direction saves a lot of complexity.\n\n#### Cons\nThat simplicity could be where SSE fails for particular use cases. SSE is a very poor solution for situations that require **bidirectional communication**, and while this seems obvious, it would surprise many developers to see how many systems actually depend on bidirectional communication for simple functionality.\n\nWhile much of this can be fixed with workarounds, a developer’s goal in choosing an event-driven protocol should be to find one that works out of the box, not to find a solution that might work if configured properly and given secondary systems upon which to depend.\n\nThere is also the issue of **security** and authentication. While two-way systems can easily use authentication methodologies, SSE handles this using **header forwarding**. While headers can be manipulated and overridden in many languages and applications, the EventSource object in JavaScript does not natively support this, which would cause many adoptees some major headaches.\n\nFinally, there is a concern over loss of efficiency with **over transmitting** data. A two-direction system can determine when a client or server disconnects, but SSE can only determine that a client has disconnected after attempting a full data transmission and receiving a noted failure. Because of this, data can be lost rather quickly, and with many failed connections, this loss can mount dramatically over time.\n\n## Conclusion\nThere is no one event-driven solution that works in every use case. While many would argue that event-driven solutions should be REST based, which suggests REST Hooks as the answer, many others would argue that it is entirely situational, and that REST is not always the silver bullet it’s touted to be.\n\nIf you are building for scalability with low overhead in a browser environment, **WebSockets** are a great solution. Conversely, if you’d like those same benefits but are working in a non-browser system, then **WebHooks** should be your approach. **REST Hooks** are not only great for RESTful services, they’re also much easier to set up than either, and thus are great in low-time high-rush situations. **Pub-Sub** can be great if you need to enforce a division between client and server, and this can further be established and controlled in an even stronger way with **Server Sent**.\n\nSimply put, the best solution will be the one that fits your specific situation and build — any of these solutions, given the correct system, is a great solution. To that end, each solution has a very specific use case.\n\n## TLDR Comparison Table\n| PROTOCOL | RELATED TO | STANDARD BODY | NOTES |\n| ------ | ------ | ------ | ------ |\n| WebSockets | TCP, HTTP-like | IETF, W3C | Two-way communication over TCP<br>Designed for web browsers & web servers<br>Good for lower overhead scenarios<br>Supported in all major browsers |\n| Webhooks | URI, HTTP | - | User defined “HTTP callbacks”<br>Triggered by an event HTTP<br>Requests are made to Webhook URI<br>Enables real-time event triggering|\n| REST Hooks | HTTP | Zapier | Lightweight subscription layer<br>Manipulated by a REST API<br>Essentially a WebHook in REST |\n| Pub-Sub | - | - |Client subscribes to classes<br>Bidirectional<br>Middleman layer between client and server<br>Loose coupling|\n| Server Sent | HTTP, HTML5 , DOM | WHATWG, W3C |Server constantly sends updates to the client<br>Unidirectional push notifications as DOM events|\n","source":"_posts/5-protocols-for-event-driven-api-architectures.md","raw":"---\ntitle: 5 Protocols For Event-Driven API Architectures\ndate: 2017-07-21 12:00:00\ntags: [Event-Driven,全栈,Node]\n---\n\n原文：[5 Protocols For Event-Driven API Architectures](http://nordicapis.com/5-protocols-for-event-driven-api-architectures/)\n\nThe internet is a system of communication, and as such, the relationship between client and server, as well as server to server, is one of the most oft-discussed and hotly contested concepts. **event-driven architecture** is a methodology of defining these relationships, and creating systems within a specific set of relationships that allow for extensive functionality.\n\nIn this piece, we’re going to discuss 5 common event-driven methods — **WebSockets**, **WebHooks**, **REST Hooks**, **Pub-Sub**, and **Server Sent Events**. We’ll define what they fundamentally are and do, and how API providers go about using them. Additionally, we’ll provide some pros and cons on each to make choosing a solution for your platform easy and intuitive.\n\n## What is an Event-Driven Architecture?\n\nEvent-driven architectures establish an event that can be consumed and reacted to. But what is an event?\n\nAn event is essentially any significant **change** from one state to another, such as the change from having no messages in your inbox to have a new message in your inbox. This state can be reacted to **internally** (such as when the email program in question realizes a new message has been received), **externally** (when a user sees a notification for a new message), or used to **generate another event** (for instance, the message tally increases by one).\n\nEvent-driven architectures are appealing to API developers because they function very well in **asynchronous** environments. By crafting APIs that **trigger** certain functions on new event delivery, API systems don’t have to inherently wait for synchronous delivery or real time communication. This is hugely beneficial, as eliminating the need to constantly poll endpoints frees resources from otherwise wasteful purposes, reducing both general hardware requirements and call-specific overhead.\n\nFor this reason, event-driven architectures are very, very popular, and lead to improved power, bandwidth, and co-processing than other solutions and architectures such as polling and other poll-centric derivatives.\n\n## 5 Types of Event-Driven Protocols for APIs\n\n### 1: WebSockets\n\n**WebSockets** are an interesting event-driven solution, because, for most browsers, they’re actually baked into the application itself. Essentially, WebSocket is a protocol that provides full-duplex communication on a single TCP connection. It was standardized by the Internet Engineering Task Force as [RFC 6455](https://tools.ietf.org/html/rfc6455), and the WebSocket API in Web IDL was later standardized under the W3C banner.\n\nWhile the protocol itself is meant to be used between **web browsers** and **servers**, the protocol can be used in any case where there is a client-server relationship. The protocol itself is based upon TCP, with the additional HTTP interpretation statement that is considered an “Upgrade request” to allow for interoperability.\n\n#### Pros\nBecause WebSocket is expressly designed for browser operation, it boasts extremely **low overhead** for what it actually does. By establishing a **full-duplex** conversation using a standardized methodology, connection both to and from the two entities can take place simultaneously, resulting in lower overhead and better throughput.\n\nAdditionally, the fact that these communications take place over TCP 80/443 means that environments that traditionally block non-web based applications for security reasons can still handle this protocol, as firewalls allow communication to and from this port.\n\nPerhaps the strongest argument for the use of WebSockets are the fact that they are standardized and **natively supported** by all major browsers, ranging from Microsft Edge to Opera, from Firefox to Chrome. This means that any web application that ties into it will be interactable within the vast majority of both browser-based and browser-independent gateways and applications.\n\n#### Cons\nWebSockets have one distinct major failing — while it might have support for HTTP-like functionality, **it is not HTTP** whatsoever. This has implications, especially when considering optimizing in HTTP such as caching, proxying, etc., that haven’t quite become apparent.\n\nBecause WebSockets are relatively new, having been only officially standardized in 2011, the industry is still understanding what the side effects mean. Most applications that use WebSockets are designed specifically for everything that a WebSocket is — what has yet to be seen, however, is whether or not this solution is better in the long-run than any stateless solution currently available.\n\nThere is of course the fact that, as with other architectures on this list, WebSockets create an “always on” connection during the duration of data transfer. While this is fine for many uses such as media streaming and live stream calculations, it also essentially means that, for WebSockets, there is no scalability. Ports have hardcoded limitations and bandwidth, and thus in order to “scale”, you must add additional ports to match the maximum load. In stateless systems, this is less of an issue, as requests can wait and be made in such a way as to be independent on the state of the server itself.\n\n### 2: WebHooks\n**WebHooks** are a similar concept to the WebSocket. They primarily function using **custom callbacks**, or code that is passed as an argument to another chunk of code and executed at a specified point in time. Essentially, a WebHook is a glorified system of “if this, then do”, allowing for users independent of the event firing to craft a custom response to that event within their own system.\n\nThe term was coined by [Jeff Lindsay](https://twitter.com/progrium) in 2007, and quickly became popular amongst users who wished to create automated responses to exterior behaviors. A great example of this would be a developer pushing a new item to GitHub, which causes an event. A user has a system tied into the URI of a WebHook. When the push is published, the user’s system utilizes the URI of the WebHook to integrate the push into a larger build, thereby creating a compiled component.\n\n#### Pros\nWebHooks function a lot like WebSockets, but they’re different in some key areas. First and foremost, WebSockets are primarily designed for browser-based communications, and while they can be used regardless in any client-server communication, they do not behave well in a **server-to-server** setup.\n\nWebHooks, on the other hand, work very well in server-to-server systems due to how they operate. Because the system essentially functions as the aforementioned “if this then do”, servers can be configured to tie into pre-formed URIs at any time and execute a given function whenever that event is triggered.\n\nAdditionally, WebHooks have the unique benefit of being **based upon HTTP**, unlike WebSockets. This means that the system can be integrated without utilizing any new infrastructure, allowing speedy adoption and relatively simple setup.\n\n#### Cons\nThe problem with WebHooks is that a lot of their functionality can already be placed on the arguably more powerful REST architectural approach. While adopting event-driven architecture is often a requirement of the service being built, it’s a hard sell when it can be mirrored in REST while also giving the wealth of options that REST gives to the user.\n\nThese RESTful solutions such as [RestMS](http://www.restms.org/) are essentially simply message querying services, though, and do require additional infrastructure, which may or may not be doable considering the purpose of the application.\n\nAdditionally, WebHooks can be **resource intensive** to both the client and the server. If the client needs to notify many servers that an event has occurred, and a server needs to listen to a great deal of clients notifying of this change, you can very quickly run into a situation where your network grows uncontrollably. While HTTP does scale quite well, this is a definite negative to consider.\n\nHowever, there are also ways to build a [message queuing service](https://en.wikipedia.org/wiki/Message_queuing_service) on top of HTTP—some RESTful examples include [IronMQ](https://www.iron.io/platform/ironmq/) and RestMS.\n\n### 3: REST Hooks\nSpeaking of RESTful examples, **REST Hooks** is essentially “hooking” baked into REST itself. Defined as an initiative from [Zapier](http://resthooks.org/docs/), this is a subject [we’ve covered before](http://nordicapis.com/stop-polling-and-consider-using-rest-hooks/) — hooks are collated to a single target URL as a subscription, which pings the resource requester when a change is noted.\n\nThis approach is a response to the practice of **polling**, in which a client constantly checks for changes to a resource. Under the REST Hooks paradigm, the client instead waits for a change, and reacts to it. To put it simply, this is a WebHook in REST.\n\n#### Pros\nREST Hooks are obviously super powerful in the correct context — being able to passively receive a resource rather than dedicating processing power to constant polling frees up a lot of the client-side cost.\n\nPerhaps the strongest argument for REST Hooks though, is the fact that it’s **so easy** and **intuitive** to use. While WebHooks utilize HTTP and thus do not need new architecture to set up, they are also limited by the fact that they are built upon HTTP, and can thus be somewhat complex to set up properly and use effectively.\n\nREST Hooks, though, are **subscription based**, and as such, are simply usable by subscribing. This makes it a very easy to use solution while providing a lot of the usability and effectiveness of more complex systems.\n\n#### Cons\nOf course, every solution has its negatives, and REST Hooks are no different. It could be viewed that REST Hooks actually fly in the face of what REST is — [session free and stateless](http://nordicapis.com/defining-stateful-vs-stateless-web-services/). REST Hooks essentially create consistent polling, it’s just moved the polling from one side to another.\n\nThen, there’s the arguable problem that REST Hooks might be doing something that has already been solved. Some would argue that TCP already does most of what REST Hooks is trying to do, and simply layering more solutions on top of HTTP to get what TCP already does is a poor approach.\n\n### 4: Pub-Sub\n**Pub-Sub** is a slightly different approach. Referred to by its full name as **publish-subscribe**, the concept is where events are published to a class without knowledge of the client subscribing to the class. Basically, a user will join one or more classes, and then will receive event updates without regard or knowledge to the event publisher.\n\nThe main difference here is one of conscious choice of provider — in the other solutions noted herein, a user consciously communicates with a given server or provider and receives events as pre-determined. Under the Pub-Sub scheme, the user only specifies which class they wish to be part of and what events they are interested in receiving. From there, they receive these events when one is pushed out.\n\nA way this is often framed in internet discussions is in the frame of a **radio channel**. Record companies, or publishers, issue audio to the station, which then broadcasts this audio to listeners, or subscribers. Pub-sub is the middleman radio station here — listeners don’t know who gave the station the music, nor do the companies know who the listeners are. It is this segmentation that is baked into the pattern.\n\nWhen we talk about Pub-Sub, we need to keep in mind that we’re actually talking about two different things. Pub-Sub can mean the methodology and general concept in programming terms, but it can also mean specific provider solutions based upon that methodology. For instance, Google’s [Cloud Pub/Sub](https://cloud.google.com/pubsub/docs/overview) is an implementation of the general methodology within their cloud service, and allows for asynchronous many-to-many pub-sub relationships as stated above.\n\n#### Pros\nA huge benefit of Pub-Sub is the fact that it’s **loosely coupled**, and thus is extremely scalable and flexible. The only thing the event-provider is doing is generating the content — each other step is done through a separated middleman, and so the content is easily scaled and modulated to the architecture and design of the solution.\n\nAdditionally, Pub-Sub lends itself very well to **testing**. A subscriber is narrowly limited to a set of events that they have requested under a class, so if a failure occurs, this natural segmentation informs the provider as to where the fault is, and which class of users is experiencing the fault.\n\n#### Cons\nUnfortunately, decoupling is also a huge disadvantage for this pattern. By being a **middleman**, Pub-Sub cannot effectively notify the provider that a message has been sent, and the listener is separated from the event and thus may not know if a message wasn’t sent that should have been. Harkening back to the radio explanation, a listener will never know if a song was meant to play on a channel or if the channel is out of range, and once the record executives hand off the music, they’ve got no idea if the user received the songs without direct feedback from them.\n\nAdditionally, while the system is extensible and flexible, instability does occur with high traffic load as subclass after subclass might be constructed to handle further segmentation. This of course leads to the aforementioned instability in addition to increased complexity.\n\nYou must keep in mind that while the relationship between the publisher and subscriber in this model may be beneficial, it also comes with its own difficulties when these relationships need to be modulated. While you can certainly work around this, at this point, you’re fighting the very basis of the pattern, rather than any secondary natures — you’re trying to make dehydrated water, and fighting against the nature of a pattern suggests the pattern to be inherently poor.\n\n> Also read: [Building a Backend for Frontend (BFF) For Your Microservices](http://nordicapis.com/building-a-backend-for-frontend-shim-for-your-microservices/)\n\n### 5: Server Sent Events\n**Server Sent Events**, or SSE, is a communication protocol much like WebSockets, but with the implication of **unidirectional data**. In this architecture, the server is consistently sending updates to the client as an automatic process. This was standardized under HTML5 by the [W3C](https://www.w3.org/TR/2009/WD-eventsource-20091029/), and is thus compatible with any solution that is likewise compatible with HTML5.\n\n> Of note is that there is a competing standardization from the [Web Hypertext Application Technology Working Group](https://whatwg.org/) – this is a relic from movement away from “HTML5” and into what WHATWG is calling “HTML Living Standard”. The general working consensus is that, WHATWG’s standardization is prioritized in the rare cases of divergent standards. This could become more of an issue as time marches forward, given that WHATWG was created due to a perceived lack of interest from W3C towards evolving HTML, but for the time being, either standard is generally acceptable.\nWhile simple in theory, Server Sent Events are anything but simple when considering benefits and drawbacks.\n\n#### Pros\nSSE is **not bidirectional** in its communications — the server is issuing the events in a steady, predictable method. This is hugely beneficial to applications which do not need the two-way communications baked into WebSockets or other such solutions, as this means **lower bandwidth**, and an allowance for the connection to be temporary rather than always-on during the duration of data transfer. By its nature, the data is being transferred one way, and thus there is no need to wait for data to be returned.\n\nAdditionally, at least in theory, SSE is easier to set up in complex situations. You only have to worry about data traveling one direction via one system, thus reducing complexity dramatically. There is no need to define a message exchange protocol, no need to specify data duration or wait times, no need to support bilateral messaging — the single direction saves a lot of complexity.\n\n#### Cons\nThat simplicity could be where SSE fails for particular use cases. SSE is a very poor solution for situations that require **bidirectional communication**, and while this seems obvious, it would surprise many developers to see how many systems actually depend on bidirectional communication for simple functionality.\n\nWhile much of this can be fixed with workarounds, a developer’s goal in choosing an event-driven protocol should be to find one that works out of the box, not to find a solution that might work if configured properly and given secondary systems upon which to depend.\n\nThere is also the issue of **security** and authentication. While two-way systems can easily use authentication methodologies, SSE handles this using **header forwarding**. While headers can be manipulated and overridden in many languages and applications, the EventSource object in JavaScript does not natively support this, which would cause many adoptees some major headaches.\n\nFinally, there is a concern over loss of efficiency with **over transmitting** data. A two-direction system can determine when a client or server disconnects, but SSE can only determine that a client has disconnected after attempting a full data transmission and receiving a noted failure. Because of this, data can be lost rather quickly, and with many failed connections, this loss can mount dramatically over time.\n\n## Conclusion\nThere is no one event-driven solution that works in every use case. While many would argue that event-driven solutions should be REST based, which suggests REST Hooks as the answer, many others would argue that it is entirely situational, and that REST is not always the silver bullet it’s touted to be.\n\nIf you are building for scalability with low overhead in a browser environment, **WebSockets** are a great solution. Conversely, if you’d like those same benefits but are working in a non-browser system, then **WebHooks** should be your approach. **REST Hooks** are not only great for RESTful services, they’re also much easier to set up than either, and thus are great in low-time high-rush situations. **Pub-Sub** can be great if you need to enforce a division between client and server, and this can further be established and controlled in an even stronger way with **Server Sent**.\n\nSimply put, the best solution will be the one that fits your specific situation and build — any of these solutions, given the correct system, is a great solution. To that end, each solution has a very specific use case.\n\n## TLDR Comparison Table\n| PROTOCOL | RELATED TO | STANDARD BODY | NOTES |\n| ------ | ------ | ------ | ------ |\n| WebSockets | TCP, HTTP-like | IETF, W3C | Two-way communication over TCP<br>Designed for web browsers & web servers<br>Good for lower overhead scenarios<br>Supported in all major browsers |\n| Webhooks | URI, HTTP | - | User defined “HTTP callbacks”<br>Triggered by an event HTTP<br>Requests are made to Webhook URI<br>Enables real-time event triggering|\n| REST Hooks | HTTP | Zapier | Lightweight subscription layer<br>Manipulated by a REST API<br>Essentially a WebHook in REST |\n| Pub-Sub | - | - |Client subscribes to classes<br>Bidirectional<br>Middleman layer between client and server<br>Loose coupling|\n| Server Sent | HTTP, HTML5 , DOM | WHATWG, W3C |Server constantly sends updates to the client<br>Unidirectional push notifications as DOM events|\n","slug":"5-protocols-for-event-driven-api-architectures","published":1,"updated":"2017-07-21T03:28:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6i92auu0005e1txpht8yzzn","content":"<p>原文：<a href=\"http://nordicapis.com/5-protocols-for-event-driven-api-architectures/\" target=\"_blank\" rel=\"external\">5 Protocols For Event-Driven API Architectures</a></p>\n<p>The internet is a system of communication, and as such, the relationship between client and server, as well as server to server, is one of the most oft-discussed and hotly contested concepts. <strong>event-driven architecture</strong> is a methodology of defining these relationships, and creating systems within a specific set of relationships that allow for extensive functionality.</p>\n<p>In this piece, we’re going to discuss 5 common event-driven methods — <strong>WebSockets</strong>, <strong>WebHooks</strong>, <strong>REST Hooks</strong>, <strong>Pub-Sub</strong>, and <strong>Server Sent Events</strong>. We’ll define what they fundamentally are and do, and how API providers go about using them. Additionally, we’ll provide some pros and cons on each to make choosing a solution for your platform easy and intuitive.</p>\n<h2 id=\"What-is-an-Event-Driven-Architecture\"><a href=\"#What-is-an-Event-Driven-Architecture\" class=\"headerlink\" title=\"What is an Event-Driven Architecture?\"></a>What is an Event-Driven Architecture?</h2><p>Event-driven architectures establish an event that can be consumed and reacted to. But what is an event?</p>\n<p>An event is essentially any significant <strong>change</strong> from one state to another, such as the change from having no messages in your inbox to have a new message in your inbox. This state can be reacted to <strong>internally</strong> (such as when the email program in question realizes a new message has been received), <strong>externally</strong> (when a user sees a notification for a new message), or used to <strong>generate another event</strong> (for instance, the message tally increases by one).</p>\n<p>Event-driven architectures are appealing to API developers because they function very well in <strong>asynchronous</strong> environments. By crafting APIs that <strong>trigger</strong> certain functions on new event delivery, API systems don’t have to inherently wait for synchronous delivery or real time communication. This is hugely beneficial, as eliminating the need to constantly poll endpoints frees resources from otherwise wasteful purposes, reducing both general hardware requirements and call-specific overhead.</p>\n<p>For this reason, event-driven architectures are very, very popular, and lead to improved power, bandwidth, and co-processing than other solutions and architectures such as polling and other poll-centric derivatives.</p>\n<h2 id=\"5-Types-of-Event-Driven-Protocols-for-APIs\"><a href=\"#5-Types-of-Event-Driven-Protocols-for-APIs\" class=\"headerlink\" title=\"5 Types of Event-Driven Protocols for APIs\"></a>5 Types of Event-Driven Protocols for APIs</h2><h3 id=\"1-WebSockets\"><a href=\"#1-WebSockets\" class=\"headerlink\" title=\"1: WebSockets\"></a>1: WebSockets</h3><p><strong>WebSockets</strong> are an interesting event-driven solution, because, for most browsers, they’re actually baked into the application itself. Essentially, WebSocket is a protocol that provides full-duplex communication on a single TCP connection. It was standardized by the Internet Engineering Task Force as <a href=\"https://tools.ietf.org/html/rfc6455\" target=\"_blank\" rel=\"external\">RFC 6455</a>, and the WebSocket API in Web IDL was later standardized under the W3C banner.</p>\n<p>While the protocol itself is meant to be used between <strong>web browsers</strong> and <strong>servers</strong>, the protocol can be used in any case where there is a client-server relationship. The protocol itself is based upon TCP, with the additional HTTP interpretation statement that is considered an “Upgrade request” to allow for interoperability.</p>\n<h4 id=\"Pros\"><a href=\"#Pros\" class=\"headerlink\" title=\"Pros\"></a>Pros</h4><p>Because WebSocket is expressly designed for browser operation, it boasts extremely <strong>low overhead</strong> for what it actually does. By establishing a <strong>full-duplex</strong> conversation using a standardized methodology, connection both to and from the two entities can take place simultaneously, resulting in lower overhead and better throughput.</p>\n<p>Additionally, the fact that these communications take place over TCP 80/443 means that environments that traditionally block non-web based applications for security reasons can still handle this protocol, as firewalls allow communication to and from this port.</p>\n<p>Perhaps the strongest argument for the use of WebSockets are the fact that they are standardized and <strong>natively supported</strong> by all major browsers, ranging from Microsft Edge to Opera, from Firefox to Chrome. This means that any web application that ties into it will be interactable within the vast majority of both browser-based and browser-independent gateways and applications.</p>\n<h4 id=\"Cons\"><a href=\"#Cons\" class=\"headerlink\" title=\"Cons\"></a>Cons</h4><p>WebSockets have one distinct major failing — while it might have support for HTTP-like functionality, <strong>it is not HTTP</strong> whatsoever. This has implications, especially when considering optimizing in HTTP such as caching, proxying, etc., that haven’t quite become apparent.</p>\n<p>Because WebSockets are relatively new, having been only officially standardized in 2011, the industry is still understanding what the side effects mean. Most applications that use WebSockets are designed specifically for everything that a WebSocket is — what has yet to be seen, however, is whether or not this solution is better in the long-run than any stateless solution currently available.</p>\n<p>There is of course the fact that, as with other architectures on this list, WebSockets create an “always on” connection during the duration of data transfer. While this is fine for many uses such as media streaming and live stream calculations, it also essentially means that, for WebSockets, there is no scalability. Ports have hardcoded limitations and bandwidth, and thus in order to “scale”, you must add additional ports to match the maximum load. In stateless systems, this is less of an issue, as requests can wait and be made in such a way as to be independent on the state of the server itself.</p>\n<h3 id=\"2-WebHooks\"><a href=\"#2-WebHooks\" class=\"headerlink\" title=\"2: WebHooks\"></a>2: WebHooks</h3><p><strong>WebHooks</strong> are a similar concept to the WebSocket. They primarily function using <strong>custom callbacks</strong>, or code that is passed as an argument to another chunk of code and executed at a specified point in time. Essentially, a WebHook is a glorified system of “if this, then do”, allowing for users independent of the event firing to craft a custom response to that event within their own system.</p>\n<p>The term was coined by <a href=\"https://twitter.com/progrium\" target=\"_blank\" rel=\"external\">Jeff Lindsay</a> in 2007, and quickly became popular amongst users who wished to create automated responses to exterior behaviors. A great example of this would be a developer pushing a new item to GitHub, which causes an event. A user has a system tied into the URI of a WebHook. When the push is published, the user’s system utilizes the URI of the WebHook to integrate the push into a larger build, thereby creating a compiled component.</p>\n<h4 id=\"Pros-1\"><a href=\"#Pros-1\" class=\"headerlink\" title=\"Pros\"></a>Pros</h4><p>WebHooks function a lot like WebSockets, but they’re different in some key areas. First and foremost, WebSockets are primarily designed for browser-based communications, and while they can be used regardless in any client-server communication, they do not behave well in a <strong>server-to-server</strong> setup.</p>\n<p>WebHooks, on the other hand, work very well in server-to-server systems due to how they operate. Because the system essentially functions as the aforementioned “if this then do”, servers can be configured to tie into pre-formed URIs at any time and execute a given function whenever that event is triggered.</p>\n<p>Additionally, WebHooks have the unique benefit of being <strong>based upon HTTP</strong>, unlike WebSockets. This means that the system can be integrated without utilizing any new infrastructure, allowing speedy adoption and relatively simple setup.</p>\n<h4 id=\"Cons-1\"><a href=\"#Cons-1\" class=\"headerlink\" title=\"Cons\"></a>Cons</h4><p>The problem with WebHooks is that a lot of their functionality can already be placed on the arguably more powerful REST architectural approach. While adopting event-driven architecture is often a requirement of the service being built, it’s a hard sell when it can be mirrored in REST while also giving the wealth of options that REST gives to the user.</p>\n<p>These RESTful solutions such as <a href=\"http://www.restms.org/\" target=\"_blank\" rel=\"external\">RestMS</a> are essentially simply message querying services, though, and do require additional infrastructure, which may or may not be doable considering the purpose of the application.</p>\n<p>Additionally, WebHooks can be <strong>resource intensive</strong> to both the client and the server. If the client needs to notify many servers that an event has occurred, and a server needs to listen to a great deal of clients notifying of this change, you can very quickly run into a situation where your network grows uncontrollably. While HTTP does scale quite well, this is a definite negative to consider.</p>\n<p>However, there are also ways to build a <a href=\"https://en.wikipedia.org/wiki/Message_queuing_service\" target=\"_blank\" rel=\"external\">message queuing service</a> on top of HTTP—some RESTful examples include <a href=\"https://www.iron.io/platform/ironmq/\" target=\"_blank\" rel=\"external\">IronMQ</a> and RestMS.</p>\n<h3 id=\"3-REST-Hooks\"><a href=\"#3-REST-Hooks\" class=\"headerlink\" title=\"3: REST Hooks\"></a>3: REST Hooks</h3><p>Speaking of RESTful examples, <strong>REST Hooks</strong> is essentially “hooking” baked into REST itself. Defined as an initiative from <a href=\"http://resthooks.org/docs/\" target=\"_blank\" rel=\"external\">Zapier</a>, this is a subject <a href=\"http://nordicapis.com/stop-polling-and-consider-using-rest-hooks/\" target=\"_blank\" rel=\"external\">we’ve covered before</a> — hooks are collated to a single target URL as a subscription, which pings the resource requester when a change is noted.</p>\n<p>This approach is a response to the practice of <strong>polling</strong>, in which a client constantly checks for changes to a resource. Under the REST Hooks paradigm, the client instead waits for a change, and reacts to it. To put it simply, this is a WebHook in REST.</p>\n<h4 id=\"Pros-2\"><a href=\"#Pros-2\" class=\"headerlink\" title=\"Pros\"></a>Pros</h4><p>REST Hooks are obviously super powerful in the correct context — being able to passively receive a resource rather than dedicating processing power to constant polling frees up a lot of the client-side cost.</p>\n<p>Perhaps the strongest argument for REST Hooks though, is the fact that it’s <strong>so easy</strong> and <strong>intuitive</strong> to use. While WebHooks utilize HTTP and thus do not need new architecture to set up, they are also limited by the fact that they are built upon HTTP, and can thus be somewhat complex to set up properly and use effectively.</p>\n<p>REST Hooks, though, are <strong>subscription based</strong>, and as such, are simply usable by subscribing. This makes it a very easy to use solution while providing a lot of the usability and effectiveness of more complex systems.</p>\n<h4 id=\"Cons-2\"><a href=\"#Cons-2\" class=\"headerlink\" title=\"Cons\"></a>Cons</h4><p>Of course, every solution has its negatives, and REST Hooks are no different. It could be viewed that REST Hooks actually fly in the face of what REST is — <a href=\"http://nordicapis.com/defining-stateful-vs-stateless-web-services/\" target=\"_blank\" rel=\"external\">session free and stateless</a>. REST Hooks essentially create consistent polling, it’s just moved the polling from one side to another.</p>\n<p>Then, there’s the arguable problem that REST Hooks might be doing something that has already been solved. Some would argue that TCP already does most of what REST Hooks is trying to do, and simply layering more solutions on top of HTTP to get what TCP already does is a poor approach.</p>\n<h3 id=\"4-Pub-Sub\"><a href=\"#4-Pub-Sub\" class=\"headerlink\" title=\"4: Pub-Sub\"></a>4: Pub-Sub</h3><p><strong>Pub-Sub</strong> is a slightly different approach. Referred to by its full name as <strong>publish-subscribe</strong>, the concept is where events are published to a class without knowledge of the client subscribing to the class. Basically, a user will join one or more classes, and then will receive event updates without regard or knowledge to the event publisher.</p>\n<p>The main difference here is one of conscious choice of provider — in the other solutions noted herein, a user consciously communicates with a given server or provider and receives events as pre-determined. Under the Pub-Sub scheme, the user only specifies which class they wish to be part of and what events they are interested in receiving. From there, they receive these events when one is pushed out.</p>\n<p>A way this is often framed in internet discussions is in the frame of a <strong>radio channel</strong>. Record companies, or publishers, issue audio to the station, which then broadcasts this audio to listeners, or subscribers. Pub-sub is the middleman radio station here — listeners don’t know who gave the station the music, nor do the companies know who the listeners are. It is this segmentation that is baked into the pattern.</p>\n<p>When we talk about Pub-Sub, we need to keep in mind that we’re actually talking about two different things. Pub-Sub can mean the methodology and general concept in programming terms, but it can also mean specific provider solutions based upon that methodology. For instance, Google’s <a href=\"https://cloud.google.com/pubsub/docs/overview\" target=\"_blank\" rel=\"external\">Cloud Pub/Sub</a> is an implementation of the general methodology within their cloud service, and allows for asynchronous many-to-many pub-sub relationships as stated above.</p>\n<h4 id=\"Pros-3\"><a href=\"#Pros-3\" class=\"headerlink\" title=\"Pros\"></a>Pros</h4><p>A huge benefit of Pub-Sub is the fact that it’s <strong>loosely coupled</strong>, and thus is extremely scalable and flexible. The only thing the event-provider is doing is generating the content — each other step is done through a separated middleman, and so the content is easily scaled and modulated to the architecture and design of the solution.</p>\n<p>Additionally, Pub-Sub lends itself very well to <strong>testing</strong>. A subscriber is narrowly limited to a set of events that they have requested under a class, so if a failure occurs, this natural segmentation informs the provider as to where the fault is, and which class of users is experiencing the fault.</p>\n<h4 id=\"Cons-3\"><a href=\"#Cons-3\" class=\"headerlink\" title=\"Cons\"></a>Cons</h4><p>Unfortunately, decoupling is also a huge disadvantage for this pattern. By being a <strong>middleman</strong>, Pub-Sub cannot effectively notify the provider that a message has been sent, and the listener is separated from the event and thus may not know if a message wasn’t sent that should have been. Harkening back to the radio explanation, a listener will never know if a song was meant to play on a channel or if the channel is out of range, and once the record executives hand off the music, they’ve got no idea if the user received the songs without direct feedback from them.</p>\n<p>Additionally, while the system is extensible and flexible, instability does occur with high traffic load as subclass after subclass might be constructed to handle further segmentation. This of course leads to the aforementioned instability in addition to increased complexity.</p>\n<p>You must keep in mind that while the relationship between the publisher and subscriber in this model may be beneficial, it also comes with its own difficulties when these relationships need to be modulated. While you can certainly work around this, at this point, you’re fighting the very basis of the pattern, rather than any secondary natures — you’re trying to make dehydrated water, and fighting against the nature of a pattern suggests the pattern to be inherently poor.</p>\n<blockquote>\n<p>Also read: <a href=\"http://nordicapis.com/building-a-backend-for-frontend-shim-for-your-microservices/\" target=\"_blank\" rel=\"external\">Building a Backend for Frontend (BFF) For Your Microservices</a></p>\n</blockquote>\n<h3 id=\"5-Server-Sent-Events\"><a href=\"#5-Server-Sent-Events\" class=\"headerlink\" title=\"5: Server Sent Events\"></a>5: Server Sent Events</h3><p><strong>Server Sent Events</strong>, or SSE, is a communication protocol much like WebSockets, but with the implication of <strong>unidirectional data</strong>. In this architecture, the server is consistently sending updates to the client as an automatic process. This was standardized under HTML5 by the <a href=\"https://www.w3.org/TR/2009/WD-eventsource-20091029/\" target=\"_blank\" rel=\"external\">W3C</a>, and is thus compatible with any solution that is likewise compatible with HTML5.</p>\n<blockquote>\n<p>Of note is that there is a competing standardization from the <a href=\"https://whatwg.org/\" target=\"_blank\" rel=\"external\">Web Hypertext Application Technology Working Group</a> – this is a relic from movement away from “HTML5” and into what WHATWG is calling “HTML Living Standard”. The general working consensus is that, WHATWG’s standardization is prioritized in the rare cases of divergent standards. This could become more of an issue as time marches forward, given that WHATWG was created due to a perceived lack of interest from W3C towards evolving HTML, but for the time being, either standard is generally acceptable.<br>While simple in theory, Server Sent Events are anything but simple when considering benefits and drawbacks.</p>\n</blockquote>\n<h4 id=\"Pros-4\"><a href=\"#Pros-4\" class=\"headerlink\" title=\"Pros\"></a>Pros</h4><p>SSE is <strong>not bidirectional</strong> in its communications — the server is issuing the events in a steady, predictable method. This is hugely beneficial to applications which do not need the two-way communications baked into WebSockets or other such solutions, as this means <strong>lower bandwidth</strong>, and an allowance for the connection to be temporary rather than always-on during the duration of data transfer. By its nature, the data is being transferred one way, and thus there is no need to wait for data to be returned.</p>\n<p>Additionally, at least in theory, SSE is easier to set up in complex situations. You only have to worry about data traveling one direction via one system, thus reducing complexity dramatically. There is no need to define a message exchange protocol, no need to specify data duration or wait times, no need to support bilateral messaging — the single direction saves a lot of complexity.</p>\n<h4 id=\"Cons-4\"><a href=\"#Cons-4\" class=\"headerlink\" title=\"Cons\"></a>Cons</h4><p>That simplicity could be where SSE fails for particular use cases. SSE is a very poor solution for situations that require <strong>bidirectional communication</strong>, and while this seems obvious, it would surprise many developers to see how many systems actually depend on bidirectional communication for simple functionality.</p>\n<p>While much of this can be fixed with workarounds, a developer’s goal in choosing an event-driven protocol should be to find one that works out of the box, not to find a solution that might work if configured properly and given secondary systems upon which to depend.</p>\n<p>There is also the issue of <strong>security</strong> and authentication. While two-way systems can easily use authentication methodologies, SSE handles this using <strong>header forwarding</strong>. While headers can be manipulated and overridden in many languages and applications, the EventSource object in JavaScript does not natively support this, which would cause many adoptees some major headaches.</p>\n<p>Finally, there is a concern over loss of efficiency with <strong>over transmitting</strong> data. A two-direction system can determine when a client or server disconnects, but SSE can only determine that a client has disconnected after attempting a full data transmission and receiving a noted failure. Because of this, data can be lost rather quickly, and with many failed connections, this loss can mount dramatically over time.</p>\n<h2 id=\"Conclusion\"><a href=\"#Conclusion\" class=\"headerlink\" title=\"Conclusion\"></a>Conclusion</h2><p>There is no one event-driven solution that works in every use case. While many would argue that event-driven solutions should be REST based, which suggests REST Hooks as the answer, many others would argue that it is entirely situational, and that REST is not always the silver bullet it’s touted to be.</p>\n<p>If you are building for scalability with low overhead in a browser environment, <strong>WebSockets</strong> are a great solution. Conversely, if you’d like those same benefits but are working in a non-browser system, then <strong>WebHooks</strong> should be your approach. <strong>REST Hooks</strong> are not only great for RESTful services, they’re also much easier to set up than either, and thus are great in low-time high-rush situations. <strong>Pub-Sub</strong> can be great if you need to enforce a division between client and server, and this can further be established and controlled in an even stronger way with <strong>Server Sent</strong>.</p>\n<p>Simply put, the best solution will be the one that fits your specific situation and build — any of these solutions, given the correct system, is a great solution. To that end, each solution has a very specific use case.</p>\n<h2 id=\"TLDR-Comparison-Table\"><a href=\"#TLDR-Comparison-Table\" class=\"headerlink\" title=\"TLDR Comparison Table\"></a>TLDR Comparison Table</h2><table>\n<thead>\n<tr>\n<th>PROTOCOL</th>\n<th>RELATED TO</th>\n<th>STANDARD BODY</th>\n<th>NOTES</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>WebSockets</td>\n<td>TCP, HTTP-like</td>\n<td>IETF, W3C</td>\n<td>Two-way communication over TCP<br>Designed for web browsers &amp; web servers<br>Good for lower overhead scenarios<br>Supported in all major browsers</td>\n</tr>\n<tr>\n<td>Webhooks</td>\n<td>URI, HTTP</td>\n<td>-</td>\n<td>User defined “HTTP callbacks”<br>Triggered by an event HTTP<br>Requests are made to Webhook URI<br>Enables real-time event triggering</td>\n</tr>\n<tr>\n<td>REST Hooks</td>\n<td>HTTP</td>\n<td>Zapier</td>\n<td>Lightweight subscription layer<br>Manipulated by a REST API<br>Essentially a WebHook in REST</td>\n</tr>\n<tr>\n<td>Pub-Sub</td>\n<td>-</td>\n<td>-</td>\n<td>Client subscribes to classes<br>Bidirectional<br>Middleman layer between client and server<br>Loose coupling</td>\n</tr>\n<tr>\n<td>Server Sent</td>\n<td>HTTP, HTML5 , DOM</td>\n<td>WHATWG, W3C</td>\n<td>Server constantly sends updates to the client<br>Unidirectional push notifications as DOM events</td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{}},"excerpt":"","more":"<p>原文：<a href=\"http://nordicapis.com/5-protocols-for-event-driven-api-architectures/\" target=\"_blank\" rel=\"external\">5 Protocols For Event-Driven API Architectures</a></p>\n<p>The internet is a system of communication, and as such, the relationship between client and server, as well as server to server, is one of the most oft-discussed and hotly contested concepts. <strong>event-driven architecture</strong> is a methodology of defining these relationships, and creating systems within a specific set of relationships that allow for extensive functionality.</p>\n<p>In this piece, we’re going to discuss 5 common event-driven methods — <strong>WebSockets</strong>, <strong>WebHooks</strong>, <strong>REST Hooks</strong>, <strong>Pub-Sub</strong>, and <strong>Server Sent Events</strong>. We’ll define what they fundamentally are and do, and how API providers go about using them. Additionally, we’ll provide some pros and cons on each to make choosing a solution for your platform easy and intuitive.</p>\n<h2 id=\"What-is-an-Event-Driven-Architecture\"><a href=\"#What-is-an-Event-Driven-Architecture\" class=\"headerlink\" title=\"What is an Event-Driven Architecture?\"></a>What is an Event-Driven Architecture?</h2><p>Event-driven architectures establish an event that can be consumed and reacted to. But what is an event?</p>\n<p>An event is essentially any significant <strong>change</strong> from one state to another, such as the change from having no messages in your inbox to have a new message in your inbox. This state can be reacted to <strong>internally</strong> (such as when the email program in question realizes a new message has been received), <strong>externally</strong> (when a user sees a notification for a new message), or used to <strong>generate another event</strong> (for instance, the message tally increases by one).</p>\n<p>Event-driven architectures are appealing to API developers because they function very well in <strong>asynchronous</strong> environments. By crafting APIs that <strong>trigger</strong> certain functions on new event delivery, API systems don’t have to inherently wait for synchronous delivery or real time communication. This is hugely beneficial, as eliminating the need to constantly poll endpoints frees resources from otherwise wasteful purposes, reducing both general hardware requirements and call-specific overhead.</p>\n<p>For this reason, event-driven architectures are very, very popular, and lead to improved power, bandwidth, and co-processing than other solutions and architectures such as polling and other poll-centric derivatives.</p>\n<h2 id=\"5-Types-of-Event-Driven-Protocols-for-APIs\"><a href=\"#5-Types-of-Event-Driven-Protocols-for-APIs\" class=\"headerlink\" title=\"5 Types of Event-Driven Protocols for APIs\"></a>5 Types of Event-Driven Protocols for APIs</h2><h3 id=\"1-WebSockets\"><a href=\"#1-WebSockets\" class=\"headerlink\" title=\"1: WebSockets\"></a>1: WebSockets</h3><p><strong>WebSockets</strong> are an interesting event-driven solution, because, for most browsers, they’re actually baked into the application itself. Essentially, WebSocket is a protocol that provides full-duplex communication on a single TCP connection. It was standardized by the Internet Engineering Task Force as <a href=\"https://tools.ietf.org/html/rfc6455\" target=\"_blank\" rel=\"external\">RFC 6455</a>, and the WebSocket API in Web IDL was later standardized under the W3C banner.</p>\n<p>While the protocol itself is meant to be used between <strong>web browsers</strong> and <strong>servers</strong>, the protocol can be used in any case where there is a client-server relationship. The protocol itself is based upon TCP, with the additional HTTP interpretation statement that is considered an “Upgrade request” to allow for interoperability.</p>\n<h4 id=\"Pros\"><a href=\"#Pros\" class=\"headerlink\" title=\"Pros\"></a>Pros</h4><p>Because WebSocket is expressly designed for browser operation, it boasts extremely <strong>low overhead</strong> for what it actually does. By establishing a <strong>full-duplex</strong> conversation using a standardized methodology, connection both to and from the two entities can take place simultaneously, resulting in lower overhead and better throughput.</p>\n<p>Additionally, the fact that these communications take place over TCP 80/443 means that environments that traditionally block non-web based applications for security reasons can still handle this protocol, as firewalls allow communication to and from this port.</p>\n<p>Perhaps the strongest argument for the use of WebSockets are the fact that they are standardized and <strong>natively supported</strong> by all major browsers, ranging from Microsft Edge to Opera, from Firefox to Chrome. This means that any web application that ties into it will be interactable within the vast majority of both browser-based and browser-independent gateways and applications.</p>\n<h4 id=\"Cons\"><a href=\"#Cons\" class=\"headerlink\" title=\"Cons\"></a>Cons</h4><p>WebSockets have one distinct major failing — while it might have support for HTTP-like functionality, <strong>it is not HTTP</strong> whatsoever. This has implications, especially when considering optimizing in HTTP such as caching, proxying, etc., that haven’t quite become apparent.</p>\n<p>Because WebSockets are relatively new, having been only officially standardized in 2011, the industry is still understanding what the side effects mean. Most applications that use WebSockets are designed specifically for everything that a WebSocket is — what has yet to be seen, however, is whether or not this solution is better in the long-run than any stateless solution currently available.</p>\n<p>There is of course the fact that, as with other architectures on this list, WebSockets create an “always on” connection during the duration of data transfer. While this is fine for many uses such as media streaming and live stream calculations, it also essentially means that, for WebSockets, there is no scalability. Ports have hardcoded limitations and bandwidth, and thus in order to “scale”, you must add additional ports to match the maximum load. In stateless systems, this is less of an issue, as requests can wait and be made in such a way as to be independent on the state of the server itself.</p>\n<h3 id=\"2-WebHooks\"><a href=\"#2-WebHooks\" class=\"headerlink\" title=\"2: WebHooks\"></a>2: WebHooks</h3><p><strong>WebHooks</strong> are a similar concept to the WebSocket. They primarily function using <strong>custom callbacks</strong>, or code that is passed as an argument to another chunk of code and executed at a specified point in time. Essentially, a WebHook is a glorified system of “if this, then do”, allowing for users independent of the event firing to craft a custom response to that event within their own system.</p>\n<p>The term was coined by <a href=\"https://twitter.com/progrium\" target=\"_blank\" rel=\"external\">Jeff Lindsay</a> in 2007, and quickly became popular amongst users who wished to create automated responses to exterior behaviors. A great example of this would be a developer pushing a new item to GitHub, which causes an event. A user has a system tied into the URI of a WebHook. When the push is published, the user’s system utilizes the URI of the WebHook to integrate the push into a larger build, thereby creating a compiled component.</p>\n<h4 id=\"Pros-1\"><a href=\"#Pros-1\" class=\"headerlink\" title=\"Pros\"></a>Pros</h4><p>WebHooks function a lot like WebSockets, but they’re different in some key areas. First and foremost, WebSockets are primarily designed for browser-based communications, and while they can be used regardless in any client-server communication, they do not behave well in a <strong>server-to-server</strong> setup.</p>\n<p>WebHooks, on the other hand, work very well in server-to-server systems due to how they operate. Because the system essentially functions as the aforementioned “if this then do”, servers can be configured to tie into pre-formed URIs at any time and execute a given function whenever that event is triggered.</p>\n<p>Additionally, WebHooks have the unique benefit of being <strong>based upon HTTP</strong>, unlike WebSockets. This means that the system can be integrated without utilizing any new infrastructure, allowing speedy adoption and relatively simple setup.</p>\n<h4 id=\"Cons-1\"><a href=\"#Cons-1\" class=\"headerlink\" title=\"Cons\"></a>Cons</h4><p>The problem with WebHooks is that a lot of their functionality can already be placed on the arguably more powerful REST architectural approach. While adopting event-driven architecture is often a requirement of the service being built, it’s a hard sell when it can be mirrored in REST while also giving the wealth of options that REST gives to the user.</p>\n<p>These RESTful solutions such as <a href=\"http://www.restms.org/\" target=\"_blank\" rel=\"external\">RestMS</a> are essentially simply message querying services, though, and do require additional infrastructure, which may or may not be doable considering the purpose of the application.</p>\n<p>Additionally, WebHooks can be <strong>resource intensive</strong> to both the client and the server. If the client needs to notify many servers that an event has occurred, and a server needs to listen to a great deal of clients notifying of this change, you can very quickly run into a situation where your network grows uncontrollably. While HTTP does scale quite well, this is a definite negative to consider.</p>\n<p>However, there are also ways to build a <a href=\"https://en.wikipedia.org/wiki/Message_queuing_service\" target=\"_blank\" rel=\"external\">message queuing service</a> on top of HTTP—some RESTful examples include <a href=\"https://www.iron.io/platform/ironmq/\" target=\"_blank\" rel=\"external\">IronMQ</a> and RestMS.</p>\n<h3 id=\"3-REST-Hooks\"><a href=\"#3-REST-Hooks\" class=\"headerlink\" title=\"3: REST Hooks\"></a>3: REST Hooks</h3><p>Speaking of RESTful examples, <strong>REST Hooks</strong> is essentially “hooking” baked into REST itself. Defined as an initiative from <a href=\"http://resthooks.org/docs/\" target=\"_blank\" rel=\"external\">Zapier</a>, this is a subject <a href=\"http://nordicapis.com/stop-polling-and-consider-using-rest-hooks/\" target=\"_blank\" rel=\"external\">we’ve covered before</a> — hooks are collated to a single target URL as a subscription, which pings the resource requester when a change is noted.</p>\n<p>This approach is a response to the practice of <strong>polling</strong>, in which a client constantly checks for changes to a resource. Under the REST Hooks paradigm, the client instead waits for a change, and reacts to it. To put it simply, this is a WebHook in REST.</p>\n<h4 id=\"Pros-2\"><a href=\"#Pros-2\" class=\"headerlink\" title=\"Pros\"></a>Pros</h4><p>REST Hooks are obviously super powerful in the correct context — being able to passively receive a resource rather than dedicating processing power to constant polling frees up a lot of the client-side cost.</p>\n<p>Perhaps the strongest argument for REST Hooks though, is the fact that it’s <strong>so easy</strong> and <strong>intuitive</strong> to use. While WebHooks utilize HTTP and thus do not need new architecture to set up, they are also limited by the fact that they are built upon HTTP, and can thus be somewhat complex to set up properly and use effectively.</p>\n<p>REST Hooks, though, are <strong>subscription based</strong>, and as such, are simply usable by subscribing. This makes it a very easy to use solution while providing a lot of the usability and effectiveness of more complex systems.</p>\n<h4 id=\"Cons-2\"><a href=\"#Cons-2\" class=\"headerlink\" title=\"Cons\"></a>Cons</h4><p>Of course, every solution has its negatives, and REST Hooks are no different. It could be viewed that REST Hooks actually fly in the face of what REST is — <a href=\"http://nordicapis.com/defining-stateful-vs-stateless-web-services/\" target=\"_blank\" rel=\"external\">session free and stateless</a>. REST Hooks essentially create consistent polling, it’s just moved the polling from one side to another.</p>\n<p>Then, there’s the arguable problem that REST Hooks might be doing something that has already been solved. Some would argue that TCP already does most of what REST Hooks is trying to do, and simply layering more solutions on top of HTTP to get what TCP already does is a poor approach.</p>\n<h3 id=\"4-Pub-Sub\"><a href=\"#4-Pub-Sub\" class=\"headerlink\" title=\"4: Pub-Sub\"></a>4: Pub-Sub</h3><p><strong>Pub-Sub</strong> is a slightly different approach. Referred to by its full name as <strong>publish-subscribe</strong>, the concept is where events are published to a class without knowledge of the client subscribing to the class. Basically, a user will join one or more classes, and then will receive event updates without regard or knowledge to the event publisher.</p>\n<p>The main difference here is one of conscious choice of provider — in the other solutions noted herein, a user consciously communicates with a given server or provider and receives events as pre-determined. Under the Pub-Sub scheme, the user only specifies which class they wish to be part of and what events they are interested in receiving. From there, they receive these events when one is pushed out.</p>\n<p>A way this is often framed in internet discussions is in the frame of a <strong>radio channel</strong>. Record companies, or publishers, issue audio to the station, which then broadcasts this audio to listeners, or subscribers. Pub-sub is the middleman radio station here — listeners don’t know who gave the station the music, nor do the companies know who the listeners are. It is this segmentation that is baked into the pattern.</p>\n<p>When we talk about Pub-Sub, we need to keep in mind that we’re actually talking about two different things. Pub-Sub can mean the methodology and general concept in programming terms, but it can also mean specific provider solutions based upon that methodology. For instance, Google’s <a href=\"https://cloud.google.com/pubsub/docs/overview\" target=\"_blank\" rel=\"external\">Cloud Pub/Sub</a> is an implementation of the general methodology within their cloud service, and allows for asynchronous many-to-many pub-sub relationships as stated above.</p>\n<h4 id=\"Pros-3\"><a href=\"#Pros-3\" class=\"headerlink\" title=\"Pros\"></a>Pros</h4><p>A huge benefit of Pub-Sub is the fact that it’s <strong>loosely coupled</strong>, and thus is extremely scalable and flexible. The only thing the event-provider is doing is generating the content — each other step is done through a separated middleman, and so the content is easily scaled and modulated to the architecture and design of the solution.</p>\n<p>Additionally, Pub-Sub lends itself very well to <strong>testing</strong>. A subscriber is narrowly limited to a set of events that they have requested under a class, so if a failure occurs, this natural segmentation informs the provider as to where the fault is, and which class of users is experiencing the fault.</p>\n<h4 id=\"Cons-3\"><a href=\"#Cons-3\" class=\"headerlink\" title=\"Cons\"></a>Cons</h4><p>Unfortunately, decoupling is also a huge disadvantage for this pattern. By being a <strong>middleman</strong>, Pub-Sub cannot effectively notify the provider that a message has been sent, and the listener is separated from the event and thus may not know if a message wasn’t sent that should have been. Harkening back to the radio explanation, a listener will never know if a song was meant to play on a channel or if the channel is out of range, and once the record executives hand off the music, they’ve got no idea if the user received the songs without direct feedback from them.</p>\n<p>Additionally, while the system is extensible and flexible, instability does occur with high traffic load as subclass after subclass might be constructed to handle further segmentation. This of course leads to the aforementioned instability in addition to increased complexity.</p>\n<p>You must keep in mind that while the relationship between the publisher and subscriber in this model may be beneficial, it also comes with its own difficulties when these relationships need to be modulated. While you can certainly work around this, at this point, you’re fighting the very basis of the pattern, rather than any secondary natures — you’re trying to make dehydrated water, and fighting against the nature of a pattern suggests the pattern to be inherently poor.</p>\n<blockquote>\n<p>Also read: <a href=\"http://nordicapis.com/building-a-backend-for-frontend-shim-for-your-microservices/\" target=\"_blank\" rel=\"external\">Building a Backend for Frontend (BFF) For Your Microservices</a></p>\n</blockquote>\n<h3 id=\"5-Server-Sent-Events\"><a href=\"#5-Server-Sent-Events\" class=\"headerlink\" title=\"5: Server Sent Events\"></a>5: Server Sent Events</h3><p><strong>Server Sent Events</strong>, or SSE, is a communication protocol much like WebSockets, but with the implication of <strong>unidirectional data</strong>. In this architecture, the server is consistently sending updates to the client as an automatic process. This was standardized under HTML5 by the <a href=\"https://www.w3.org/TR/2009/WD-eventsource-20091029/\" target=\"_blank\" rel=\"external\">W3C</a>, and is thus compatible with any solution that is likewise compatible with HTML5.</p>\n<blockquote>\n<p>Of note is that there is a competing standardization from the <a href=\"https://whatwg.org/\" target=\"_blank\" rel=\"external\">Web Hypertext Application Technology Working Group</a> – this is a relic from movement away from “HTML5” and into what WHATWG is calling “HTML Living Standard”. The general working consensus is that, WHATWG’s standardization is prioritized in the rare cases of divergent standards. This could become more of an issue as time marches forward, given that WHATWG was created due to a perceived lack of interest from W3C towards evolving HTML, but for the time being, either standard is generally acceptable.<br>While simple in theory, Server Sent Events are anything but simple when considering benefits and drawbacks.</p>\n</blockquote>\n<h4 id=\"Pros-4\"><a href=\"#Pros-4\" class=\"headerlink\" title=\"Pros\"></a>Pros</h4><p>SSE is <strong>not bidirectional</strong> in its communications — the server is issuing the events in a steady, predictable method. This is hugely beneficial to applications which do not need the two-way communications baked into WebSockets or other such solutions, as this means <strong>lower bandwidth</strong>, and an allowance for the connection to be temporary rather than always-on during the duration of data transfer. By its nature, the data is being transferred one way, and thus there is no need to wait for data to be returned.</p>\n<p>Additionally, at least in theory, SSE is easier to set up in complex situations. You only have to worry about data traveling one direction via one system, thus reducing complexity dramatically. There is no need to define a message exchange protocol, no need to specify data duration or wait times, no need to support bilateral messaging — the single direction saves a lot of complexity.</p>\n<h4 id=\"Cons-4\"><a href=\"#Cons-4\" class=\"headerlink\" title=\"Cons\"></a>Cons</h4><p>That simplicity could be where SSE fails for particular use cases. SSE is a very poor solution for situations that require <strong>bidirectional communication</strong>, and while this seems obvious, it would surprise many developers to see how many systems actually depend on bidirectional communication for simple functionality.</p>\n<p>While much of this can be fixed with workarounds, a developer’s goal in choosing an event-driven protocol should be to find one that works out of the box, not to find a solution that might work if configured properly and given secondary systems upon which to depend.</p>\n<p>There is also the issue of <strong>security</strong> and authentication. While two-way systems can easily use authentication methodologies, SSE handles this using <strong>header forwarding</strong>. While headers can be manipulated and overridden in many languages and applications, the EventSource object in JavaScript does not natively support this, which would cause many adoptees some major headaches.</p>\n<p>Finally, there is a concern over loss of efficiency with <strong>over transmitting</strong> data. A two-direction system can determine when a client or server disconnects, but SSE can only determine that a client has disconnected after attempting a full data transmission and receiving a noted failure. Because of this, data can be lost rather quickly, and with many failed connections, this loss can mount dramatically over time.</p>\n<h2 id=\"Conclusion\"><a href=\"#Conclusion\" class=\"headerlink\" title=\"Conclusion\"></a>Conclusion</h2><p>There is no one event-driven solution that works in every use case. While many would argue that event-driven solutions should be REST based, which suggests REST Hooks as the answer, many others would argue that it is entirely situational, and that REST is not always the silver bullet it’s touted to be.</p>\n<p>If you are building for scalability with low overhead in a browser environment, <strong>WebSockets</strong> are a great solution. Conversely, if you’d like those same benefits but are working in a non-browser system, then <strong>WebHooks</strong> should be your approach. <strong>REST Hooks</strong> are not only great for RESTful services, they’re also much easier to set up than either, and thus are great in low-time high-rush situations. <strong>Pub-Sub</strong> can be great if you need to enforce a division between client and server, and this can further be established and controlled in an even stronger way with <strong>Server Sent</strong>.</p>\n<p>Simply put, the best solution will be the one that fits your specific situation and build — any of these solutions, given the correct system, is a great solution. To that end, each solution has a very specific use case.</p>\n<h2 id=\"TLDR-Comparison-Table\"><a href=\"#TLDR-Comparison-Table\" class=\"headerlink\" title=\"TLDR Comparison Table\"></a>TLDR Comparison Table</h2><table>\n<thead>\n<tr>\n<th>PROTOCOL</th>\n<th>RELATED TO</th>\n<th>STANDARD BODY</th>\n<th>NOTES</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>WebSockets</td>\n<td>TCP, HTTP-like</td>\n<td>IETF, W3C</td>\n<td>Two-way communication over TCP<br>Designed for web browsers &amp; web servers<br>Good for lower overhead scenarios<br>Supported in all major browsers</td>\n</tr>\n<tr>\n<td>Webhooks</td>\n<td>URI, HTTP</td>\n<td>-</td>\n<td>User defined “HTTP callbacks”<br>Triggered by an event HTTP<br>Requests are made to Webhook URI<br>Enables real-time event triggering</td>\n</tr>\n<tr>\n<td>REST Hooks</td>\n<td>HTTP</td>\n<td>Zapier</td>\n<td>Lightweight subscription layer<br>Manipulated by a REST API<br>Essentially a WebHook in REST</td>\n</tr>\n<tr>\n<td>Pub-Sub</td>\n<td>-</td>\n<td>-</td>\n<td>Client subscribes to classes<br>Bidirectional<br>Middleman layer between client and server<br>Loose coupling</td>\n</tr>\n<tr>\n<td>Server Sent</td>\n<td>HTTP, HTML5 , DOM</td>\n<td>WHATWG, W3C</td>\n<td>Server constantly sends updates to the client<br>Unidirectional push notifications as DOM events</td>\n</tr>\n</tbody>\n</table>\n"},{"title":"大前端周刊 第六期 （本期小编：郭俊兵）","date":"2017-07-28T04:09:40.000Z","_content":"\n## 基础\n* [CSS 样式书写规范](https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&mid=2651552360&idx=1&sn=8d2bc092405fc23379a786a6b7a36274&chksm=8025ada9b75224bfd372ce168cb0f9cb6959255e2a7e94556eacea5d1d8e4b559dd494704ae5&mpshare=1&scene=1&srcid=0720bFFOVROJ90Pe2ZutzpQz#rd)\n**不同的规范都有各自的长处与缺陷，对待所谓的规范最好的方式不是人云亦云，拿来就用，而是应该结合实际情况及需求，取长补短，取其精华去其糟粕。**\n\n* [bfc初探](https://segmentfault.com/a/1190000010150841)\n**bfc全称是块级格式化上下文（block formating context），是web可视化css渲染的一部分，它是块级盒子的布局发生，浮动互相交互的部分。**\n\n* [es6精简学习](https://segmentfault.com/a/1190000010279009)\n**秉着二八原则，掌握好常用的，有用的这个可以让我们快速起飞**\n\n## 文章\n* [推荐一个Vuex的介绍文章](https://github.com/chenbin92/blog/issues/1)\n<small>*推荐人：张成斌*</small>\n使用Vue做项目时，Vuex的使用与否和怎么使用始终是回避不了的一个问题。这篇文章或许能给你一些灵感。\n\n* [当我们学习 Node.js 时，我们在学习什么？](https://mp.weixin.qq.com/s?__biz=MzIyMjYyMzg3MA==&mid=2247484289&idx=1&sn=9e7f6c0c5e6707c8b3d0a73b36bc00c1&chksm=e82be290df5c6b86e2be66f2eea6ee88be1449c3b40d8ebf40932798f95e651fbaf49ca698d0&mpshare=1&scene=1&srcid=0728VrhaVGLU4L9ednVFlmev&pass_ticket=UuoqCxRu07cu1Iw3Eo8nDcUi6ufOxbjgwdd0cRPXNFEztRXx6J2qpa2gAXxKir5f#rd)\n<small>*推荐人：包京京*</small>\n大家都说学 Node.js 学 Node.js，到底是学它的什么呢？是学 JavaScript 这门语言，还是学 Node.js 的 API？还是学 Node.js 各种三方库？\n\n* [推荐一篇关于WebSocket 的教程](http://www.ruanyifeng.com/blog/2017/05/websocket.html)\n<small>*推荐人：陶明*</small>\n文章介绍了WebSocket 的特性及与HTTP对比在服务器推送上的优势，通过一个简单的示例介绍了WebSocket 部分API。\n\n* [推荐一篇介绍git工作流程的文章](http://www.cnblogs.com/cnblogsfans/p/5075073.html)\n<small>*推荐人：李丽娇*</small>\ngit成为现在最火的代码管理工具，文中详细介绍了git在团队中的使用流程，这种思路在团队协作中很是受用。同时文中介绍了gitflow使用的方法。\n\n* [理解 async/await](https://juejin.im/post/596e142d5188254b532ce2da)\n<small>*推荐人：耿少真*</small>\nasync 函数是 Generator 函数的语法糖。使用 关键字 async 来表示，在函数内部使用 await 来表示异步。\n\n* [http协议简介](http://www.jianshu.com/p/80e25cb1d81a)\n<small>*推荐人：郭俊兵*</small>\n大致了解下http协议相关内容，有利于了解前端开发时，调用后台接口，请求做了什么。\n\n* [Vue2.0 源码阅读：响应式原理](http://zhouweicsu.github.io/blog/2017/03/07/vue-2-0-reactivity/)\n<small>*推荐人：李志伟*</small>\n文章深入Vue源码，详细地解析了响应式原理。其原理大致可总结为：当数据发生改变后，相应的 setter 函数被触发，然后执行 notify 函数通知订阅者（Watcher）去更新相关视图，也会对新的数据重新 observe，更新相关的依赖关系。\n\n* [HTTP/2 Server Push 详解(原文)](https://www.smashingmagazine.com/2017/04/guide-http2-server-push/)\n<small>*推荐人：胡国伟*</small>\nServer Push可以将静态资源推送给客户端，实现多路复用，是HTTP/2众多协议优化中最令人振奋的特性，它大大降低了网络延迟对性能的影响。\n##### 翻译：\n  - [HTTP/2 Server Push 详解（上）](http://www.alloyteam.com/2017/04/guide-http2-server-push-part1/)\n  - [HTTP/2 Server Push 详解（下）](http://www.alloyteam.com/2017/04/guide-http2-server-push-part2/)\n\n* [深入vue2.0底层思想–模板渲染](http://mp.weixin.qq.com/s/L5VK5v3fmzdjLdT6Z6w-rA)\n<small>*推荐人：王俐*</small>\nVue 2.0 中模板渲染与 Vue 1.0的区别，1.0 中采用的 DocumentFragment （想了解可以观看这篇文章），而 2.0 中借鉴 React 的 Virtual DOM。基于 Virtual DOM，2.0 还可以支持服务端渲染（SSR），也支持 JSX 语法。\n\n* [iView 一周年了，同时发布了 2.0 正式版](https://zhuanlan.zhihu.com/p/28090879)\n<small>*推荐人：王祥*</small>\n一周年，两个大版本，很值得称赞的成绩！能跟梁灏这样优秀的前端生态贡献者共事，我感到非常荣幸！\n正如标题所言，2.0正式版将会是一个全新的开始，她将随着Vue社区的进步而快速迭代。\n期待vue社区和iView能有更好的发展，iView不会止于组件库，更期待iView deign、iView mobile…和更多优秀的开发者参与到开源生态的共建！","source":"_posts/weekly-6.md","raw":"---\ntitle: 大前端周刊 第六期 （本期小编：郭俊兵）\ndate: 2017-07-28 12:09:40\ntags: [weekly,Vuex,node,WebSocket,http,Vue,iView,Git]\n---\n\n## 基础\n* [CSS 样式书写规范](https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&mid=2651552360&idx=1&sn=8d2bc092405fc23379a786a6b7a36274&chksm=8025ada9b75224bfd372ce168cb0f9cb6959255e2a7e94556eacea5d1d8e4b559dd494704ae5&mpshare=1&scene=1&srcid=0720bFFOVROJ90Pe2ZutzpQz#rd)\n**不同的规范都有各自的长处与缺陷，对待所谓的规范最好的方式不是人云亦云，拿来就用，而是应该结合实际情况及需求，取长补短，取其精华去其糟粕。**\n\n* [bfc初探](https://segmentfault.com/a/1190000010150841)\n**bfc全称是块级格式化上下文（block formating context），是web可视化css渲染的一部分，它是块级盒子的布局发生，浮动互相交互的部分。**\n\n* [es6精简学习](https://segmentfault.com/a/1190000010279009)\n**秉着二八原则，掌握好常用的，有用的这个可以让我们快速起飞**\n\n## 文章\n* [推荐一个Vuex的介绍文章](https://github.com/chenbin92/blog/issues/1)\n<small>*推荐人：张成斌*</small>\n使用Vue做项目时，Vuex的使用与否和怎么使用始终是回避不了的一个问题。这篇文章或许能给你一些灵感。\n\n* [当我们学习 Node.js 时，我们在学习什么？](https://mp.weixin.qq.com/s?__biz=MzIyMjYyMzg3MA==&mid=2247484289&idx=1&sn=9e7f6c0c5e6707c8b3d0a73b36bc00c1&chksm=e82be290df5c6b86e2be66f2eea6ee88be1449c3b40d8ebf40932798f95e651fbaf49ca698d0&mpshare=1&scene=1&srcid=0728VrhaVGLU4L9ednVFlmev&pass_ticket=UuoqCxRu07cu1Iw3Eo8nDcUi6ufOxbjgwdd0cRPXNFEztRXx6J2qpa2gAXxKir5f#rd)\n<small>*推荐人：包京京*</small>\n大家都说学 Node.js 学 Node.js，到底是学它的什么呢？是学 JavaScript 这门语言，还是学 Node.js 的 API？还是学 Node.js 各种三方库？\n\n* [推荐一篇关于WebSocket 的教程](http://www.ruanyifeng.com/blog/2017/05/websocket.html)\n<small>*推荐人：陶明*</small>\n文章介绍了WebSocket 的特性及与HTTP对比在服务器推送上的优势，通过一个简单的示例介绍了WebSocket 部分API。\n\n* [推荐一篇介绍git工作流程的文章](http://www.cnblogs.com/cnblogsfans/p/5075073.html)\n<small>*推荐人：李丽娇*</small>\ngit成为现在最火的代码管理工具，文中详细介绍了git在团队中的使用流程，这种思路在团队协作中很是受用。同时文中介绍了gitflow使用的方法。\n\n* [理解 async/await](https://juejin.im/post/596e142d5188254b532ce2da)\n<small>*推荐人：耿少真*</small>\nasync 函数是 Generator 函数的语法糖。使用 关键字 async 来表示，在函数内部使用 await 来表示异步。\n\n* [http协议简介](http://www.jianshu.com/p/80e25cb1d81a)\n<small>*推荐人：郭俊兵*</small>\n大致了解下http协议相关内容，有利于了解前端开发时，调用后台接口，请求做了什么。\n\n* [Vue2.0 源码阅读：响应式原理](http://zhouweicsu.github.io/blog/2017/03/07/vue-2-0-reactivity/)\n<small>*推荐人：李志伟*</small>\n文章深入Vue源码，详细地解析了响应式原理。其原理大致可总结为：当数据发生改变后，相应的 setter 函数被触发，然后执行 notify 函数通知订阅者（Watcher）去更新相关视图，也会对新的数据重新 observe，更新相关的依赖关系。\n\n* [HTTP/2 Server Push 详解(原文)](https://www.smashingmagazine.com/2017/04/guide-http2-server-push/)\n<small>*推荐人：胡国伟*</small>\nServer Push可以将静态资源推送给客户端，实现多路复用，是HTTP/2众多协议优化中最令人振奋的特性，它大大降低了网络延迟对性能的影响。\n##### 翻译：\n  - [HTTP/2 Server Push 详解（上）](http://www.alloyteam.com/2017/04/guide-http2-server-push-part1/)\n  - [HTTP/2 Server Push 详解（下）](http://www.alloyteam.com/2017/04/guide-http2-server-push-part2/)\n\n* [深入vue2.0底层思想–模板渲染](http://mp.weixin.qq.com/s/L5VK5v3fmzdjLdT6Z6w-rA)\n<small>*推荐人：王俐*</small>\nVue 2.0 中模板渲染与 Vue 1.0的区别，1.0 中采用的 DocumentFragment （想了解可以观看这篇文章），而 2.0 中借鉴 React 的 Virtual DOM。基于 Virtual DOM，2.0 还可以支持服务端渲染（SSR），也支持 JSX 语法。\n\n* [iView 一周年了，同时发布了 2.0 正式版](https://zhuanlan.zhihu.com/p/28090879)\n<small>*推荐人：王祥*</small>\n一周年，两个大版本，很值得称赞的成绩！能跟梁灏这样优秀的前端生态贡献者共事，我感到非常荣幸！\n正如标题所言，2.0正式版将会是一个全新的开始，她将随着Vue社区的进步而快速迭代。\n期待vue社区和iView能有更好的发展，iView不会止于组件库，更期待iView deign、iView mobile…和更多优秀的开发者参与到开源生态的共建！","slug":"weekly-6","published":1,"updated":"2017-08-09T02:50:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6i92aux0007e1txvvdal8n1","content":"<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><ul>\n<li><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&amp;mid=2651552360&amp;idx=1&amp;sn=8d2bc092405fc23379a786a6b7a36274&amp;chksm=8025ada9b75224bfd372ce168cb0f9cb6959255e2a7e94556eacea5d1d8e4b559dd494704ae5&amp;mpshare=1&amp;scene=1&amp;srcid=0720bFFOVROJ90Pe2ZutzpQz#rd\" target=\"_blank\" rel=\"external\">CSS 样式书写规范</a><br><strong>不同的规范都有各自的长处与缺陷，对待所谓的规范最好的方式不是人云亦云，拿来就用，而是应该结合实际情况及需求，取长补短，取其精华去其糟粕。</strong></p>\n</li>\n<li><p><a href=\"https://segmentfault.com/a/1190000010150841\" target=\"_blank\" rel=\"external\">bfc初探</a><br><strong>bfc全称是块级格式化上下文（block formating context），是web可视化css渲染的一部分，它是块级盒子的布局发生，浮动互相交互的部分。</strong></p>\n</li>\n<li><p><a href=\"https://segmentfault.com/a/1190000010279009\" target=\"_blank\" rel=\"external\">es6精简学习</a><br><strong>秉着二八原则，掌握好常用的，有用的这个可以让我们快速起飞</strong></p>\n</li>\n</ul>\n<h2 id=\"文章\"><a href=\"#文章\" class=\"headerlink\" title=\"文章\"></a>文章</h2><ul>\n<li><p><a href=\"https://github.com/chenbin92/blog/issues/1\" target=\"_blank\" rel=\"external\">推荐一个Vuex的介绍文章</a><br><small><em>推荐人：张成斌</em></small><br>使用Vue做项目时，Vuex的使用与否和怎么使用始终是回避不了的一个问题。这篇文章或许能给你一些灵感。</p>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzIyMjYyMzg3MA==&amp;mid=2247484289&amp;idx=1&amp;sn=9e7f6c0c5e6707c8b3d0a73b36bc00c1&amp;chksm=e82be290df5c6b86e2be66f2eea6ee88be1449c3b40d8ebf40932798f95e651fbaf49ca698d0&amp;mpshare=1&amp;scene=1&amp;srcid=0728VrhaVGLU4L9ednVFlmev&amp;pass_ticket=UuoqCxRu07cu1Iw3Eo8nDcUi6ufOxbjgwdd0cRPXNFEztRXx6J2qpa2gAXxKir5f#rd\" target=\"_blank\" rel=\"external\">当我们学习 Node.js 时，我们在学习什么？</a><br><small><em>推荐人：包京京</em></small><br>大家都说学 Node.js 学 Node.js，到底是学它的什么呢？是学 JavaScript 这门语言，还是学 Node.js 的 API？还是学 Node.js 各种三方库？</p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2017/05/websocket.html\" target=\"_blank\" rel=\"external\">推荐一篇关于WebSocket 的教程</a><br><small><em>推荐人：陶明</em></small><br>文章介绍了WebSocket 的特性及与HTTP对比在服务器推送上的优势，通过一个简单的示例介绍了WebSocket 部分API。</p>\n</li>\n<li><p><a href=\"http://www.cnblogs.com/cnblogsfans/p/5075073.html\" target=\"_blank\" rel=\"external\">推荐一篇介绍git工作流程的文章</a><br><small><em>推荐人：李丽娇</em></small><br>git成为现在最火的代码管理工具，文中详细介绍了git在团队中的使用流程，这种思路在团队协作中很是受用。同时文中介绍了gitflow使用的方法。</p>\n</li>\n<li><p><a href=\"https://juejin.im/post/596e142d5188254b532ce2da\" target=\"_blank\" rel=\"external\">理解 async/await</a><br><small><em>推荐人：耿少真</em></small><br>async 函数是 Generator 函数的语法糖。使用 关键字 async 来表示，在函数内部使用 await 来表示异步。</p>\n</li>\n<li><p><a href=\"http://www.jianshu.com/p/80e25cb1d81a\" target=\"_blank\" rel=\"external\">http协议简介</a><br><small><em>推荐人：郭俊兵</em></small><br>大致了解下http协议相关内容，有利于了解前端开发时，调用后台接口，请求做了什么。</p>\n</li>\n<li><p><a href=\"http://zhouweicsu.github.io/blog/2017/03/07/vue-2-0-reactivity/\" target=\"_blank\" rel=\"external\">Vue2.0 源码阅读：响应式原理</a><br><small><em>推荐人：李志伟</em></small><br>文章深入Vue源码，详细地解析了响应式原理。其原理大致可总结为：当数据发生改变后，相应的 setter 函数被触发，然后执行 notify 函数通知订阅者（Watcher）去更新相关视图，也会对新的数据重新 observe，更新相关的依赖关系。</p>\n</li>\n<li><p><a href=\"https://www.smashingmagazine.com/2017/04/guide-http2-server-push/\" target=\"_blank\" rel=\"external\">HTTP/2 Server Push 详解(原文)</a><br><small><em>推荐人：胡国伟</em></small><br>Server Push可以将静态资源推送给客户端，实现多路复用，是HTTP/2众多协议优化中最令人振奋的特性，它大大降低了网络延迟对性能的影响。</p>\n<h5 id=\"翻译：\"><a href=\"#翻译：\" class=\"headerlink\" title=\"翻译：\"></a>翻译：</h5><ul>\n<li><a href=\"http://www.alloyteam.com/2017/04/guide-http2-server-push-part1/\" target=\"_blank\" rel=\"external\">HTTP/2 Server Push 详解（上）</a></li>\n<li><a href=\"http://www.alloyteam.com/2017/04/guide-http2-server-push-part2/\" target=\"_blank\" rel=\"external\">HTTP/2 Server Push 详解（下）</a></li>\n</ul>\n</li>\n<li><p><a href=\"http://mp.weixin.qq.com/s/L5VK5v3fmzdjLdT6Z6w-rA\" target=\"_blank\" rel=\"external\">深入vue2.0底层思想–模板渲染</a><br><small><em>推荐人：王俐</em></small><br>Vue 2.0 中模板渲染与 Vue 1.0的区别，1.0 中采用的 DocumentFragment （想了解可以观看这篇文章），而 2.0 中借鉴 React 的 Virtual DOM。基于 Virtual DOM，2.0 还可以支持服务端渲染（SSR），也支持 JSX 语法。</p>\n</li>\n<li><p><a href=\"https://zhuanlan.zhihu.com/p/28090879\" target=\"_blank\" rel=\"external\">iView 一周年了，同时发布了 2.0 正式版</a><br><small><em>推荐人：王祥</em></small><br>一周年，两个大版本，很值得称赞的成绩！能跟梁灏这样优秀的前端生态贡献者共事，我感到非常荣幸！<br>正如标题所言，2.0正式版将会是一个全新的开始，她将随着Vue社区的进步而快速迭代。<br>期待vue社区和iView能有更好的发展，iView不会止于组件库，更期待iView deign、iView mobile…和更多优秀的开发者参与到开源生态的共建！</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><ul>\n<li><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&amp;mid=2651552360&amp;idx=1&amp;sn=8d2bc092405fc23379a786a6b7a36274&amp;chksm=8025ada9b75224bfd372ce168cb0f9cb6959255e2a7e94556eacea5d1d8e4b559dd494704ae5&amp;mpshare=1&amp;scene=1&amp;srcid=0720bFFOVROJ90Pe2ZutzpQz#rd\" target=\"_blank\" rel=\"external\">CSS 样式书写规范</a><br><strong>不同的规范都有各自的长处与缺陷，对待所谓的规范最好的方式不是人云亦云，拿来就用，而是应该结合实际情况及需求，取长补短，取其精华去其糟粕。</strong></p>\n</li>\n<li><p><a href=\"https://segmentfault.com/a/1190000010150841\" target=\"_blank\" rel=\"external\">bfc初探</a><br><strong>bfc全称是块级格式化上下文（block formating context），是web可视化css渲染的一部分，它是块级盒子的布局发生，浮动互相交互的部分。</strong></p>\n</li>\n<li><p><a href=\"https://segmentfault.com/a/1190000010279009\" target=\"_blank\" rel=\"external\">es6精简学习</a><br><strong>秉着二八原则，掌握好常用的，有用的这个可以让我们快速起飞</strong></p>\n</li>\n</ul>\n<h2 id=\"文章\"><a href=\"#文章\" class=\"headerlink\" title=\"文章\"></a>文章</h2><ul>\n<li><p><a href=\"https://github.com/chenbin92/blog/issues/1\" target=\"_blank\" rel=\"external\">推荐一个Vuex的介绍文章</a><br><small><em>推荐人：张成斌</em></small><br>使用Vue做项目时，Vuex的使用与否和怎么使用始终是回避不了的一个问题。这篇文章或许能给你一些灵感。</p>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzIyMjYyMzg3MA==&amp;mid=2247484289&amp;idx=1&amp;sn=9e7f6c0c5e6707c8b3d0a73b36bc00c1&amp;chksm=e82be290df5c6b86e2be66f2eea6ee88be1449c3b40d8ebf40932798f95e651fbaf49ca698d0&amp;mpshare=1&amp;scene=1&amp;srcid=0728VrhaVGLU4L9ednVFlmev&amp;pass_ticket=UuoqCxRu07cu1Iw3Eo8nDcUi6ufOxbjgwdd0cRPXNFEztRXx6J2qpa2gAXxKir5f#rd\" target=\"_blank\" rel=\"external\">当我们学习 Node.js 时，我们在学习什么？</a><br><small><em>推荐人：包京京</em></small><br>大家都说学 Node.js 学 Node.js，到底是学它的什么呢？是学 JavaScript 这门语言，还是学 Node.js 的 API？还是学 Node.js 各种三方库？</p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2017/05/websocket.html\" target=\"_blank\" rel=\"external\">推荐一篇关于WebSocket 的教程</a><br><small><em>推荐人：陶明</em></small><br>文章介绍了WebSocket 的特性及与HTTP对比在服务器推送上的优势，通过一个简单的示例介绍了WebSocket 部分API。</p>\n</li>\n<li><p><a href=\"http://www.cnblogs.com/cnblogsfans/p/5075073.html\" target=\"_blank\" rel=\"external\">推荐一篇介绍git工作流程的文章</a><br><small><em>推荐人：李丽娇</em></small><br>git成为现在最火的代码管理工具，文中详细介绍了git在团队中的使用流程，这种思路在团队协作中很是受用。同时文中介绍了gitflow使用的方法。</p>\n</li>\n<li><p><a href=\"https://juejin.im/post/596e142d5188254b532ce2da\" target=\"_blank\" rel=\"external\">理解 async/await</a><br><small><em>推荐人：耿少真</em></small><br>async 函数是 Generator 函数的语法糖。使用 关键字 async 来表示，在函数内部使用 await 来表示异步。</p>\n</li>\n<li><p><a href=\"http://www.jianshu.com/p/80e25cb1d81a\" target=\"_blank\" rel=\"external\">http协议简介</a><br><small><em>推荐人：郭俊兵</em></small><br>大致了解下http协议相关内容，有利于了解前端开发时，调用后台接口，请求做了什么。</p>\n</li>\n<li><p><a href=\"http://zhouweicsu.github.io/blog/2017/03/07/vue-2-0-reactivity/\" target=\"_blank\" rel=\"external\">Vue2.0 源码阅读：响应式原理</a><br><small><em>推荐人：李志伟</em></small><br>文章深入Vue源码，详细地解析了响应式原理。其原理大致可总结为：当数据发生改变后，相应的 setter 函数被触发，然后执行 notify 函数通知订阅者（Watcher）去更新相关视图，也会对新的数据重新 observe，更新相关的依赖关系。</p>\n</li>\n<li><p><a href=\"https://www.smashingmagazine.com/2017/04/guide-http2-server-push/\" target=\"_blank\" rel=\"external\">HTTP/2 Server Push 详解(原文)</a><br><small><em>推荐人：胡国伟</em></small><br>Server Push可以将静态资源推送给客户端，实现多路复用，是HTTP/2众多协议优化中最令人振奋的特性，它大大降低了网络延迟对性能的影响。</p>\n<h5 id=\"翻译：\"><a href=\"#翻译：\" class=\"headerlink\" title=\"翻译：\"></a>翻译：</h5><ul>\n<li><a href=\"http://www.alloyteam.com/2017/04/guide-http2-server-push-part1/\" target=\"_blank\" rel=\"external\">HTTP/2 Server Push 详解（上）</a></li>\n<li><a href=\"http://www.alloyteam.com/2017/04/guide-http2-server-push-part2/\" target=\"_blank\" rel=\"external\">HTTP/2 Server Push 详解（下）</a></li>\n</ul>\n</li>\n<li><p><a href=\"http://mp.weixin.qq.com/s/L5VK5v3fmzdjLdT6Z6w-rA\" target=\"_blank\" rel=\"external\">深入vue2.0底层思想–模板渲染</a><br><small><em>推荐人：王俐</em></small><br>Vue 2.0 中模板渲染与 Vue 1.0的区别，1.0 中采用的 DocumentFragment （想了解可以观看这篇文章），而 2.0 中借鉴 React 的 Virtual DOM。基于 Virtual DOM，2.0 还可以支持服务端渲染（SSR），也支持 JSX 语法。</p>\n</li>\n<li><p><a href=\"https://zhuanlan.zhihu.com/p/28090879\" target=\"_blank\" rel=\"external\">iView 一周年了，同时发布了 2.0 正式版</a><br><small><em>推荐人：王祥</em></small><br>一周年，两个大版本，很值得称赞的成绩！能跟梁灏这样优秀的前端生态贡献者共事，我感到非常荣幸！<br>正如标题所言，2.0正式版将会是一个全新的开始，她将随着Vue社区的进步而快速迭代。<br>期待vue社区和iView能有更好的发展，iView不会止于组件库，更期待iView deign、iView mobile…和更多优秀的开发者参与到开源生态的共建！</p>\n</li>\n</ul>\n"},{"title":"大前端周刊 第五期 （本期小编：陶明）","date":"2017-07-21T06:21:43.000Z","_content":"\n## 基础\n* [JS中关于this](https://kongchenglc.github.io/blog/%E5%85%B3%E4%BA%8Ethis20170716/)\n**关于this的几种绑定规则以及优先级**\n\n* [跨域资源共享 CORS](http://www.ruanyifeng.com/blog/2016/04/cors.html)\n**一个option请求引发的疑惑**\n\n* [表单脚本的基础知识](http://www.jianshu.com/p/fc2017f18525)\n**详细的总结了表单的属性、方法及事件**\n\n## 文章\n* [五种事件驱动的API架构](https://talkingdata.github.io/fsd/2017/07/21/5-protocols-for-event-driven-api-architectures/)\n<small>*推荐人：王祥*</small>\n本文会介绍 5 种事件驱动的 API 架构：WebSockets、WebHooks、REST Hooks、Pub-Sub， 以及 Server Sent Events，并分别介绍这几种架构的基础功能、使用方式以及各自的优缺点。\n对于 Node.js 开发者来说，我们天生就在使用事件驱动的架构，业界也越来越认可事件驱动架构和异步系统的优势，了解本文介绍的 5 种事件驱动API 架构。\n\n* [推荐一篇Three.js入门文章](https://zhuanlan.zhihu.com/p/27296011)\n<small>*推荐人：张成斌*</small>\n文章把学习Three.js需要掌握的基本概念和知识点讲解的很详细。并且结合代码实现了一个demo。对于Three.js有兴趣的同学，是一篇不错的入门文章。\n\n* [推荐一篇介绍RESTful API的文章](https://segmentfault.com/a/1190000010261115)\n<small>*推荐人：李丽娇*</small>\n介绍了RESTful API的实现思想，并从http请求方式和相应内容等方面给出详细示例。\n在项目接口设计和接口对接中可做实质性参考。\n\n* [读 Zepto 源码之 Event 模块](https://juejin.im/post/596d45d96fb9a06ba2688e44/?utm_source=weixinqun&utm_medium=feZeptoEvent)\n<small>*推荐人：胡国伟*</small>\n如何自己实现事件处理，本文通过深入浅出解读 Zepto Event 模块源码，给我们提供了很好的答案。\n\n* [深入探究 eventloop 与浏览器渲染的时序问题](https://www.404forest.com/2017/07/18/how-javascript-actually-works-eventloop-and-uirendering/)\n<small>*推荐人：陶明*</small>\n文章通过对那些『延迟』执行的函数思考，深入的对event loop和task进行了拆分讲解，通过实例与图示详细讲解了整个执行渲染过程。\n\n* [vue的Virtual Dom实现- snabbdom解密](http://www.cnblogs.com/xuntu/p/6800547.html)\n<small>*推荐人：李志伟*</small>\n文章通过详细的图文对照、算法代码解析讲述了虚拟dom的实现，Virtual Node作为纯数据对象，patch创建或者更新DOM树，diff算法用来比较同层级，然后通过钩子和扩展模块创建有attribute、props、eventlistener的复杂dom。\n\n* [ES6数组的扩展(rest参数和扩展运算符)](https://github.com/ruanyf/es6tutorial/blob/8c8be74712a9e0d1a5dbcc855fe3e574b9fd4e6b/docs/array.md)\n<small>*推荐人：耿少真*</small>\nrest参数和扩展运算符都是ES6新增的特性。\nrest参数的形式为：...变量名；扩展运算符是三个点（...）。\n\n ##### rest参数:\n  - rest参数用于获取函数的多余参数，这样就不需要使用arguments对象了, rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中\n\n ##### 扩展运算符:\n  - 扩展运算符可以看做是 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列\n\n* [程序员如何快速学习新的框架](https://mp.weixin.qq.com/s?__biz=MjM5Mjg4NDMwMA==&mid=2652975196&idx=1&sn=7775588a3e5a9cd44090f379766d2354&chksm=bd4ae37f8a3d6a69d00df95143c477440c4c494df56a101e4e076911a615e75f5b194cd4e182&mpshare=1&scene=1&srcid=0720soS6N4MjqELSisDoyamI#rd)\n<small>*推荐人：郭俊兵*</small>\n前端框架丰富多彩的今天，快速学习新的框架是每个前端程序员的必备技能。\n\n* [4种使用webpack提升vue应用的方式](https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&mid=2651226710&idx=1&sn=3c6848e002aabeb55d6e9456b646d03d&chksm=bd495bd28a3ed2c43c34afb19a4fb0aedfb489b847f5e27348b9a021242e115d6ddb158c9e32&mpshare=1&scene=1&srcid=0721vFmgm9iqGHwNUyqboDb3&pass_ticket=E7F2%2BBqX9jvbMHf320yfzDVuT2rXz5tmHzjKDL3CgheMLCPvEi2MI8tlg%2FO3xRtu#rd)\n<small>*推荐人：包京京*</small>\n本篇文章所提到的几个措施大家可能都曾经在项目里用过，但是就如作者所言：你只是在用，并不知道为什么用，本文最大的价值在于提供了系统的优化方案并解释了原因\n\n## 其他\n* [pell](https://github.com/jaredreich/pell)\n**一个非常轻的开源WYSIWYG 编辑器**\n* [three.js](https://threejs.org/examples/#webgl_animation_cloth)\n**three.js的Demo**\n","source":"_posts/weekly-5.md","raw":"---\ntitle: 大前端周刊 第五期 （本期小编：陶明）\ndate: 2017-07-21 14:21:43\ntags: [weekly,three.js,Zepto,ES6,Vue,事件驱动]\n---\n\n## 基础\n* [JS中关于this](https://kongchenglc.github.io/blog/%E5%85%B3%E4%BA%8Ethis20170716/)\n**关于this的几种绑定规则以及优先级**\n\n* [跨域资源共享 CORS](http://www.ruanyifeng.com/blog/2016/04/cors.html)\n**一个option请求引发的疑惑**\n\n* [表单脚本的基础知识](http://www.jianshu.com/p/fc2017f18525)\n**详细的总结了表单的属性、方法及事件**\n\n## 文章\n* [五种事件驱动的API架构](https://talkingdata.github.io/fsd/2017/07/21/5-protocols-for-event-driven-api-architectures/)\n<small>*推荐人：王祥*</small>\n本文会介绍 5 种事件驱动的 API 架构：WebSockets、WebHooks、REST Hooks、Pub-Sub， 以及 Server Sent Events，并分别介绍这几种架构的基础功能、使用方式以及各自的优缺点。\n对于 Node.js 开发者来说，我们天生就在使用事件驱动的架构，业界也越来越认可事件驱动架构和异步系统的优势，了解本文介绍的 5 种事件驱动API 架构。\n\n* [推荐一篇Three.js入门文章](https://zhuanlan.zhihu.com/p/27296011)\n<small>*推荐人：张成斌*</small>\n文章把学习Three.js需要掌握的基本概念和知识点讲解的很详细。并且结合代码实现了一个demo。对于Three.js有兴趣的同学，是一篇不错的入门文章。\n\n* [推荐一篇介绍RESTful API的文章](https://segmentfault.com/a/1190000010261115)\n<small>*推荐人：李丽娇*</small>\n介绍了RESTful API的实现思想，并从http请求方式和相应内容等方面给出详细示例。\n在项目接口设计和接口对接中可做实质性参考。\n\n* [读 Zepto 源码之 Event 模块](https://juejin.im/post/596d45d96fb9a06ba2688e44/?utm_source=weixinqun&utm_medium=feZeptoEvent)\n<small>*推荐人：胡国伟*</small>\n如何自己实现事件处理，本文通过深入浅出解读 Zepto Event 模块源码，给我们提供了很好的答案。\n\n* [深入探究 eventloop 与浏览器渲染的时序问题](https://www.404forest.com/2017/07/18/how-javascript-actually-works-eventloop-and-uirendering/)\n<small>*推荐人：陶明*</small>\n文章通过对那些『延迟』执行的函数思考，深入的对event loop和task进行了拆分讲解，通过实例与图示详细讲解了整个执行渲染过程。\n\n* [vue的Virtual Dom实现- snabbdom解密](http://www.cnblogs.com/xuntu/p/6800547.html)\n<small>*推荐人：李志伟*</small>\n文章通过详细的图文对照、算法代码解析讲述了虚拟dom的实现，Virtual Node作为纯数据对象，patch创建或者更新DOM树，diff算法用来比较同层级，然后通过钩子和扩展模块创建有attribute、props、eventlistener的复杂dom。\n\n* [ES6数组的扩展(rest参数和扩展运算符)](https://github.com/ruanyf/es6tutorial/blob/8c8be74712a9e0d1a5dbcc855fe3e574b9fd4e6b/docs/array.md)\n<small>*推荐人：耿少真*</small>\nrest参数和扩展运算符都是ES6新增的特性。\nrest参数的形式为：...变量名；扩展运算符是三个点（...）。\n\n ##### rest参数:\n  - rest参数用于获取函数的多余参数，这样就不需要使用arguments对象了, rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中\n\n ##### 扩展运算符:\n  - 扩展运算符可以看做是 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列\n\n* [程序员如何快速学习新的框架](https://mp.weixin.qq.com/s?__biz=MjM5Mjg4NDMwMA==&mid=2652975196&idx=1&sn=7775588a3e5a9cd44090f379766d2354&chksm=bd4ae37f8a3d6a69d00df95143c477440c4c494df56a101e4e076911a615e75f5b194cd4e182&mpshare=1&scene=1&srcid=0720soS6N4MjqELSisDoyamI#rd)\n<small>*推荐人：郭俊兵*</small>\n前端框架丰富多彩的今天，快速学习新的框架是每个前端程序员的必备技能。\n\n* [4种使用webpack提升vue应用的方式](https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&mid=2651226710&idx=1&sn=3c6848e002aabeb55d6e9456b646d03d&chksm=bd495bd28a3ed2c43c34afb19a4fb0aedfb489b847f5e27348b9a021242e115d6ddb158c9e32&mpshare=1&scene=1&srcid=0721vFmgm9iqGHwNUyqboDb3&pass_ticket=E7F2%2BBqX9jvbMHf320yfzDVuT2rXz5tmHzjKDL3CgheMLCPvEi2MI8tlg%2FO3xRtu#rd)\n<small>*推荐人：包京京*</small>\n本篇文章所提到的几个措施大家可能都曾经在项目里用过，但是就如作者所言：你只是在用，并不知道为什么用，本文最大的价值在于提供了系统的优化方案并解释了原因\n\n## 其他\n* [pell](https://github.com/jaredreich/pell)\n**一个非常轻的开源WYSIWYG 编辑器**\n* [three.js](https://threejs.org/examples/#webgl_animation_cloth)\n**three.js的Demo**\n","slug":"weekly-5","published":1,"updated":"2017-08-09T02:50:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6i92auy0008e1txqhp9v106","content":"<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><ul>\n<li><p><a href=\"https://kongchenglc.github.io/blog/%E5%85%B3%E4%BA%8Ethis20170716/\" target=\"_blank\" rel=\"external\">JS中关于this</a><br><strong>关于this的几种绑定规则以及优先级</strong></p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2016/04/cors.html\" target=\"_blank\" rel=\"external\">跨域资源共享 CORS</a><br><strong>一个option请求引发的疑惑</strong></p>\n</li>\n<li><p><a href=\"http://www.jianshu.com/p/fc2017f18525\" target=\"_blank\" rel=\"external\">表单脚本的基础知识</a><br><strong>详细的总结了表单的属性、方法及事件</strong></p>\n</li>\n</ul>\n<h2 id=\"文章\"><a href=\"#文章\" class=\"headerlink\" title=\"文章\"></a>文章</h2><ul>\n<li><p><a href=\"https://talkingdata.github.io/fsd/2017/07/21/5-protocols-for-event-driven-api-architectures/\">五种事件驱动的API架构</a><br><small><em>推荐人：王祥</em></small><br>本文会介绍 5 种事件驱动的 API 架构：WebSockets、WebHooks、REST Hooks、Pub-Sub， 以及 Server Sent Events，并分别介绍这几种架构的基础功能、使用方式以及各自的优缺点。<br>对于 Node.js 开发者来说，我们天生就在使用事件驱动的架构，业界也越来越认可事件驱动架构和异步系统的优势，了解本文介绍的 5 种事件驱动API 架构。</p>\n</li>\n<li><p><a href=\"https://zhuanlan.zhihu.com/p/27296011\" target=\"_blank\" rel=\"external\">推荐一篇Three.js入门文章</a><br><small><em>推荐人：张成斌</em></small><br>文章把学习Three.js需要掌握的基本概念和知识点讲解的很详细。并且结合代码实现了一个demo。对于Three.js有兴趣的同学，是一篇不错的入门文章。</p>\n</li>\n<li><p><a href=\"https://segmentfault.com/a/1190000010261115\" target=\"_blank\" rel=\"external\">推荐一篇介绍RESTful API的文章</a><br><small><em>推荐人：李丽娇</em></small><br>介绍了RESTful API的实现思想，并从http请求方式和相应内容等方面给出详细示例。<br>在项目接口设计和接口对接中可做实质性参考。</p>\n</li>\n<li><p><a href=\"https://juejin.im/post/596d45d96fb9a06ba2688e44/?utm_source=weixinqun&amp;utm_medium=feZeptoEvent\" target=\"_blank\" rel=\"external\">读 Zepto 源码之 Event 模块</a><br><small><em>推荐人：胡国伟</em></small><br>如何自己实现事件处理，本文通过深入浅出解读 Zepto Event 模块源码，给我们提供了很好的答案。</p>\n</li>\n<li><p><a href=\"https://www.404forest.com/2017/07/18/how-javascript-actually-works-eventloop-and-uirendering/\" target=\"_blank\" rel=\"external\">深入探究 eventloop 与浏览器渲染的时序问题</a><br><small><em>推荐人：陶明</em></small><br>文章通过对那些『延迟』执行的函数思考，深入的对event loop和task进行了拆分讲解，通过实例与图示详细讲解了整个执行渲染过程。</p>\n</li>\n<li><p><a href=\"http://www.cnblogs.com/xuntu/p/6800547.html\" target=\"_blank\" rel=\"external\">vue的Virtual Dom实现- snabbdom解密</a><br><small><em>推荐人：李志伟</em></small><br>文章通过详细的图文对照、算法代码解析讲述了虚拟dom的实现，Virtual Node作为纯数据对象，patch创建或者更新DOM树，diff算法用来比较同层级，然后通过钩子和扩展模块创建有attribute、props、eventlistener的复杂dom。</p>\n</li>\n<li><p><a href=\"https://github.com/ruanyf/es6tutorial/blob/8c8be74712a9e0d1a5dbcc855fe3e574b9fd4e6b/docs/array.md\" target=\"_blank\" rel=\"external\">ES6数组的扩展(rest参数和扩展运算符)</a><br><small><em>推荐人：耿少真</em></small><br>rest参数和扩展运算符都是ES6新增的特性。<br>rest参数的形式为：…变量名；扩展运算符是三个点（…）。</p>\n<h5 id=\"rest参数\"><a href=\"#rest参数\" class=\"headerlink\" title=\"rest参数:\"></a>rest参数:</h5><ul>\n<li>rest参数用于获取函数的多余参数，这样就不需要使用arguments对象了, rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中</li>\n</ul>\n<h5 id=\"扩展运算符\"><a href=\"#扩展运算符\" class=\"headerlink\" title=\"扩展运算符:\"></a>扩展运算符:</h5><ul>\n<li>扩展运算符可以看做是 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列</li>\n</ul>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5Mjg4NDMwMA==&amp;mid=2652975196&amp;idx=1&amp;sn=7775588a3e5a9cd44090f379766d2354&amp;chksm=bd4ae37f8a3d6a69d00df95143c477440c4c494df56a101e4e076911a615e75f5b194cd4e182&amp;mpshare=1&amp;scene=1&amp;srcid=0720soS6N4MjqELSisDoyamI#rd\" target=\"_blank\" rel=\"external\">程序员如何快速学习新的框架</a><br><small><em>推荐人：郭俊兵</em></small><br>前端框架丰富多彩的今天，快速学习新的框架是每个前端程序员的必备技能。</p>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651226710&amp;idx=1&amp;sn=3c6848e002aabeb55d6e9456b646d03d&amp;chksm=bd495bd28a3ed2c43c34afb19a4fb0aedfb489b847f5e27348b9a021242e115d6ddb158c9e32&amp;mpshare=1&amp;scene=1&amp;srcid=0721vFmgm9iqGHwNUyqboDb3&amp;pass_ticket=E7F2%2BBqX9jvbMHf320yfzDVuT2rXz5tmHzjKDL3CgheMLCPvEi2MI8tlg%2FO3xRtu#rd\" target=\"_blank\" rel=\"external\">4种使用webpack提升vue应用的方式</a><br><small><em>推荐人：包京京</em></small><br>本篇文章所提到的几个措施大家可能都曾经在项目里用过，但是就如作者所言：你只是在用，并不知道为什么用，本文最大的价值在于提供了系统的优化方案并解释了原因</p>\n</li>\n</ul>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><ul>\n<li><a href=\"https://github.com/jaredreich/pell\" target=\"_blank\" rel=\"external\">pell</a><br><strong>一个非常轻的开源WYSIWYG 编辑器</strong></li>\n<li><a href=\"https://threejs.org/examples/#webgl_animation_cloth\" target=\"_blank\" rel=\"external\">three.js</a><br><strong>three.js的Demo</strong></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><ul>\n<li><p><a href=\"https://kongchenglc.github.io/blog/%E5%85%B3%E4%BA%8Ethis20170716/\" target=\"_blank\" rel=\"external\">JS中关于this</a><br><strong>关于this的几种绑定规则以及优先级</strong></p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2016/04/cors.html\" target=\"_blank\" rel=\"external\">跨域资源共享 CORS</a><br><strong>一个option请求引发的疑惑</strong></p>\n</li>\n<li><p><a href=\"http://www.jianshu.com/p/fc2017f18525\" target=\"_blank\" rel=\"external\">表单脚本的基础知识</a><br><strong>详细的总结了表单的属性、方法及事件</strong></p>\n</li>\n</ul>\n<h2 id=\"文章\"><a href=\"#文章\" class=\"headerlink\" title=\"文章\"></a>文章</h2><ul>\n<li><p><a href=\"https://talkingdata.github.io/fsd/2017/07/21/5-protocols-for-event-driven-api-architectures/\">五种事件驱动的API架构</a><br><small><em>推荐人：王祥</em></small><br>本文会介绍 5 种事件驱动的 API 架构：WebSockets、WebHooks、REST Hooks、Pub-Sub， 以及 Server Sent Events，并分别介绍这几种架构的基础功能、使用方式以及各自的优缺点。<br>对于 Node.js 开发者来说，我们天生就在使用事件驱动的架构，业界也越来越认可事件驱动架构和异步系统的优势，了解本文介绍的 5 种事件驱动API 架构。</p>\n</li>\n<li><p><a href=\"https://zhuanlan.zhihu.com/p/27296011\" target=\"_blank\" rel=\"external\">推荐一篇Three.js入门文章</a><br><small><em>推荐人：张成斌</em></small><br>文章把学习Three.js需要掌握的基本概念和知识点讲解的很详细。并且结合代码实现了一个demo。对于Three.js有兴趣的同学，是一篇不错的入门文章。</p>\n</li>\n<li><p><a href=\"https://segmentfault.com/a/1190000010261115\" target=\"_blank\" rel=\"external\">推荐一篇介绍RESTful API的文章</a><br><small><em>推荐人：李丽娇</em></small><br>介绍了RESTful API的实现思想，并从http请求方式和相应内容等方面给出详细示例。<br>在项目接口设计和接口对接中可做实质性参考。</p>\n</li>\n<li><p><a href=\"https://juejin.im/post/596d45d96fb9a06ba2688e44/?utm_source=weixinqun&amp;utm_medium=feZeptoEvent\" target=\"_blank\" rel=\"external\">读 Zepto 源码之 Event 模块</a><br><small><em>推荐人：胡国伟</em></small><br>如何自己实现事件处理，本文通过深入浅出解读 Zepto Event 模块源码，给我们提供了很好的答案。</p>\n</li>\n<li><p><a href=\"https://www.404forest.com/2017/07/18/how-javascript-actually-works-eventloop-and-uirendering/\" target=\"_blank\" rel=\"external\">深入探究 eventloop 与浏览器渲染的时序问题</a><br><small><em>推荐人：陶明</em></small><br>文章通过对那些『延迟』执行的函数思考，深入的对event loop和task进行了拆分讲解，通过实例与图示详细讲解了整个执行渲染过程。</p>\n</li>\n<li><p><a href=\"http://www.cnblogs.com/xuntu/p/6800547.html\" target=\"_blank\" rel=\"external\">vue的Virtual Dom实现- snabbdom解密</a><br><small><em>推荐人：李志伟</em></small><br>文章通过详细的图文对照、算法代码解析讲述了虚拟dom的实现，Virtual Node作为纯数据对象，patch创建或者更新DOM树，diff算法用来比较同层级，然后通过钩子和扩展模块创建有attribute、props、eventlistener的复杂dom。</p>\n</li>\n<li><p><a href=\"https://github.com/ruanyf/es6tutorial/blob/8c8be74712a9e0d1a5dbcc855fe3e574b9fd4e6b/docs/array.md\" target=\"_blank\" rel=\"external\">ES6数组的扩展(rest参数和扩展运算符)</a><br><small><em>推荐人：耿少真</em></small><br>rest参数和扩展运算符都是ES6新增的特性。<br>rest参数的形式为：…变量名；扩展运算符是三个点（…）。</p>\n<h5 id=\"rest参数\"><a href=\"#rest参数\" class=\"headerlink\" title=\"rest参数:\"></a>rest参数:</h5><ul>\n<li>rest参数用于获取函数的多余参数，这样就不需要使用arguments对象了, rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中</li>\n</ul>\n<h5 id=\"扩展运算符\"><a href=\"#扩展运算符\" class=\"headerlink\" title=\"扩展运算符:\"></a>扩展运算符:</h5><ul>\n<li>扩展运算符可以看做是 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列</li>\n</ul>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5Mjg4NDMwMA==&amp;mid=2652975196&amp;idx=1&amp;sn=7775588a3e5a9cd44090f379766d2354&amp;chksm=bd4ae37f8a3d6a69d00df95143c477440c4c494df56a101e4e076911a615e75f5b194cd4e182&amp;mpshare=1&amp;scene=1&amp;srcid=0720soS6N4MjqELSisDoyamI#rd\" target=\"_blank\" rel=\"external\">程序员如何快速学习新的框架</a><br><small><em>推荐人：郭俊兵</em></small><br>前端框架丰富多彩的今天，快速学习新的框架是每个前端程序员的必备技能。</p>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651226710&amp;idx=1&amp;sn=3c6848e002aabeb55d6e9456b646d03d&amp;chksm=bd495bd28a3ed2c43c34afb19a4fb0aedfb489b847f5e27348b9a021242e115d6ddb158c9e32&amp;mpshare=1&amp;scene=1&amp;srcid=0721vFmgm9iqGHwNUyqboDb3&amp;pass_ticket=E7F2%2BBqX9jvbMHf320yfzDVuT2rXz5tmHzjKDL3CgheMLCPvEi2MI8tlg%2FO3xRtu#rd\" target=\"_blank\" rel=\"external\">4种使用webpack提升vue应用的方式</a><br><small><em>推荐人：包京京</em></small><br>本篇文章所提到的几个措施大家可能都曾经在项目里用过，但是就如作者所言：你只是在用，并不知道为什么用，本文最大的价值在于提供了系统的优化方案并解释了原因</p>\n</li>\n</ul>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><ul>\n<li><a href=\"https://github.com/jaredreich/pell\" target=\"_blank\" rel=\"external\">pell</a><br><strong>一个非常轻的开源WYSIWYG 编辑器</strong></li>\n<li><a href=\"https://threejs.org/examples/#webgl_animation_cloth\" target=\"_blank\" rel=\"external\">three.js</a><br><strong>three.js的Demo</strong></li>\n</ul>\n"},{"title":"大前端周刊 第九期 （本期小编：包京京）","date":"2017-08-18T06:57:34.000Z","_content":"## 基础\n\n* [javascript数据结构](http://blog.benoitvallon.com/data-structures-in-javascript/data-structures-in-javascript/)\n**用javascript创建并分析各种常见数据结构**\n\n* [理解Service Worker](https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&mid=2651226809&idx=1&sn=514ca88902bc91840f363348d6c86c39&chksm=bd495b3d8a3ed22bcf78801f96ae5c8d9555792d599004a7dc47a5a528185b9734f78af565fb&mpshare=1&scene=1&srcid=08182YSPaUr4JxGj4iID40gs&pass_ticket=0Et24OmYtRSLgA6Geno1MGBk5RujsQrVbaq%2FwZJ%2BzwtD%2F%2FbnV8lCXfDaw3Z5FpPr#rd)\n**PWA是最近前端最火热的一个概念之一，Service Worker是支持PWA的核心技术之一**\n\n* [常见排序算法之JavaScript实现](https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&mid=2651226816&idx=1&sn=5c2de943a3ff61de10466bfe21f973c2&chksm=bd495b448a3ed2529d674d66eab367d3b2c9c1516f70206ea36aaa5439703288168a6305d48f&mpshare=1&scene=1&srcid=0818znt16EAbHf0IGrXO1guY&pass_ticket=0Et24OmYtRSLgA6Geno1MGBk5RujsQrVbaq%2FwZJ%2BzwtD%2F%2FbnV8lCXfDaw3Z5FpPr#rd)\n**排序算法是基础算法。本文用javascript和算法可视化工具将各种排序算法实现了一遍**\n\n\n## 文章\n* [饿了么的 PWA 升级实践](https://zhuanlan.zhihu.com/p/27853228)\n<small>*推荐人: 胡国伟*</small>\n饿了吗本次分享了基于 vue.js 的升级实践，踩坑跳坑的过程非常精彩。阅读完本文之余也可了解下Lavas：百度推出的基于 Vue 的 PWA 解决方案，其号称帮助开发者快速搭建 PWA 应用，解决接入 PWA 的各种问题。\n\n* [Vuex框架原理与源码分析](https://tech.meituan.com/vuex-code-analysis.html)\n<small>*推荐人：李志伟*</small>\n文章首先抛出5个核心问题，然后介绍各模块核心流程，结合图解、代码示例更利于理解。理清store构造方法你也就大致明白Vuex的实现了。\n\n* [每个JavaScript开发者都该懂的Unicode](https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&mid=2651552440&idx=1&sn=01bdb132ed0383a47993d711120b4283&chksm=8025ad79b752246fef6761482dbace0d9899ac00982a238063749400e4b0aed38140005ac869&mpshare=1&scene=1&srcid=0809B7Mm0d6x7DCLtBzpQKer#)\n<small>*推荐人：郭俊兵*</small>\n如果你觉得理解Unicode很难，那么是时候来面对它了！其实它没你想的那么难。让我们进入抽象概念、字符、星光平面(辅助平面)和代理对的世界。\n\n* [Webpack 性能优化 （一）](http://code.oneapm.com/javascript/2015/07/07/webpack_performance_1/)\n<small>*推荐人：陶明*</small>\n文章通过项目打包场景，介绍了 resolve.alias 即利用别名做重定向的方法，在此基础上，配合module.noParse 忽略对某些模块的解析可以进一步加快速度。\n\n* [分享一篇介绍JS调试技巧的文章](http://web.jobbole.com/85503/)\n<small>*推荐人：李丽娇*</small>\n据说程序员不是在改bug就是在写bug的路上，由此可见调试问题这个技能的重要性。文中介绍了多种JS的调试工具和方法，并配有GIF图演示。快GET起来吧！\n\n* [Koa2进阶学习笔记](https://chenshenhai.github.io/koa2-note/)\n<small>*推荐人：耿少真*</small>\n基于async/await实现中间体系的koa2框架将会是是node.js web开发方向大势所趋的普及框架。基于generator/yield的koa1将会逐渐被koa2替代，毕竟使用co.js来处理generator是一种过渡的方式，虽然有其特定的应用场景，但是用async/await会更加优雅地实现同步写法。\n\n* [前端开发持续集成/持续部署(CI/CD)实例](http://annn.me/frontend-ci-cd/)\n<small>*推荐人：包京京*</small>\n近几年，前端项目也引入了编译，构建，单元测试等现代软件工程化的标准环节。这样大提高了前端的开发效率和业务交付能力。在项目部署阶段，我们还需要引入 CI / CD 等现代化的软件开发实践，来减少风险，自动化重复操作，节省我们的时间。本文主要分享一下如何基于 gitlab 、 jenkins 让 CI/CD 跑起来。\n\n* [滴滴 webapp 5.0 Vue 2.0 重构经验分享](https://github.com/DDFE/DDFE-blog/issues/13)\n<small>*推荐人：张成斌*</small>\n滴滴的 webapp 是运行在微信、支付宝、手 Q 以及其它第三方渠道的打车软件。借着产品层面的功能和视觉升级，我们用 Vue 2.0 对它进行了一次技术重构；本文即是本次重构中的经验分享。\n\n* [前端工程化实践](http://wxnet.me/2017/08/18/front-end-engineering-practice/)\n<small>*推荐人：王祥*</small>\n第一篇原创文章，总结了TalkingData DTU可视化团队，在2017年上半年的实践和尝试。内容包括git工作流、代码规范和大前端的目标确定，总结过往，才能更好的迎接未来。\n","source":"_posts/weekly-9.md","raw":"---\ntitle: 大前端周刊 第九期 （本期小编：包京京）\ndate: 2017-08-18 14:57:34\ntags: [weekly,工程化实践,Vuex,Webpack,PWA,持续部署]\n---\n## 基础\n\n* [javascript数据结构](http://blog.benoitvallon.com/data-structures-in-javascript/data-structures-in-javascript/)\n**用javascript创建并分析各种常见数据结构**\n\n* [理解Service Worker](https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&mid=2651226809&idx=1&sn=514ca88902bc91840f363348d6c86c39&chksm=bd495b3d8a3ed22bcf78801f96ae5c8d9555792d599004a7dc47a5a528185b9734f78af565fb&mpshare=1&scene=1&srcid=08182YSPaUr4JxGj4iID40gs&pass_ticket=0Et24OmYtRSLgA6Geno1MGBk5RujsQrVbaq%2FwZJ%2BzwtD%2F%2FbnV8lCXfDaw3Z5FpPr#rd)\n**PWA是最近前端最火热的一个概念之一，Service Worker是支持PWA的核心技术之一**\n\n* [常见排序算法之JavaScript实现](https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&mid=2651226816&idx=1&sn=5c2de943a3ff61de10466bfe21f973c2&chksm=bd495b448a3ed2529d674d66eab367d3b2c9c1516f70206ea36aaa5439703288168a6305d48f&mpshare=1&scene=1&srcid=0818znt16EAbHf0IGrXO1guY&pass_ticket=0Et24OmYtRSLgA6Geno1MGBk5RujsQrVbaq%2FwZJ%2BzwtD%2F%2FbnV8lCXfDaw3Z5FpPr#rd)\n**排序算法是基础算法。本文用javascript和算法可视化工具将各种排序算法实现了一遍**\n\n\n## 文章\n* [饿了么的 PWA 升级实践](https://zhuanlan.zhihu.com/p/27853228)\n<small>*推荐人: 胡国伟*</small>\n饿了吗本次分享了基于 vue.js 的升级实践，踩坑跳坑的过程非常精彩。阅读完本文之余也可了解下Lavas：百度推出的基于 Vue 的 PWA 解决方案，其号称帮助开发者快速搭建 PWA 应用，解决接入 PWA 的各种问题。\n\n* [Vuex框架原理与源码分析](https://tech.meituan.com/vuex-code-analysis.html)\n<small>*推荐人：李志伟*</small>\n文章首先抛出5个核心问题，然后介绍各模块核心流程，结合图解、代码示例更利于理解。理清store构造方法你也就大致明白Vuex的实现了。\n\n* [每个JavaScript开发者都该懂的Unicode](https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&mid=2651552440&idx=1&sn=01bdb132ed0383a47993d711120b4283&chksm=8025ad79b752246fef6761482dbace0d9899ac00982a238063749400e4b0aed38140005ac869&mpshare=1&scene=1&srcid=0809B7Mm0d6x7DCLtBzpQKer#)\n<small>*推荐人：郭俊兵*</small>\n如果你觉得理解Unicode很难，那么是时候来面对它了！其实它没你想的那么难。让我们进入抽象概念、字符、星光平面(辅助平面)和代理对的世界。\n\n* [Webpack 性能优化 （一）](http://code.oneapm.com/javascript/2015/07/07/webpack_performance_1/)\n<small>*推荐人：陶明*</small>\n文章通过项目打包场景，介绍了 resolve.alias 即利用别名做重定向的方法，在此基础上，配合module.noParse 忽略对某些模块的解析可以进一步加快速度。\n\n* [分享一篇介绍JS调试技巧的文章](http://web.jobbole.com/85503/)\n<small>*推荐人：李丽娇*</small>\n据说程序员不是在改bug就是在写bug的路上，由此可见调试问题这个技能的重要性。文中介绍了多种JS的调试工具和方法，并配有GIF图演示。快GET起来吧！\n\n* [Koa2进阶学习笔记](https://chenshenhai.github.io/koa2-note/)\n<small>*推荐人：耿少真*</small>\n基于async/await实现中间体系的koa2框架将会是是node.js web开发方向大势所趋的普及框架。基于generator/yield的koa1将会逐渐被koa2替代，毕竟使用co.js来处理generator是一种过渡的方式，虽然有其特定的应用场景，但是用async/await会更加优雅地实现同步写法。\n\n* [前端开发持续集成/持续部署(CI/CD)实例](http://annn.me/frontend-ci-cd/)\n<small>*推荐人：包京京*</small>\n近几年，前端项目也引入了编译，构建，单元测试等现代软件工程化的标准环节。这样大提高了前端的开发效率和业务交付能力。在项目部署阶段，我们还需要引入 CI / CD 等现代化的软件开发实践，来减少风险，自动化重复操作，节省我们的时间。本文主要分享一下如何基于 gitlab 、 jenkins 让 CI/CD 跑起来。\n\n* [滴滴 webapp 5.0 Vue 2.0 重构经验分享](https://github.com/DDFE/DDFE-blog/issues/13)\n<small>*推荐人：张成斌*</small>\n滴滴的 webapp 是运行在微信、支付宝、手 Q 以及其它第三方渠道的打车软件。借着产品层面的功能和视觉升级，我们用 Vue 2.0 对它进行了一次技术重构；本文即是本次重构中的经验分享。\n\n* [前端工程化实践](http://wxnet.me/2017/08/18/front-end-engineering-practice/)\n<small>*推荐人：王祥*</small>\n第一篇原创文章，总结了TalkingData DTU可视化团队，在2017年上半年的实践和尝试。内容包括git工作流、代码规范和大前端的目标确定，总结过往，才能更好的迎接未来。\n","slug":"weekly-9","published":1,"updated":"2017-08-18T19:10:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6i92av2000ae1txzd3w04cw","content":"<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><ul>\n<li><p><a href=\"http://blog.benoitvallon.com/data-structures-in-javascript/data-structures-in-javascript/\" target=\"_blank\" rel=\"external\">javascript数据结构</a><br><strong>用javascript创建并分析各种常见数据结构</strong></p>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651226809&amp;idx=1&amp;sn=514ca88902bc91840f363348d6c86c39&amp;chksm=bd495b3d8a3ed22bcf78801f96ae5c8d9555792d599004a7dc47a5a528185b9734f78af565fb&amp;mpshare=1&amp;scene=1&amp;srcid=08182YSPaUr4JxGj4iID40gs&amp;pass_ticket=0Et24OmYtRSLgA6Geno1MGBk5RujsQrVbaq%2FwZJ%2BzwtD%2F%2FbnV8lCXfDaw3Z5FpPr#rd\" target=\"_blank\" rel=\"external\">理解Service Worker</a><br><strong>PWA是最近前端最火热的一个概念之一，Service Worker是支持PWA的核心技术之一</strong></p>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651226816&amp;idx=1&amp;sn=5c2de943a3ff61de10466bfe21f973c2&amp;chksm=bd495b448a3ed2529d674d66eab367d3b2c9c1516f70206ea36aaa5439703288168a6305d48f&amp;mpshare=1&amp;scene=1&amp;srcid=0818znt16EAbHf0IGrXO1guY&amp;pass_ticket=0Et24OmYtRSLgA6Geno1MGBk5RujsQrVbaq%2FwZJ%2BzwtD%2F%2FbnV8lCXfDaw3Z5FpPr#rd\" target=\"_blank\" rel=\"external\">常见排序算法之JavaScript实现</a><br><strong>排序算法是基础算法。本文用javascript和算法可视化工具将各种排序算法实现了一遍</strong></p>\n</li>\n</ul>\n<h2 id=\"文章\"><a href=\"#文章\" class=\"headerlink\" title=\"文章\"></a>文章</h2><ul>\n<li><p><a href=\"https://zhuanlan.zhihu.com/p/27853228\" target=\"_blank\" rel=\"external\">饿了么的 PWA 升级实践</a><br><small><em>推荐人: 胡国伟</em></small><br>饿了吗本次分享了基于 vue.js 的升级实践，踩坑跳坑的过程非常精彩。阅读完本文之余也可了解下Lavas：百度推出的基于 Vue 的 PWA 解决方案，其号称帮助开发者快速搭建 PWA 应用，解决接入 PWA 的各种问题。</p>\n</li>\n<li><p><a href=\"https://tech.meituan.com/vuex-code-analysis.html\" target=\"_blank\" rel=\"external\">Vuex框架原理与源码分析</a><br><small><em>推荐人：李志伟</em></small><br>文章首先抛出5个核心问题，然后介绍各模块核心流程，结合图解、代码示例更利于理解。理清store构造方法你也就大致明白Vuex的实现了。</p>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&amp;mid=2651552440&amp;idx=1&amp;sn=01bdb132ed0383a47993d711120b4283&amp;chksm=8025ad79b752246fef6761482dbace0d9899ac00982a238063749400e4b0aed38140005ac869&amp;mpshare=1&amp;scene=1&amp;srcid=0809B7Mm0d6x7DCLtBzpQKer#\" target=\"_blank\" rel=\"external\">每个JavaScript开发者都该懂的Unicode</a><br><small><em>推荐人：郭俊兵</em></small><br>如果你觉得理解Unicode很难，那么是时候来面对它了！其实它没你想的那么难。让我们进入抽象概念、字符、星光平面(辅助平面)和代理对的世界。</p>\n</li>\n<li><p><a href=\"http://code.oneapm.com/javascript/2015/07/07/webpack_performance_1/\" target=\"_blank\" rel=\"external\">Webpack 性能优化 （一）</a><br><small><em>推荐人：陶明</em></small><br>文章通过项目打包场景，介绍了 resolve.alias 即利用别名做重定向的方法，在此基础上，配合module.noParse 忽略对某些模块的解析可以进一步加快速度。</p>\n</li>\n<li><p><a href=\"http://web.jobbole.com/85503/\" target=\"_blank\" rel=\"external\">分享一篇介绍JS调试技巧的文章</a><br><small><em>推荐人：李丽娇</em></small><br>据说程序员不是在改bug就是在写bug的路上，由此可见调试问题这个技能的重要性。文中介绍了多种JS的调试工具和方法，并配有GIF图演示。快GET起来吧！</p>\n</li>\n<li><p><a href=\"https://chenshenhai.github.io/koa2-note/\" target=\"_blank\" rel=\"external\">Koa2进阶学习笔记</a><br><small><em>推荐人：耿少真</em></small><br>基于async/await实现中间体系的koa2框架将会是是node.js web开发方向大势所趋的普及框架。基于generator/yield的koa1将会逐渐被koa2替代，毕竟使用co.js来处理generator是一种过渡的方式，虽然有其特定的应用场景，但是用async/await会更加优雅地实现同步写法。</p>\n</li>\n<li><p><a href=\"http://annn.me/frontend-ci-cd/\" target=\"_blank\" rel=\"external\">前端开发持续集成/持续部署(CI/CD)实例</a><br><small><em>推荐人：包京京</em></small><br>近几年，前端项目也引入了编译，构建，单元测试等现代软件工程化的标准环节。这样大提高了前端的开发效率和业务交付能力。在项目部署阶段，我们还需要引入 CI / CD 等现代化的软件开发实践，来减少风险，自动化重复操作，节省我们的时间。本文主要分享一下如何基于 gitlab 、 jenkins 让 CI/CD 跑起来。</p>\n</li>\n<li><p><a href=\"https://github.com/DDFE/DDFE-blog/issues/13\" target=\"_blank\" rel=\"external\">滴滴 webapp 5.0 Vue 2.0 重构经验分享</a><br><small><em>推荐人：张成斌</em></small><br>滴滴的 webapp 是运行在微信、支付宝、手 Q 以及其它第三方渠道的打车软件。借着产品层面的功能和视觉升级，我们用 Vue 2.0 对它进行了一次技术重构；本文即是本次重构中的经验分享。</p>\n</li>\n<li><p><a href=\"http://wxnet.me/2017/08/18/front-end-engineering-practice/\" target=\"_blank\" rel=\"external\">前端工程化实践</a><br><small><em>推荐人：王祥</em></small><br>第一篇原创文章，总结了TalkingData DTU可视化团队，在2017年上半年的实践和尝试。内容包括git工作流、代码规范和大前端的目标确定，总结过往，才能更好的迎接未来。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><ul>\n<li><p><a href=\"http://blog.benoitvallon.com/data-structures-in-javascript/data-structures-in-javascript/\" target=\"_blank\" rel=\"external\">javascript数据结构</a><br><strong>用javascript创建并分析各种常见数据结构</strong></p>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651226809&amp;idx=1&amp;sn=514ca88902bc91840f363348d6c86c39&amp;chksm=bd495b3d8a3ed22bcf78801f96ae5c8d9555792d599004a7dc47a5a528185b9734f78af565fb&amp;mpshare=1&amp;scene=1&amp;srcid=08182YSPaUr4JxGj4iID40gs&amp;pass_ticket=0Et24OmYtRSLgA6Geno1MGBk5RujsQrVbaq%2FwZJ%2BzwtD%2F%2FbnV8lCXfDaw3Z5FpPr#rd\" target=\"_blank\" rel=\"external\">理解Service Worker</a><br><strong>PWA是最近前端最火热的一个概念之一，Service Worker是支持PWA的核心技术之一</strong></p>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651226816&amp;idx=1&amp;sn=5c2de943a3ff61de10466bfe21f973c2&amp;chksm=bd495b448a3ed2529d674d66eab367d3b2c9c1516f70206ea36aaa5439703288168a6305d48f&amp;mpshare=1&amp;scene=1&amp;srcid=0818znt16EAbHf0IGrXO1guY&amp;pass_ticket=0Et24OmYtRSLgA6Geno1MGBk5RujsQrVbaq%2FwZJ%2BzwtD%2F%2FbnV8lCXfDaw3Z5FpPr#rd\" target=\"_blank\" rel=\"external\">常见排序算法之JavaScript实现</a><br><strong>排序算法是基础算法。本文用javascript和算法可视化工具将各种排序算法实现了一遍</strong></p>\n</li>\n</ul>\n<h2 id=\"文章\"><a href=\"#文章\" class=\"headerlink\" title=\"文章\"></a>文章</h2><ul>\n<li><p><a href=\"https://zhuanlan.zhihu.com/p/27853228\" target=\"_blank\" rel=\"external\">饿了么的 PWA 升级实践</a><br><small><em>推荐人: 胡国伟</em></small><br>饿了吗本次分享了基于 vue.js 的升级实践，踩坑跳坑的过程非常精彩。阅读完本文之余也可了解下Lavas：百度推出的基于 Vue 的 PWA 解决方案，其号称帮助开发者快速搭建 PWA 应用，解决接入 PWA 的各种问题。</p>\n</li>\n<li><p><a href=\"https://tech.meituan.com/vuex-code-analysis.html\" target=\"_blank\" rel=\"external\">Vuex框架原理与源码分析</a><br><small><em>推荐人：李志伟</em></small><br>文章首先抛出5个核心问题，然后介绍各模块核心流程，结合图解、代码示例更利于理解。理清store构造方法你也就大致明白Vuex的实现了。</p>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&amp;mid=2651552440&amp;idx=1&amp;sn=01bdb132ed0383a47993d711120b4283&amp;chksm=8025ad79b752246fef6761482dbace0d9899ac00982a238063749400e4b0aed38140005ac869&amp;mpshare=1&amp;scene=1&amp;srcid=0809B7Mm0d6x7DCLtBzpQKer#\" target=\"_blank\" rel=\"external\">每个JavaScript开发者都该懂的Unicode</a><br><small><em>推荐人：郭俊兵</em></small><br>如果你觉得理解Unicode很难，那么是时候来面对它了！其实它没你想的那么难。让我们进入抽象概念、字符、星光平面(辅助平面)和代理对的世界。</p>\n</li>\n<li><p><a href=\"http://code.oneapm.com/javascript/2015/07/07/webpack_performance_1/\" target=\"_blank\" rel=\"external\">Webpack 性能优化 （一）</a><br><small><em>推荐人：陶明</em></small><br>文章通过项目打包场景，介绍了 resolve.alias 即利用别名做重定向的方法，在此基础上，配合module.noParse 忽略对某些模块的解析可以进一步加快速度。</p>\n</li>\n<li><p><a href=\"http://web.jobbole.com/85503/\" target=\"_blank\" rel=\"external\">分享一篇介绍JS调试技巧的文章</a><br><small><em>推荐人：李丽娇</em></small><br>据说程序员不是在改bug就是在写bug的路上，由此可见调试问题这个技能的重要性。文中介绍了多种JS的调试工具和方法，并配有GIF图演示。快GET起来吧！</p>\n</li>\n<li><p><a href=\"https://chenshenhai.github.io/koa2-note/\" target=\"_blank\" rel=\"external\">Koa2进阶学习笔记</a><br><small><em>推荐人：耿少真</em></small><br>基于async/await实现中间体系的koa2框架将会是是node.js web开发方向大势所趋的普及框架。基于generator/yield的koa1将会逐渐被koa2替代，毕竟使用co.js来处理generator是一种过渡的方式，虽然有其特定的应用场景，但是用async/await会更加优雅地实现同步写法。</p>\n</li>\n<li><p><a href=\"http://annn.me/frontend-ci-cd/\" target=\"_blank\" rel=\"external\">前端开发持续集成/持续部署(CI/CD)实例</a><br><small><em>推荐人：包京京</em></small><br>近几年，前端项目也引入了编译，构建，单元测试等现代软件工程化的标准环节。这样大提高了前端的开发效率和业务交付能力。在项目部署阶段，我们还需要引入 CI / CD 等现代化的软件开发实践，来减少风险，自动化重复操作，节省我们的时间。本文主要分享一下如何基于 gitlab 、 jenkins 让 CI/CD 跑起来。</p>\n</li>\n<li><p><a href=\"https://github.com/DDFE/DDFE-blog/issues/13\" target=\"_blank\" rel=\"external\">滴滴 webapp 5.0 Vue 2.0 重构经验分享</a><br><small><em>推荐人：张成斌</em></small><br>滴滴的 webapp 是运行在微信、支付宝、手 Q 以及其它第三方渠道的打车软件。借着产品层面的功能和视觉升级，我们用 Vue 2.0 对它进行了一次技术重构；本文即是本次重构中的经验分享。</p>\n</li>\n<li><p><a href=\"http://wxnet.me/2017/08/18/front-end-engineering-practice/\" target=\"_blank\" rel=\"external\">前端工程化实践</a><br><small><em>推荐人：王祥</em></small><br>第一篇原创文章，总结了TalkingData DTU可视化团队，在2017年上半年的实践和尝试。内容包括git工作流、代码规范和大前端的目标确定，总结过往，才能更好的迎接未来。</p>\n</li>\n</ul>\n"},{"title":"大前端周刊 第七期 （本期小编：张成斌）","date":"2017-08-04T02:32:34.000Z","_content":"## 基础\n\n* [exports、module.exports 和 export、export default 到底是咋回事](https://juejin.im/post/597ec55a51882556a234fcef)\n**模块引入方式的一个梳理**\n\n* [Node.js 实践教程](https://juejin.im/post/597ec55a51882556a234fcef)\n**饿了么出的一个Node实践教程，还在施工中，有兴趣的小伙伴可以关注一下。前提背景是[如何通过饿了么 Node.js 面试](https://github.com/ElemeFE/node-interview/tree/master/sections/zh-cn)**\n\n* [浏览器是怎么看闭包的](https://juejin.im/post/5979b5755188253df1067397)\n**换个角度来理解闭包，从内存分配与回收的角度阐述，希望能帮助大家真正消化掉所看到的闭包知识**\n\n## 文章\n* [深入理解 JavaScript 数据双向绑定](https://mp.weixin.qq.com/s?__biz=MzIyMjYyMzg3MA==&mid=2247484289&idx=2&sn=e1d9664d24d7b44bcece7464318a8369&chksm=e82be290df5c6b86f08fa80a5b33e4a3d46daa1093290610d63b47f86f5bdd7d21151b91dd8f&mpshare=1&scene=1&srcid=0804TnxBJbqO63wtfhcXPBra&pass_ticket=lctb96bPZ%2BUbaZfdgO9Bxo8p62cFUW61TN3xhm1p6zgF%2FxcmdmZtIzWeDN%2F7BnNZ#rd)\n<small>*推荐人：包京京*</small>\n首先讲解一下数据双向绑定的基本原理，介绍对比一下三大框架的不同实现方式，同时会一步步完成一个简单的mvvm示例。\n\n* [前端开发者指南（2017）](https://juejin.im/post/592faca42f301e006bc791e0)\n<small>*推荐人：郭俊兵*</small>\n内容偏向于 WEB 技术（HTML、CSS、DOM、JavaScript）和以这些技术为根基直接构建而成的开源技术。书中引用和讨论的材料要么就是同类翘楚，要么就是解决问题的流行方案。\n\n* [关于 Vue App 开发的一些思考](https://juejin.im/post/592faca42f301e006bc791e0)\n<small>*推荐人：张成斌*</small>\nTalkingData实习生写的一篇文章。作者回顾了自己经历三个项目的开发历程，发现了很多问题，也产生了很多思考。该文章有很多值得借鉴的地方。\n\n* [JavaScript专题之jQuery通用遍历方法each的实现](https://segmentfault.com/a/1190000010480396)\n<br>[系列目录地址](https://github.com/mqyqingfeng/Blog)\n<small>*推荐人：陶明*</small>\n文章从each 的功能实现入手不断完善，整体实现思路清晰，对于问题及解决也有详细的代码实现与解释。这是一个系列内容涵盖防抖、节流、去重、类型判断等。\n\n* [JavaScript 数据类型和数据结构](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures)\n<small>*推荐人：李丽娇*</small>\n作为js权威文档之一，mozilla网站除了对基础只是的介绍，还会有一些总结性的文章和使用注意事项。\n这篇文章总结性地介绍了Javascript的数据类型和数据结构，并有一些使用中的注意事项。\n\n* [函数式编程初探](http://www.ruanyifeng.com/blog/2012/04/functional_programming.html)\n<br>[函数式编程入门教程](http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html)\n<small>*推荐人：王祥*</small>\n推荐阮一峰老师的两篇函数式入门文章，大家可能无意识的使用函数式编程一段时间了。读这两篇文章，可以将思维里零散的函数式编码习惯系串联起来。\n\n* [Vue 全站服务器渲染 SSR 实践](http://gitbook.cn/m/mazi/article/5900675d2fde0e5078d4ed5e?readArticle=yes)\n<small>*推荐人：胡国伟*</small>\n掘金分享了`vue`实现SSR的实践，目前来看性能问题依然很严重，仅供大家参考。\n\n* [Vue开发常见问题集锦](http://mp.weixin.qq.com/s/fgFOvWBC_P78hG154gyXYQ)\n<small>*推荐人：王俐*</small>\n附：[换个思路理解Javascript中的this](http://mp.weixin.qq.com/s/fgFOvWBC_P78hG154gyXYQ)实际开发中会遇到的问题，主要涉及技术栈： Vue-CLI、 Element UI、 Pug(Jade)、 Less、ES6；\n1、涉及问题：ES6语法转换建议使用babel-polyfill；\n2、对于let和const的使用\n3、自定义路径别名的设置\n4、 在使用 Moment.js 遇到一些问题\n5、CSS 作用域与模块\n\n* [详解 Vue 2.4.0 带来的 4 个重大变化](https://mp.weixin.qq.com/s/qRAdgYxOfBW6xmQUdZcu_A)\n<small>*推荐人：李志伟*</small>\n“异步组件”让你的应用代码分离，使非必要组件在首页加载后延迟加载， 从而让用户更快的看到主页；组件内新增实现“属性继承”，使你的在每个中间组件属性定义变得相当简洁；异步组件支持webpack3，vue-loaderv13.0.0将.vue文件作为ES模块输出，这使得vue能够享受新的变量提升带来的便利；保留HTML注释，咳咳...聊胜于无。\n\n* [异步编程之async](https://i.jakeyu.top/2017/03/15/async/)\n<small>*推荐人：耿少真*</small>\n对async方法的深入理解。\n","source":"_posts/weekly-7.md","raw":"---\ntitle: 大前端周刊 第七期 （本期小编：张成斌）\ndate: 2017-08-04 10:32:34\ntags: [weekly,模块,node,Vue,函数式]\n---\n## 基础\n\n* [exports、module.exports 和 export、export default 到底是咋回事](https://juejin.im/post/597ec55a51882556a234fcef)\n**模块引入方式的一个梳理**\n\n* [Node.js 实践教程](https://juejin.im/post/597ec55a51882556a234fcef)\n**饿了么出的一个Node实践教程，还在施工中，有兴趣的小伙伴可以关注一下。前提背景是[如何通过饿了么 Node.js 面试](https://github.com/ElemeFE/node-interview/tree/master/sections/zh-cn)**\n\n* [浏览器是怎么看闭包的](https://juejin.im/post/5979b5755188253df1067397)\n**换个角度来理解闭包，从内存分配与回收的角度阐述，希望能帮助大家真正消化掉所看到的闭包知识**\n\n## 文章\n* [深入理解 JavaScript 数据双向绑定](https://mp.weixin.qq.com/s?__biz=MzIyMjYyMzg3MA==&mid=2247484289&idx=2&sn=e1d9664d24d7b44bcece7464318a8369&chksm=e82be290df5c6b86f08fa80a5b33e4a3d46daa1093290610d63b47f86f5bdd7d21151b91dd8f&mpshare=1&scene=1&srcid=0804TnxBJbqO63wtfhcXPBra&pass_ticket=lctb96bPZ%2BUbaZfdgO9Bxo8p62cFUW61TN3xhm1p6zgF%2FxcmdmZtIzWeDN%2F7BnNZ#rd)\n<small>*推荐人：包京京*</small>\n首先讲解一下数据双向绑定的基本原理，介绍对比一下三大框架的不同实现方式，同时会一步步完成一个简单的mvvm示例。\n\n* [前端开发者指南（2017）](https://juejin.im/post/592faca42f301e006bc791e0)\n<small>*推荐人：郭俊兵*</small>\n内容偏向于 WEB 技术（HTML、CSS、DOM、JavaScript）和以这些技术为根基直接构建而成的开源技术。书中引用和讨论的材料要么就是同类翘楚，要么就是解决问题的流行方案。\n\n* [关于 Vue App 开发的一些思考](https://juejin.im/post/592faca42f301e006bc791e0)\n<small>*推荐人：张成斌*</small>\nTalkingData实习生写的一篇文章。作者回顾了自己经历三个项目的开发历程，发现了很多问题，也产生了很多思考。该文章有很多值得借鉴的地方。\n\n* [JavaScript专题之jQuery通用遍历方法each的实现](https://segmentfault.com/a/1190000010480396)\n<br>[系列目录地址](https://github.com/mqyqingfeng/Blog)\n<small>*推荐人：陶明*</small>\n文章从each 的功能实现入手不断完善，整体实现思路清晰，对于问题及解决也有详细的代码实现与解释。这是一个系列内容涵盖防抖、节流、去重、类型判断等。\n\n* [JavaScript 数据类型和数据结构](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures)\n<small>*推荐人：李丽娇*</small>\n作为js权威文档之一，mozilla网站除了对基础只是的介绍，还会有一些总结性的文章和使用注意事项。\n这篇文章总结性地介绍了Javascript的数据类型和数据结构，并有一些使用中的注意事项。\n\n* [函数式编程初探](http://www.ruanyifeng.com/blog/2012/04/functional_programming.html)\n<br>[函数式编程入门教程](http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html)\n<small>*推荐人：王祥*</small>\n推荐阮一峰老师的两篇函数式入门文章，大家可能无意识的使用函数式编程一段时间了。读这两篇文章，可以将思维里零散的函数式编码习惯系串联起来。\n\n* [Vue 全站服务器渲染 SSR 实践](http://gitbook.cn/m/mazi/article/5900675d2fde0e5078d4ed5e?readArticle=yes)\n<small>*推荐人：胡国伟*</small>\n掘金分享了`vue`实现SSR的实践，目前来看性能问题依然很严重，仅供大家参考。\n\n* [Vue开发常见问题集锦](http://mp.weixin.qq.com/s/fgFOvWBC_P78hG154gyXYQ)\n<small>*推荐人：王俐*</small>\n附：[换个思路理解Javascript中的this](http://mp.weixin.qq.com/s/fgFOvWBC_P78hG154gyXYQ)实际开发中会遇到的问题，主要涉及技术栈： Vue-CLI、 Element UI、 Pug(Jade)、 Less、ES6；\n1、涉及问题：ES6语法转换建议使用babel-polyfill；\n2、对于let和const的使用\n3、自定义路径别名的设置\n4、 在使用 Moment.js 遇到一些问题\n5、CSS 作用域与模块\n\n* [详解 Vue 2.4.0 带来的 4 个重大变化](https://mp.weixin.qq.com/s/qRAdgYxOfBW6xmQUdZcu_A)\n<small>*推荐人：李志伟*</small>\n“异步组件”让你的应用代码分离，使非必要组件在首页加载后延迟加载， 从而让用户更快的看到主页；组件内新增实现“属性继承”，使你的在每个中间组件属性定义变得相当简洁；异步组件支持webpack3，vue-loaderv13.0.0将.vue文件作为ES模块输出，这使得vue能够享受新的变量提升带来的便利；保留HTML注释，咳咳...聊胜于无。\n\n* [异步编程之async](https://i.jakeyu.top/2017/03/15/async/)\n<small>*推荐人：耿少真*</small>\n对async方法的深入理解。\n","slug":"weekly-7","published":1,"updated":"2017-08-09T02:50:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6i92av4000be1txgy6ubl9b","content":"<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><ul>\n<li><p><a href=\"https://juejin.im/post/597ec55a51882556a234fcef\" target=\"_blank\" rel=\"external\">exports、module.exports 和 export、export default 到底是咋回事</a><br><strong>模块引入方式的一个梳理</strong></p>\n</li>\n<li><p><a href=\"https://juejin.im/post/597ec55a51882556a234fcef\" target=\"_blank\" rel=\"external\">Node.js 实践教程</a><br><strong>饿了么出的一个Node实践教程，还在施工中，有兴趣的小伙伴可以关注一下。前提背景是<a href=\"https://github.com/ElemeFE/node-interview/tree/master/sections/zh-cn\" target=\"_blank\" rel=\"external\">如何通过饿了么 Node.js 面试</a></strong></p>\n</li>\n<li><p><a href=\"https://juejin.im/post/5979b5755188253df1067397\" target=\"_blank\" rel=\"external\">浏览器是怎么看闭包的</a><br><strong>换个角度来理解闭包，从内存分配与回收的角度阐述，希望能帮助大家真正消化掉所看到的闭包知识</strong></p>\n</li>\n</ul>\n<h2 id=\"文章\"><a href=\"#文章\" class=\"headerlink\" title=\"文章\"></a>文章</h2><ul>\n<li><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzIyMjYyMzg3MA==&amp;mid=2247484289&amp;idx=2&amp;sn=e1d9664d24d7b44bcece7464318a8369&amp;chksm=e82be290df5c6b86f08fa80a5b33e4a3d46daa1093290610d63b47f86f5bdd7d21151b91dd8f&amp;mpshare=1&amp;scene=1&amp;srcid=0804TnxBJbqO63wtfhcXPBra&amp;pass_ticket=lctb96bPZ%2BUbaZfdgO9Bxo8p62cFUW61TN3xhm1p6zgF%2FxcmdmZtIzWeDN%2F7BnNZ#rd\" target=\"_blank\" rel=\"external\">深入理解 JavaScript 数据双向绑定</a><br><small><em>推荐人：包京京</em></small><br>首先讲解一下数据双向绑定的基本原理，介绍对比一下三大框架的不同实现方式，同时会一步步完成一个简单的mvvm示例。</p>\n</li>\n<li><p><a href=\"https://juejin.im/post/592faca42f301e006bc791e0\" target=\"_blank\" rel=\"external\">前端开发者指南（2017）</a><br><small><em>推荐人：郭俊兵</em></small><br>内容偏向于 WEB 技术（HTML、CSS、DOM、JavaScript）和以这些技术为根基直接构建而成的开源技术。书中引用和讨论的材料要么就是同类翘楚，要么就是解决问题的流行方案。</p>\n</li>\n<li><p><a href=\"https://juejin.im/post/592faca42f301e006bc791e0\" target=\"_blank\" rel=\"external\">关于 Vue App 开发的一些思考</a><br><small><em>推荐人：张成斌</em></small><br>TalkingData实习生写的一篇文章。作者回顾了自己经历三个项目的开发历程，发现了很多问题，也产生了很多思考。该文章有很多值得借鉴的地方。</p>\n</li>\n<li><p><a href=\"https://segmentfault.com/a/1190000010480396\" target=\"_blank\" rel=\"external\">JavaScript专题之jQuery通用遍历方法each的实现</a><br><br><a href=\"https://github.com/mqyqingfeng/Blog\" target=\"_blank\" rel=\"external\">系列目录地址</a><br><small><em>推荐人：陶明</em></small><br>文章从each 的功能实现入手不断完善，整体实现思路清晰，对于问题及解决也有详细的代码实现与解释。这是一个系列内容涵盖防抖、节流、去重、类型判断等。</p>\n</li>\n<li><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures\" target=\"_blank\" rel=\"external\">JavaScript 数据类型和数据结构</a><br><small><em>推荐人：李丽娇</em></small><br>作为js权威文档之一，mozilla网站除了对基础只是的介绍，还会有一些总结性的文章和使用注意事项。<br>这篇文章总结性地介绍了Javascript的数据类型和数据结构，并有一些使用中的注意事项。</p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2012/04/functional_programming.html\" target=\"_blank\" rel=\"external\">函数式编程初探</a><br><br><a href=\"http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html\" target=\"_blank\" rel=\"external\">函数式编程入门教程</a><br><small><em>推荐人：王祥</em></small><br>推荐阮一峰老师的两篇函数式入门文章，大家可能无意识的使用函数式编程一段时间了。读这两篇文章，可以将思维里零散的函数式编码习惯系串联起来。</p>\n</li>\n<li><p><a href=\"http://gitbook.cn/m/mazi/article/5900675d2fde0e5078d4ed5e?readArticle=yes\" target=\"_blank\" rel=\"external\">Vue 全站服务器渲染 SSR 实践</a><br><small><em>推荐人：胡国伟</em></small><br>掘金分享了<code>vue</code>实现SSR的实践，目前来看性能问题依然很严重，仅供大家参考。</p>\n</li>\n<li><p><a href=\"http://mp.weixin.qq.com/s/fgFOvWBC_P78hG154gyXYQ\" target=\"_blank\" rel=\"external\">Vue开发常见问题集锦</a><br><small><em>推荐人：王俐</em></small><br>附：<a href=\"http://mp.weixin.qq.com/s/fgFOvWBC_P78hG154gyXYQ\" target=\"_blank\" rel=\"external\">换个思路理解Javascript中的this</a>实际开发中会遇到的问题，主要涉及技术栈： Vue-CLI、 Element UI、 Pug(Jade)、 Less、ES6；<br>1、涉及问题：ES6语法转换建议使用babel-polyfill；<br>2、对于let和const的使用<br>3、自定义路径别名的设置<br>4、 在使用 Moment.js 遇到一些问题<br>5、CSS 作用域与模块</p>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s/qRAdgYxOfBW6xmQUdZcu_A\" target=\"_blank\" rel=\"external\">详解 Vue 2.4.0 带来的 4 个重大变化</a><br><small><em>推荐人：李志伟</em></small><br>“异步组件”让你的应用代码分离，使非必要组件在首页加载后延迟加载， 从而让用户更快的看到主页；组件内新增实现“属性继承”，使你的在每个中间组件属性定义变得相当简洁；异步组件支持webpack3，vue-loaderv13.0.0将.vue文件作为ES模块输出，这使得vue能够享受新的变量提升带来的便利；保留HTML注释，咳咳…聊胜于无。</p>\n</li>\n<li><p><a href=\"https://i.jakeyu.top/2017/03/15/async/\" target=\"_blank\" rel=\"external\">异步编程之async</a><br><small><em>推荐人：耿少真</em></small><br>对async方法的深入理解。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><ul>\n<li><p><a href=\"https://juejin.im/post/597ec55a51882556a234fcef\" target=\"_blank\" rel=\"external\">exports、module.exports 和 export、export default 到底是咋回事</a><br><strong>模块引入方式的一个梳理</strong></p>\n</li>\n<li><p><a href=\"https://juejin.im/post/597ec55a51882556a234fcef\" target=\"_blank\" rel=\"external\">Node.js 实践教程</a><br><strong>饿了么出的一个Node实践教程，还在施工中，有兴趣的小伙伴可以关注一下。前提背景是<a href=\"https://github.com/ElemeFE/node-interview/tree/master/sections/zh-cn\" target=\"_blank\" rel=\"external\">如何通过饿了么 Node.js 面试</a></strong></p>\n</li>\n<li><p><a href=\"https://juejin.im/post/5979b5755188253df1067397\" target=\"_blank\" rel=\"external\">浏览器是怎么看闭包的</a><br><strong>换个角度来理解闭包，从内存分配与回收的角度阐述，希望能帮助大家真正消化掉所看到的闭包知识</strong></p>\n</li>\n</ul>\n<h2 id=\"文章\"><a href=\"#文章\" class=\"headerlink\" title=\"文章\"></a>文章</h2><ul>\n<li><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzIyMjYyMzg3MA==&amp;mid=2247484289&amp;idx=2&amp;sn=e1d9664d24d7b44bcece7464318a8369&amp;chksm=e82be290df5c6b86f08fa80a5b33e4a3d46daa1093290610d63b47f86f5bdd7d21151b91dd8f&amp;mpshare=1&amp;scene=1&amp;srcid=0804TnxBJbqO63wtfhcXPBra&amp;pass_ticket=lctb96bPZ%2BUbaZfdgO9Bxo8p62cFUW61TN3xhm1p6zgF%2FxcmdmZtIzWeDN%2F7BnNZ#rd\" target=\"_blank\" rel=\"external\">深入理解 JavaScript 数据双向绑定</a><br><small><em>推荐人：包京京</em></small><br>首先讲解一下数据双向绑定的基本原理，介绍对比一下三大框架的不同实现方式，同时会一步步完成一个简单的mvvm示例。</p>\n</li>\n<li><p><a href=\"https://juejin.im/post/592faca42f301e006bc791e0\" target=\"_blank\" rel=\"external\">前端开发者指南（2017）</a><br><small><em>推荐人：郭俊兵</em></small><br>内容偏向于 WEB 技术（HTML、CSS、DOM、JavaScript）和以这些技术为根基直接构建而成的开源技术。书中引用和讨论的材料要么就是同类翘楚，要么就是解决问题的流行方案。</p>\n</li>\n<li><p><a href=\"https://juejin.im/post/592faca42f301e006bc791e0\" target=\"_blank\" rel=\"external\">关于 Vue App 开发的一些思考</a><br><small><em>推荐人：张成斌</em></small><br>TalkingData实习生写的一篇文章。作者回顾了自己经历三个项目的开发历程，发现了很多问题，也产生了很多思考。该文章有很多值得借鉴的地方。</p>\n</li>\n<li><p><a href=\"https://segmentfault.com/a/1190000010480396\" target=\"_blank\" rel=\"external\">JavaScript专题之jQuery通用遍历方法each的实现</a><br><br><a href=\"https://github.com/mqyqingfeng/Blog\" target=\"_blank\" rel=\"external\">系列目录地址</a><br><small><em>推荐人：陶明</em></small><br>文章从each 的功能实现入手不断完善，整体实现思路清晰，对于问题及解决也有详细的代码实现与解释。这是一个系列内容涵盖防抖、节流、去重、类型判断等。</p>\n</li>\n<li><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures\" target=\"_blank\" rel=\"external\">JavaScript 数据类型和数据结构</a><br><small><em>推荐人：李丽娇</em></small><br>作为js权威文档之一，mozilla网站除了对基础只是的介绍，还会有一些总结性的文章和使用注意事项。<br>这篇文章总结性地介绍了Javascript的数据类型和数据结构，并有一些使用中的注意事项。</p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2012/04/functional_programming.html\" target=\"_blank\" rel=\"external\">函数式编程初探</a><br><br><a href=\"http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html\" target=\"_blank\" rel=\"external\">函数式编程入门教程</a><br><small><em>推荐人：王祥</em></small><br>推荐阮一峰老师的两篇函数式入门文章，大家可能无意识的使用函数式编程一段时间了。读这两篇文章，可以将思维里零散的函数式编码习惯系串联起来。</p>\n</li>\n<li><p><a href=\"http://gitbook.cn/m/mazi/article/5900675d2fde0e5078d4ed5e?readArticle=yes\" target=\"_blank\" rel=\"external\">Vue 全站服务器渲染 SSR 实践</a><br><small><em>推荐人：胡国伟</em></small><br>掘金分享了<code>vue</code>实现SSR的实践，目前来看性能问题依然很严重，仅供大家参考。</p>\n</li>\n<li><p><a href=\"http://mp.weixin.qq.com/s/fgFOvWBC_P78hG154gyXYQ\" target=\"_blank\" rel=\"external\">Vue开发常见问题集锦</a><br><small><em>推荐人：王俐</em></small><br>附：<a href=\"http://mp.weixin.qq.com/s/fgFOvWBC_P78hG154gyXYQ\" target=\"_blank\" rel=\"external\">换个思路理解Javascript中的this</a>实际开发中会遇到的问题，主要涉及技术栈： Vue-CLI、 Element UI、 Pug(Jade)、 Less、ES6；<br>1、涉及问题：ES6语法转换建议使用babel-polyfill；<br>2、对于let和const的使用<br>3、自定义路径别名的设置<br>4、 在使用 Moment.js 遇到一些问题<br>5、CSS 作用域与模块</p>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s/qRAdgYxOfBW6xmQUdZcu_A\" target=\"_blank\" rel=\"external\">详解 Vue 2.4.0 带来的 4 个重大变化</a><br><small><em>推荐人：李志伟</em></small><br>“异步组件”让你的应用代码分离，使非必要组件在首页加载后延迟加载， 从而让用户更快的看到主页；组件内新增实现“属性继承”，使你的在每个中间组件属性定义变得相当简洁；异步组件支持webpack3，vue-loaderv13.0.0将.vue文件作为ES模块输出，这使得vue能够享受新的变量提升带来的便利；保留HTML注释，咳咳…聊胜于无。</p>\n</li>\n<li><p><a href=\"https://i.jakeyu.top/2017/03/15/async/\" target=\"_blank\" rel=\"external\">异步编程之async</a><br><small><em>推荐人：耿少真</em></small><br>对async方法的深入理解。</p>\n</li>\n</ul>\n"},{"title":"大前端周刊 第八期 （本期小编：耿少真）","date":"2017-08-11T06:57:34.000Z","_content":"## 基础\n\n* [掌握Chrome开发工具](http://www.zcfy.cc/article/mastering-chrome-developer-tools-next-level-front-end-development-techniques-3722.html?t=selection)\n**熟悉Chrome开发工具的基本功能: DOM检查器、样式面板和JavaScript控制台和一些不太为人所知的特性**\n\n* [JS函数式编程指南](https://www.gitbook.com/book/llh911001/mostly-adequate-guide-chinese/details)\n**对函数式编程的目的有一个初步认识，对一个程序之所以是函数式程序的原因有一定了解**\n\n* [HTTP协议详解](https://mp.weixin.qq.com/s/27zpNIGhVbx-on9FDs_6dw)\n**Web服务器是基于HTTP（HyperText Transfer Protocol）协议实现的，所以要实现一个Web服务器就必须了解HTTP协议，本章主要介绍HTTP协议的相关知识，让我们对HTTP协议有个理性的认识。**\n\n## 资源整理\n* [编程书单](http://blog.didiaoyuan.com/2017/04/18/%E6%80%BB%E6%9C%89%E4%BD%A0%E8%A6%81%E7%9A%84%E7%BC%96%E7%A8%8B%E4%B9%A6%E5%8D%95%EF%BC%88GitHub-%EF%BC%89/)\n**一些 GitHub 上不错的文章或电子书列表与大家分享。不乏有不少经典，可以收起来慢慢阅览。**\n\n* [Web前端导航网站](http://www.alloyteam.com/nav/)\n**收录了前端开发需要的大部分网站，可以快速找到自己需要的网站**\n\n## 文章\n* [彻底弄懂CommonJS和AMD/CMD](http://www.cnblogs.com/chenguangliang/p/5856701.html)\n<small>*推荐人：李丽娇*</small>\n经常说的CommonJS、AMD、CMD规范具体指什么？实现原理是什么？这些规范有哪些具体实现？来看这篇文章找答案。\n\n* [使用Node.js实现文件流转存服务](https://zhuanlan.zhihu.com/p/25367269)\n<small>*推荐人：李志伟*</small>\n文章介绍了基于node实现分片上传大型文件，通过灵活使用Promise和递归，实现非异步模型看起来很复杂的事情。另外文章附有较为完整的单元测试，覆盖分片的缓存与切割、上传前后的md5值。\n\n* [API设计原则](http://coolshell.cn/articles/18024.html)\n<small>*推荐人：胡国伟*</small>\n我们平时在编写组件或者后端接口的时候都避免不了API 设计，你的API越容易使用，那么就会有越多的人去用它。那么问题来了，怎样才能设计出优秀的 API ？本文是虽然是以`C++`为例， 其中设计原则和思考是具有普适性的，是关于API设计一篇难得的好文章\n\n* [一道JS面试题所引发的\"血案\"，透过现象寻本质，再从本质看现象](https://github.com/jawil/blog/issues/3)\n<small>*推荐人：张成斌*</small>\n对this、执行环境、作用域等概念进行了系统的讲解。加深对于这些易混淆概念的理解。\n\n* [karma+webpack搭建vue单元测试环境](http://www.jianshu.com/p/a515fbbdd1b2)\n<small>*推荐人：耿少真*</small>\nkarma+webpack搭建vue单元测试环境介绍了vue单元测试环境搭建及查看源文件的测试覆盖覆盖率。\n[Vue单元测试case写法](http://www.jianshu.com/p/45e8c2b26309)\n测试环境搭建完成后，在此基础上vue单元测试思路介绍和case的写法。测试框架使用jasmine。\n\n* [【源码拾遗】axios —— 极简封装的艺术](https://zhuanlan.zhihu.com/p/28396592)\n<small>*推荐人：陶明*</small>\n本文通过axios 功能的使用及源码分析详细说明了axios 对于功能的实现。\naxios是基于Promise的方式封装，所以分析axios源码也是对Promise的深入学习。\n\n* [Intro to Frontend Ops](https://rupl.github.io/frontend-ops/#/)\n<small>*推荐人：包京京*</small>\nFrontend Ops是这篇文章作者自己定义的一个概念，业界应该还没有统一这种叫法，不过文章作者的意思是，随着前端项目复杂程度的增加，需要类似于DevOps的工程化能力，来进行持续发布、自动化测试等等流程（本文是英文的材料，暂无译文）。\n\n* [Koa 框架教程](http://www.ruanyifeng.com/blog/2017/08/koa.html)\n<small>*推荐人：王祥*</small>\n本文从零开始，循序渐进，教会你如何使用 Koa 写出自己的 Web 应用。每一步都有简洁易懂的示例，希望让大家一看就懂。\n\n* [一行 JavaScript 代码的逆向工程](https://juejin.im/post/5988411251882526185d634a)\n<small>*推荐人：郭俊兵*</small>\n这一行代码会被渲染成一个矩阵效果，通过一次代码解读，享受理解它的过程。\n`<pre id=p><script>n=setInterval(\"for(n+=7,i=k,P='p.\\\\n';i-=1/k;P+=P[i%2?(i%2*j-j+n/k^j)&1:2])j=k/i;p.innerHTML=P\",k=64)</script>`\n\n","source":"_posts/weekly-8.md","raw":"---\ntitle: 大前端周刊 第八期 （本期小编：耿少真）\ndate: 2017-08-11 14:57:34\ntags: [weekly,模块,node,Vue,API设计，单元测试]\n---\n## 基础\n\n* [掌握Chrome开发工具](http://www.zcfy.cc/article/mastering-chrome-developer-tools-next-level-front-end-development-techniques-3722.html?t=selection)\n**熟悉Chrome开发工具的基本功能: DOM检查器、样式面板和JavaScript控制台和一些不太为人所知的特性**\n\n* [JS函数式编程指南](https://www.gitbook.com/book/llh911001/mostly-adequate-guide-chinese/details)\n**对函数式编程的目的有一个初步认识，对一个程序之所以是函数式程序的原因有一定了解**\n\n* [HTTP协议详解](https://mp.weixin.qq.com/s/27zpNIGhVbx-on9FDs_6dw)\n**Web服务器是基于HTTP（HyperText Transfer Protocol）协议实现的，所以要实现一个Web服务器就必须了解HTTP协议，本章主要介绍HTTP协议的相关知识，让我们对HTTP协议有个理性的认识。**\n\n## 资源整理\n* [编程书单](http://blog.didiaoyuan.com/2017/04/18/%E6%80%BB%E6%9C%89%E4%BD%A0%E8%A6%81%E7%9A%84%E7%BC%96%E7%A8%8B%E4%B9%A6%E5%8D%95%EF%BC%88GitHub-%EF%BC%89/)\n**一些 GitHub 上不错的文章或电子书列表与大家分享。不乏有不少经典，可以收起来慢慢阅览。**\n\n* [Web前端导航网站](http://www.alloyteam.com/nav/)\n**收录了前端开发需要的大部分网站，可以快速找到自己需要的网站**\n\n## 文章\n* [彻底弄懂CommonJS和AMD/CMD](http://www.cnblogs.com/chenguangliang/p/5856701.html)\n<small>*推荐人：李丽娇*</small>\n经常说的CommonJS、AMD、CMD规范具体指什么？实现原理是什么？这些规范有哪些具体实现？来看这篇文章找答案。\n\n* [使用Node.js实现文件流转存服务](https://zhuanlan.zhihu.com/p/25367269)\n<small>*推荐人：李志伟*</small>\n文章介绍了基于node实现分片上传大型文件，通过灵活使用Promise和递归，实现非异步模型看起来很复杂的事情。另外文章附有较为完整的单元测试，覆盖分片的缓存与切割、上传前后的md5值。\n\n* [API设计原则](http://coolshell.cn/articles/18024.html)\n<small>*推荐人：胡国伟*</small>\n我们平时在编写组件或者后端接口的时候都避免不了API 设计，你的API越容易使用，那么就会有越多的人去用它。那么问题来了，怎样才能设计出优秀的 API ？本文是虽然是以`C++`为例， 其中设计原则和思考是具有普适性的，是关于API设计一篇难得的好文章\n\n* [一道JS面试题所引发的\"血案\"，透过现象寻本质，再从本质看现象](https://github.com/jawil/blog/issues/3)\n<small>*推荐人：张成斌*</small>\n对this、执行环境、作用域等概念进行了系统的讲解。加深对于这些易混淆概念的理解。\n\n* [karma+webpack搭建vue单元测试环境](http://www.jianshu.com/p/a515fbbdd1b2)\n<small>*推荐人：耿少真*</small>\nkarma+webpack搭建vue单元测试环境介绍了vue单元测试环境搭建及查看源文件的测试覆盖覆盖率。\n[Vue单元测试case写法](http://www.jianshu.com/p/45e8c2b26309)\n测试环境搭建完成后，在此基础上vue单元测试思路介绍和case的写法。测试框架使用jasmine。\n\n* [【源码拾遗】axios —— 极简封装的艺术](https://zhuanlan.zhihu.com/p/28396592)\n<small>*推荐人：陶明*</small>\n本文通过axios 功能的使用及源码分析详细说明了axios 对于功能的实现。\naxios是基于Promise的方式封装，所以分析axios源码也是对Promise的深入学习。\n\n* [Intro to Frontend Ops](https://rupl.github.io/frontend-ops/#/)\n<small>*推荐人：包京京*</small>\nFrontend Ops是这篇文章作者自己定义的一个概念，业界应该还没有统一这种叫法，不过文章作者的意思是，随着前端项目复杂程度的增加，需要类似于DevOps的工程化能力，来进行持续发布、自动化测试等等流程（本文是英文的材料，暂无译文）。\n\n* [Koa 框架教程](http://www.ruanyifeng.com/blog/2017/08/koa.html)\n<small>*推荐人：王祥*</small>\n本文从零开始，循序渐进，教会你如何使用 Koa 写出自己的 Web 应用。每一步都有简洁易懂的示例，希望让大家一看就懂。\n\n* [一行 JavaScript 代码的逆向工程](https://juejin.im/post/5988411251882526185d634a)\n<small>*推荐人：郭俊兵*</small>\n这一行代码会被渲染成一个矩阵效果，通过一次代码解读，享受理解它的过程。\n`<pre id=p><script>n=setInterval(\"for(n+=7,i=k,P='p.\\\\n';i-=1/k;P+=P[i%2?(i%2*j-j+n/k^j)&1:2])j=k/i;p.innerHTML=P\",k=64)</script>`\n\n","slug":"weekly-8","published":1,"updated":"2017-08-18T19:09:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6i92av5000de1tx3e8cw0g3","content":"<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><ul>\n<li><p><a href=\"http://www.zcfy.cc/article/mastering-chrome-developer-tools-next-level-front-end-development-techniques-3722.html?t=selection\" target=\"_blank\" rel=\"external\">掌握Chrome开发工具</a><br><strong>熟悉Chrome开发工具的基本功能: DOM检查器、样式面板和JavaScript控制台和一些不太为人所知的特性</strong></p>\n</li>\n<li><p><a href=\"https://www.gitbook.com/book/llh911001/mostly-adequate-guide-chinese/details\" target=\"_blank\" rel=\"external\">JS函数式编程指南</a><br><strong>对函数式编程的目的有一个初步认识，对一个程序之所以是函数式程序的原因有一定了解</strong></p>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s/27zpNIGhVbx-on9FDs_6dw\" target=\"_blank\" rel=\"external\">HTTP协议详解</a><br><strong>Web服务器是基于HTTP（HyperText Transfer Protocol）协议实现的，所以要实现一个Web服务器就必须了解HTTP协议，本章主要介绍HTTP协议的相关知识，让我们对HTTP协议有个理性的认识。</strong></p>\n</li>\n</ul>\n<h2 id=\"资源整理\"><a href=\"#资源整理\" class=\"headerlink\" title=\"资源整理\"></a>资源整理</h2><ul>\n<li><p><a href=\"http://blog.didiaoyuan.com/2017/04/18/%E6%80%BB%E6%9C%89%E4%BD%A0%E8%A6%81%E7%9A%84%E7%BC%96%E7%A8%8B%E4%B9%A6%E5%8D%95%EF%BC%88GitHub-%EF%BC%89/\" target=\"_blank\" rel=\"external\">编程书单</a><br><strong>一些 GitHub 上不错的文章或电子书列表与大家分享。不乏有不少经典，可以收起来慢慢阅览。</strong></p>\n</li>\n<li><p><a href=\"http://www.alloyteam.com/nav/\" target=\"_blank\" rel=\"external\">Web前端导航网站</a><br><strong>收录了前端开发需要的大部分网站，可以快速找到自己需要的网站</strong></p>\n</li>\n</ul>\n<h2 id=\"文章\"><a href=\"#文章\" class=\"headerlink\" title=\"文章\"></a>文章</h2><ul>\n<li><p><a href=\"http://www.cnblogs.com/chenguangliang/p/5856701.html\" target=\"_blank\" rel=\"external\">彻底弄懂CommonJS和AMD/CMD</a><br><small><em>推荐人：李丽娇</em></small><br>经常说的CommonJS、AMD、CMD规范具体指什么？实现原理是什么？这些规范有哪些具体实现？来看这篇文章找答案。</p>\n</li>\n<li><p><a href=\"https://zhuanlan.zhihu.com/p/25367269\" target=\"_blank\" rel=\"external\">使用Node.js实现文件流转存服务</a><br><small><em>推荐人：李志伟</em></small><br>文章介绍了基于node实现分片上传大型文件，通过灵活使用Promise和递归，实现非异步模型看起来很复杂的事情。另外文章附有较为完整的单元测试，覆盖分片的缓存与切割、上传前后的md5值。</p>\n</li>\n<li><p><a href=\"http://coolshell.cn/articles/18024.html\" target=\"_blank\" rel=\"external\">API设计原则</a><br><small><em>推荐人：胡国伟</em></small><br>我们平时在编写组件或者后端接口的时候都避免不了API 设计，你的API越容易使用，那么就会有越多的人去用它。那么问题来了，怎样才能设计出优秀的 API ？本文是虽然是以<code>C++</code>为例， 其中设计原则和思考是具有普适性的，是关于API设计一篇难得的好文章</p>\n</li>\n<li><p><a href=\"https://github.com/jawil/blog/issues/3\" target=\"_blank\" rel=\"external\">一道JS面试题所引发的”血案”，透过现象寻本质，再从本质看现象</a><br><small><em>推荐人：张成斌</em></small><br>对this、执行环境、作用域等概念进行了系统的讲解。加深对于这些易混淆概念的理解。</p>\n</li>\n<li><p><a href=\"http://www.jianshu.com/p/a515fbbdd1b2\" target=\"_blank\" rel=\"external\">karma+webpack搭建vue单元测试环境</a><br><small><em>推荐人：耿少真</em></small><br>karma+webpack搭建vue单元测试环境介绍了vue单元测试环境搭建及查看源文件的测试覆盖覆盖率。<br><a href=\"http://www.jianshu.com/p/45e8c2b26309\" target=\"_blank\" rel=\"external\">Vue单元测试case写法</a><br>测试环境搭建完成后，在此基础上vue单元测试思路介绍和case的写法。测试框架使用jasmine。</p>\n</li>\n<li><p><a href=\"https://zhuanlan.zhihu.com/p/28396592\" target=\"_blank\" rel=\"external\">【源码拾遗】axios —— 极简封装的艺术</a><br><small><em>推荐人：陶明</em></small><br>本文通过axios 功能的使用及源码分析详细说明了axios 对于功能的实现。<br>axios是基于Promise的方式封装，所以分析axios源码也是对Promise的深入学习。</p>\n</li>\n<li><p><a href=\"https://rupl.github.io/frontend-ops/#/\" target=\"_blank\" rel=\"external\">Intro to Frontend Ops</a><br><small><em>推荐人：包京京</em></small><br>Frontend Ops是这篇文章作者自己定义的一个概念，业界应该还没有统一这种叫法，不过文章作者的意思是，随着前端项目复杂程度的增加，需要类似于DevOps的工程化能力，来进行持续发布、自动化测试等等流程（本文是英文的材料，暂无译文）。</p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2017/08/koa.html\" target=\"_blank\" rel=\"external\">Koa 框架教程</a><br><small><em>推荐人：王祥</em></small><br>本文从零开始，循序渐进，教会你如何使用 Koa 写出自己的 Web 应用。每一步都有简洁易懂的示例，希望让大家一看就懂。</p>\n</li>\n<li><p><a href=\"https://juejin.im/post/5988411251882526185d634a\" target=\"_blank\" rel=\"external\">一行 JavaScript 代码的逆向工程</a><br><small><em>推荐人：郭俊兵</em></small><br>这一行代码会被渲染成一个矩阵效果，通过一次代码解读，享受理解它的过程。<br><code>&lt;pre id=p&gt;&lt;script&gt;n=setInterval(&quot;for(n+=7,i=k,P=&#39;p.\\\\n&#39;;i-=1/k;P+=P[i%2?(i%2*j-j+n/k^j)&amp;1:2])j=k/i;p.innerHTML=P&quot;,k=64)&lt;/script&gt;</code></p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><ul>\n<li><p><a href=\"http://www.zcfy.cc/article/mastering-chrome-developer-tools-next-level-front-end-development-techniques-3722.html?t=selection\" target=\"_blank\" rel=\"external\">掌握Chrome开发工具</a><br><strong>熟悉Chrome开发工具的基本功能: DOM检查器、样式面板和JavaScript控制台和一些不太为人所知的特性</strong></p>\n</li>\n<li><p><a href=\"https://www.gitbook.com/book/llh911001/mostly-adequate-guide-chinese/details\" target=\"_blank\" rel=\"external\">JS函数式编程指南</a><br><strong>对函数式编程的目的有一个初步认识，对一个程序之所以是函数式程序的原因有一定了解</strong></p>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s/27zpNIGhVbx-on9FDs_6dw\" target=\"_blank\" rel=\"external\">HTTP协议详解</a><br><strong>Web服务器是基于HTTP（HyperText Transfer Protocol）协议实现的，所以要实现一个Web服务器就必须了解HTTP协议，本章主要介绍HTTP协议的相关知识，让我们对HTTP协议有个理性的认识。</strong></p>\n</li>\n</ul>\n<h2 id=\"资源整理\"><a href=\"#资源整理\" class=\"headerlink\" title=\"资源整理\"></a>资源整理</h2><ul>\n<li><p><a href=\"http://blog.didiaoyuan.com/2017/04/18/%E6%80%BB%E6%9C%89%E4%BD%A0%E8%A6%81%E7%9A%84%E7%BC%96%E7%A8%8B%E4%B9%A6%E5%8D%95%EF%BC%88GitHub-%EF%BC%89/\" target=\"_blank\" rel=\"external\">编程书单</a><br><strong>一些 GitHub 上不错的文章或电子书列表与大家分享。不乏有不少经典，可以收起来慢慢阅览。</strong></p>\n</li>\n<li><p><a href=\"http://www.alloyteam.com/nav/\" target=\"_blank\" rel=\"external\">Web前端导航网站</a><br><strong>收录了前端开发需要的大部分网站，可以快速找到自己需要的网站</strong></p>\n</li>\n</ul>\n<h2 id=\"文章\"><a href=\"#文章\" class=\"headerlink\" title=\"文章\"></a>文章</h2><ul>\n<li><p><a href=\"http://www.cnblogs.com/chenguangliang/p/5856701.html\" target=\"_blank\" rel=\"external\">彻底弄懂CommonJS和AMD/CMD</a><br><small><em>推荐人：李丽娇</em></small><br>经常说的CommonJS、AMD、CMD规范具体指什么？实现原理是什么？这些规范有哪些具体实现？来看这篇文章找答案。</p>\n</li>\n<li><p><a href=\"https://zhuanlan.zhihu.com/p/25367269\" target=\"_blank\" rel=\"external\">使用Node.js实现文件流转存服务</a><br><small><em>推荐人：李志伟</em></small><br>文章介绍了基于node实现分片上传大型文件，通过灵活使用Promise和递归，实现非异步模型看起来很复杂的事情。另外文章附有较为完整的单元测试，覆盖分片的缓存与切割、上传前后的md5值。</p>\n</li>\n<li><p><a href=\"http://coolshell.cn/articles/18024.html\" target=\"_blank\" rel=\"external\">API设计原则</a><br><small><em>推荐人：胡国伟</em></small><br>我们平时在编写组件或者后端接口的时候都避免不了API 设计，你的API越容易使用，那么就会有越多的人去用它。那么问题来了，怎样才能设计出优秀的 API ？本文是虽然是以<code>C++</code>为例， 其中设计原则和思考是具有普适性的，是关于API设计一篇难得的好文章</p>\n</li>\n<li><p><a href=\"https://github.com/jawil/blog/issues/3\" target=\"_blank\" rel=\"external\">一道JS面试题所引发的”血案”，透过现象寻本质，再从本质看现象</a><br><small><em>推荐人：张成斌</em></small><br>对this、执行环境、作用域等概念进行了系统的讲解。加深对于这些易混淆概念的理解。</p>\n</li>\n<li><p><a href=\"http://www.jianshu.com/p/a515fbbdd1b2\" target=\"_blank\" rel=\"external\">karma+webpack搭建vue单元测试环境</a><br><small><em>推荐人：耿少真</em></small><br>karma+webpack搭建vue单元测试环境介绍了vue单元测试环境搭建及查看源文件的测试覆盖覆盖率。<br><a href=\"http://www.jianshu.com/p/45e8c2b26309\" target=\"_blank\" rel=\"external\">Vue单元测试case写法</a><br>测试环境搭建完成后，在此基础上vue单元测试思路介绍和case的写法。测试框架使用jasmine。</p>\n</li>\n<li><p><a href=\"https://zhuanlan.zhihu.com/p/28396592\" target=\"_blank\" rel=\"external\">【源码拾遗】axios —— 极简封装的艺术</a><br><small><em>推荐人：陶明</em></small><br>本文通过axios 功能的使用及源码分析详细说明了axios 对于功能的实现。<br>axios是基于Promise的方式封装，所以分析axios源码也是对Promise的深入学习。</p>\n</li>\n<li><p><a href=\"https://rupl.github.io/frontend-ops/#/\" target=\"_blank\" rel=\"external\">Intro to Frontend Ops</a><br><small><em>推荐人：包京京</em></small><br>Frontend Ops是这篇文章作者自己定义的一个概念，业界应该还没有统一这种叫法，不过文章作者的意思是，随着前端项目复杂程度的增加，需要类似于DevOps的工程化能力，来进行持续发布、自动化测试等等流程（本文是英文的材料，暂无译文）。</p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2017/08/koa.html\" target=\"_blank\" rel=\"external\">Koa 框架教程</a><br><small><em>推荐人：王祥</em></small><br>本文从零开始，循序渐进，教会你如何使用 Koa 写出自己的 Web 应用。每一步都有简洁易懂的示例，希望让大家一看就懂。</p>\n</li>\n<li><p><a href=\"https://juejin.im/post/5988411251882526185d634a\" target=\"_blank\" rel=\"external\">一行 JavaScript 代码的逆向工程</a><br><small><em>推荐人：郭俊兵</em></small><br>这一行代码会被渲染成一个矩阵效果，通过一次代码解读，享受理解它的过程。<br><code>&lt;pre id=p&gt;&lt;script&gt;n=setInterval(&quot;for(n+=7,i=k,P=&#39;p.\\\\n&#39;;i-=1/k;P+=P[i%2?(i%2*j-j+n/k^j)&amp;1:2])j=k/i;p.innerHTML=P&quot;,k=64)&lt;/script&gt;</code></p>\n</li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cj6i92auf0000e1txl53kbr1t","tag_id":"cj6i92aum0002e1txcprsd5ky","_id":"cj6i92ava000he1txovy0g5hc"},{"post_id":"cj6i92auf0000e1txl53kbr1t","tag_id":"cj6i92auw0006e1txl1041d3y","_id":"cj6i92avb000ie1txiv0n4s9w"},{"post_id":"cj6i92auf0000e1txl53kbr1t","tag_id":"cj6i92av10009e1tx2h6ryd54","_id":"cj6i92avb000ke1tximw04b5k"},{"post_id":"cj6i92auf0000e1txl53kbr1t","tag_id":"cj6i92av5000ce1txcy3srjrt","_id":"cj6i92avb000le1txhuts3y0l"},{"post_id":"cj6i92auf0000e1txl53kbr1t","tag_id":"cj6i92av7000ee1txdszv1th3","_id":"cj6i92avc000ne1txijfd0jj2"},{"post_id":"cj6i92auf0000e1txl53kbr1t","tag_id":"cj6i92av8000fe1txn5n7zuma","_id":"cj6i92avc000oe1txm9dcipsh"},{"post_id":"cj6i92auj0001e1txd0yb60zr","tag_id":"cj6i92aum0002e1txcprsd5ky","_id":"cj6i92ave000se1tx46gpvpgm"},{"post_id":"cj6i92auj0001e1txd0yb60zr","tag_id":"cj6i92avb000je1tx3b6r44uk","_id":"cj6i92ave000te1tx8ngxme1p"},{"post_id":"cj6i92auj0001e1txd0yb60zr","tag_id":"cj6i92avb000me1txwwkgwyjv","_id":"cj6i92ave000ve1txvc5cspar"},{"post_id":"cj6i92auj0001e1txd0yb60zr","tag_id":"cj6i92avc000pe1txft9sd1yx","_id":"cj6i92avf000we1txatwpbq8p"},{"post_id":"cj6i92auj0001e1txd0yb60zr","tag_id":"cj6i92avd000qe1txddspzj0e","_id":"cj6i92avf000ye1txxzdpr4ui"},{"post_id":"cj6i92aup0003e1txp8kbumsh","tag_id":"cj6i92aum0002e1txcprsd5ky","_id":"cj6i92avg0010e1txc9k1e1r0"},{"post_id":"cj6i92aup0003e1txp8kbumsh","tag_id":"cj6i92ave000ue1txwsigvb28","_id":"cj6i92avg0011e1tx3crzl7xn"},{"post_id":"cj6i92aup0003e1txp8kbumsh","tag_id":"cj6i92avf000xe1tx1nbu3dr8","_id":"cj6i92avg0013e1txzndddt7t"},{"post_id":"cj6i92aur0004e1txbfmr1c3a","tag_id":"cj6i92aum0002e1txcprsd5ky","_id":"cj6i92avi001ae1txzylkmnmd"},{"post_id":"cj6i92aur0004e1txbfmr1c3a","tag_id":"cj6i92avf000ze1txuei4381s","_id":"cj6i92avi001be1tx5p8ous5n"},{"post_id":"cj6i92aur0004e1txbfmr1c3a","tag_id":"cj6i92avg0012e1txdn46d685","_id":"cj6i92avj001de1tx1hrqbx0l"},{"post_id":"cj6i92aur0004e1txbfmr1c3a","tag_id":"cj6i92avg0014e1txfomb2rnd","_id":"cj6i92avj001ee1tx3psrlfja"},{"post_id":"cj6i92aur0004e1txbfmr1c3a","tag_id":"cj6i92avh0015e1txuth1rp6q","_id":"cj6i92avk001ge1tx0lwe0zvx"},{"post_id":"cj6i92aur0004e1txbfmr1c3a","tag_id":"cj6i92av5000ce1txcy3srjrt","_id":"cj6i92avk001he1txrssmfh0l"},{"post_id":"cj6i92aur0004e1txbfmr1c3a","tag_id":"cj6i92avh0017e1txmidzviyr","_id":"cj6i92avk001je1txd6az4nky"},{"post_id":"cj6i92aur0004e1txbfmr1c3a","tag_id":"cj6i92avi0018e1txb170vdpo","_id":"cj6i92avk001ke1tx4ravs2px"},{"post_id":"cj6i92auu0005e1txpht8yzzn","tag_id":"cj6i92avi0019e1tx2swr3jed","_id":"cj6i92avl001me1txav5nduaq"},{"post_id":"cj6i92auu0005e1txpht8yzzn","tag_id":"cj6i92ave000ue1txwsigvb28","_id":"cj6i92avl001ne1tx0br4wugy"},{"post_id":"cj6i92auu0005e1txpht8yzzn","tag_id":"cj6i92avf000xe1tx1nbu3dr8","_id":"cj6i92avl001pe1txliknepe3"},{"post_id":"cj6i92aux0007e1txvvdal8n1","tag_id":"cj6i92aum0002e1txcprsd5ky","_id":"cj6i92avq001ve1txoyjd2s3t"},{"post_id":"cj6i92aux0007e1txvvdal8n1","tag_id":"cj6i92avk001ie1txr1zo9fc7","_id":"cj6i92avq001we1txk2y5l1cd"},{"post_id":"cj6i92aux0007e1txvvdal8n1","tag_id":"cj6i92avk001le1txuqpq3put","_id":"cj6i92avr001ye1txqufkfmdw"},{"post_id":"cj6i92aux0007e1txvvdal8n1","tag_id":"cj6i92avl001oe1txdq2585lg","_id":"cj6i92avr001ze1txbxgg9538"},{"post_id":"cj6i92aux0007e1txvvdal8n1","tag_id":"cj6i92avn001qe1txgd60tj6u","_id":"cj6i92avt0021e1txy1vl5yca"},{"post_id":"cj6i92aux0007e1txvvdal8n1","tag_id":"cj6i92avg0014e1txfomb2rnd","_id":"cj6i92avt0022e1txpho1w5ax"},{"post_id":"cj6i92aux0007e1txvvdal8n1","tag_id":"cj6i92avn001se1tx53697myq","_id":"cj6i92avu0024e1txd78n7e4i"},{"post_id":"cj6i92aux0007e1txvvdal8n1","tag_id":"cj6i92avo001te1txv840hoga","_id":"cj6i92avu0025e1tx0d8fjmhg"},{"post_id":"cj6i92auy0008e1txqhp9v106","tag_id":"cj6i92aum0002e1txcprsd5ky","_id":"cj6i92avx0028e1txma5wpxnj"},{"post_id":"cj6i92auy0008e1txqhp9v106","tag_id":"cj6i92avd000qe1txddspzj0e","_id":"cj6i92avx0029e1txkl6nqpc1"},{"post_id":"cj6i92auy0008e1txqhp9v106","tag_id":"cj6i92avq001xe1txgn230cej","_id":"cj6i92avx002be1txbs5isbub"},{"post_id":"cj6i92auy0008e1txqhp9v106","tag_id":"cj6i92avg0012e1txdn46d685","_id":"cj6i92avx002ce1txir72y50a"},{"post_id":"cj6i92auy0008e1txqhp9v106","tag_id":"cj6i92avg0014e1txfomb2rnd","_id":"cj6i92avx002ee1tx98tsqv4r"},{"post_id":"cj6i92auy0008e1txqhp9v106","tag_id":"cj6i92avu0026e1txs9mdd4vs","_id":"cj6i92avy002fe1tx6tv5lhmq"},{"post_id":"cj6i92av2000ae1txzd3w04cw","tag_id":"cj6i92aum0002e1txcprsd5ky","_id":"cj6i92avy002je1txlyxfwj85"},{"post_id":"cj6i92av2000ae1txzd3w04cw","tag_id":"cj6i92avu0027e1txep9uqnrv","_id":"cj6i92avy002ke1tx26nsi4cf"},{"post_id":"cj6i92av2000ae1txzd3w04cw","tag_id":"cj6i92avk001ie1txr1zo9fc7","_id":"cj6i92avz002me1txc2fwb8ns"},{"post_id":"cj6i92av2000ae1txzd3w04cw","tag_id":"cj6i92avx002de1tx76nwd4oc","_id":"cj6i92aw3002ne1txg01vqcwn"},{"post_id":"cj6i92av2000ae1txzd3w04cw","tag_id":"cj6i92avy002ge1txpzb3qikf","_id":"cj6i92aw4002pe1txt40qo696"},{"post_id":"cj6i92av2000ae1txzd3w04cw","tag_id":"cj6i92avy002he1txn6mpuhfu","_id":"cj6i92aw5002qe1txhbeav29k"},{"post_id":"cj6i92av4000be1txgy6ubl9b","tag_id":"cj6i92aum0002e1txcprsd5ky","_id":"cj6i92aw6002te1tx7e5szd9a"},{"post_id":"cj6i92av4000be1txgy6ubl9b","tag_id":"cj6i92avy002ie1txrz4v0g6b","_id":"cj6i92aw6002ue1txkk26cpl1"},{"post_id":"cj6i92av4000be1txgy6ubl9b","tag_id":"cj6i92avk001le1txuqpq3put","_id":"cj6i92aw7002we1txn4eywijv"},{"post_id":"cj6i92av4000be1txgy6ubl9b","tag_id":"cj6i92avg0014e1txfomb2rnd","_id":"cj6i92aw7002xe1tx43psa562"},{"post_id":"cj6i92av4000be1txgy6ubl9b","tag_id":"cj6i92aw5002re1txf6cka2as","_id":"cj6i92aw7002ze1tx2ocqurs5"},{"post_id":"cj6i92av5000de1tx3e8cw0g3","tag_id":"cj6i92aum0002e1txcprsd5ky","_id":"cj6i92aw80031e1txn8tf6wit"},{"post_id":"cj6i92av5000de1tx3e8cw0g3","tag_id":"cj6i92avy002ie1txrz4v0g6b","_id":"cj6i92aw80032e1txt1dvqte9"},{"post_id":"cj6i92av5000de1tx3e8cw0g3","tag_id":"cj6i92avk001le1txuqpq3put","_id":"cj6i92aw80033e1txn5c1km43"},{"post_id":"cj6i92av5000de1tx3e8cw0g3","tag_id":"cj6i92avg0014e1txfomb2rnd","_id":"cj6i92aw80034e1txsnzipzqw"},{"post_id":"cj6i92av5000de1tx3e8cw0g3","tag_id":"cj6i92aw70030e1txpmfdfoka","_id":"cj6i92aw80035e1tx9bftpsdl"}],"Tag":[{"name":"weekly","_id":"cj6i92aum0002e1txcprsd5ky"},{"name":"es6","_id":"cj6i92auw0006e1txl1041d3y"},{"name":"vue","_id":"cj6i92av10009e1tx2h6ryd54"},{"name":"算法","_id":"cj6i92av5000ce1txcy3srjrt"},{"name":"工具","_id":"cj6i92av7000ee1txdszv1th3"},{"name":"必备技能","_id":"cj6i92av8000fe1txn5n7zuma"},{"name":"框架","_id":"cj6i92avb000je1tx3b6r44uk"},{"name":"测试","_id":"cj6i92avb000me1txwwkgwyjv"},{"name":"设计模式","_id":"cj6i92avc000pe1txft9sd1yx"},{"name":"three.js","_id":"cj6i92avd000qe1txddspzj0e"},{"name":"全栈","_id":"cj6i92ave000ue1txwsigvb28"},{"name":"Node","_id":"cj6i92avf000xe1tx1nbu3dr8"},{"name":"Echarts","_id":"cj6i92avf000ze1txuei4381s"},{"name":"ES6","_id":"cj6i92avg0012e1txdn46d685"},{"name":"Vue","_id":"cj6i92avg0014e1txfomb2rnd"},{"name":"SVG","_id":"cj6i92avh0015e1txuth1rp6q"},{"name":"模块化","_id":"cj6i92avh0017e1txmidzviyr"},{"name":"性能优化","_id":"cj6i92avi0018e1txb170vdpo"},{"name":"Event-Driven","_id":"cj6i92avi0019e1tx2swr3jed"},{"name":"Vuex","_id":"cj6i92avk001ie1txr1zo9fc7"},{"name":"node","_id":"cj6i92avk001le1txuqpq3put"},{"name":"WebSocket","_id":"cj6i92avl001oe1txdq2585lg"},{"name":"http","_id":"cj6i92avn001qe1txgd60tj6u"},{"name":"iView","_id":"cj6i92avn001se1tx53697myq"},{"name":"Git","_id":"cj6i92avo001te1txv840hoga"},{"name":"Zepto","_id":"cj6i92avq001xe1txgn230cej"},{"name":"事件驱动","_id":"cj6i92avu0026e1txs9mdd4vs"},{"name":"工程化实践","_id":"cj6i92avu0027e1txep9uqnrv"},{"name":"Webpack","_id":"cj6i92avx002de1tx76nwd4oc"},{"name":"PWA","_id":"cj6i92avy002ge1txpzb3qikf"},{"name":"持续部署","_id":"cj6i92avy002he1txn6mpuhfu"},{"name":"模块","_id":"cj6i92avy002ie1txrz4v0g6b"},{"name":"函数式","_id":"cj6i92aw5002re1txf6cka2as"},{"name":"API设计，单元测试","_id":"cj6i92aw70030e1txpmfdfoka"}]}}